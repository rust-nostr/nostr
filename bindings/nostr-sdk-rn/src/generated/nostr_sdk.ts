// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
  type UniffiVTableCallbackInterfaceAdmitPolicy,
  type UniffiVTableCallbackInterfaceCustomNostrSigner,
  type UniffiVTableCallbackInterfaceCustomWebSocketTransport,
  type UniffiVTableCallbackInterfaceHandleNotification,
  type UniffiVTableCallbackInterfaceWebSocketAdapter,
} from './nostr_sdk-ffi';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiDuration,
  type UniffiHandle,
  type UniffiObjectFactory,
  type UniffiReferenceHolder,
  type UniffiRustArcPtr,
  type UniffiRustCallStatus,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterDuration,
  FfiConverterFloat64,
  FfiConverterInt32,
  FfiConverterInt64,
  FfiConverterMap,
  FfiConverterObject,
  FfiConverterObjectWithCallbacks,
  FfiConverterOptional,
  FfiConverterUInt16,
  FfiConverterUInt32,
  FfiConverterUInt64,
  FfiConverterUInt8,
  RustBuffer,
  UniffiAbstractObject,
  UniffiEnum,
  UniffiError,
  UniffiInternalError,
  UniffiResult,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiRustCallAsync,
  uniffiTraitInterfaceCall,
  uniffiTraitInterfaceCallAsync,
  uniffiTraitInterfaceCallAsyncWithError,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller();

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

/**
 * Create a NIP26 delegation tag (including the signature).
 * See also validate_delegation_tag().
 *
 * <https://github.com/nostr-protocol/nips/blob/master/26.md>
 */
export function createDelegationTag(
  delegatorKeys: KeysInterface,
  delegateePubkey: PublicKeyInterface,
  conditions: string
): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_create_delegation_tag(
          FfiConverterTypeKeys.lower(delegatorKeys),
          FfiConverterTypePublicKey.lower(delegateePubkey),
          FfiConverterString.lower(conditions),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function decryptReceivedPrivateZapMessage(
  secretKey: SecretKeyInterface,
  privateZap: EventInterface
): EventInterface /*throws*/ {
  return FfiConverterTypeEvent.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_decrypt_received_private_zap_message(
          FfiConverterTypeSecretKey.lower(secretKey),
          FfiConverterTypeEvent.lower(privateZap),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function decryptSentPrivateZapMessage(
  secretKey: SecretKeyInterface,
  publicKey: PublicKeyInterface,
  privateZap: EventInterface
): EventInterface /*throws*/ {
  return FfiConverterTypeEvent.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_decrypt_sent_private_zap_message(
          FfiConverterTypeSecretKey.lower(secretKey),
          FfiConverterTypePublicKey.lower(publicKey),
          FfiConverterTypeEvent.lower(privateZap),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Extracts the relay info (url, optional read/write flag) from the event
 */
export function extractRelayList(
  event: EventInterface
): Map<string, RelayMetadata | undefined> {
  return FfiConverterMapStringOptionalTypeRelayMetadata.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_extract_relay_list(
          FfiConverterTypeEvent.lower(event),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Generate shared key
 *
 * **Important: use of a strong cryptographic hash function may be critical to security! Do NOT use
 * unless you understand cryptographical implications.**
 */
export function generateSharedKey(
  secretKey: SecretKeyInterface,
  publicKey: PublicKeyInterface
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_generate_shared_key(
          FfiConverterTypeSecretKey.lower(secretKey),
          FfiConverterTypePublicKey.lower(publicKey),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Gets the number of leading zero bits. Result is between 0 and 255.
 */
export function getLeadingZeroBits(bytes: ArrayBuffer): /*u8*/ number {
  return FfiConverterUInt8.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_get_leading_zero_bits(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Get NIP05 profile
 *
 * <https://github.com/nostr-protocol/nips/blob/master/05.md>
 */
export async function getNip05Profile(
  nip05: string,
  proxy: string | undefined = undefined,
  asyncOpts_?: { signal: AbortSignal }
): Promise<Nip05ProfileInterface> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_get_nip05_profile(
          FfiConverterString.lower(nip05),
          FfiConverterOptionalString.lower(proxy)
        );
      },
      /*pollFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
      /*freeFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
      /*liftFunc:*/ FfiConverterTypeNip05Profile.lift.bind(
        FfiConverterTypeNip05Profile
      ),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
/**
 * Get the nip96.json file on the server and return the JSON as a `ServerConfig`
 *
 * <https://github.com/nostr-protocol/nips/blob/master/96.md>
 */
export async function getNip96ServerConfig(
  serverUrl: string,
  proxy: string | undefined = undefined,
  asyncOpts_?: { signal: AbortSignal }
): Promise<ServerConfigInterface> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_get_nip96_server_config(
          FfiConverterString.lower(serverUrl),
          FfiConverterOptionalString.lower(proxy)
        );
      },
      /*pollFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
      /*freeFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
      /*liftFunc:*/ FfiConverterTypeServerConfig.lift.bind(
        FfiConverterTypeServerConfig
      ),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
/**
 * Returns all possible ID prefixes (hex) that have the specified number of leading zero bits.
 *
 * Possible values: 0-255
 */
export function getPrefixesForDifficulty(
  leadingZeroBits: /*u8*/ number
): Array<string> {
  return FfiConverterArrayString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_get_prefixes_for_difficulty(
          FfiConverterUInt8.lower(leadingZeroBits),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Build Gift Wrap
 *
 * <https://github.com/nostr-protocol/nips/blob/master/59.md>
 */
export async function giftWrap(
  signer: NostrSignerInterface,
  receiverPubkey: PublicKeyInterface,
  rumor: UnsignedEventInterface,
  extraTags: Array<TagInterface> = [],
  asyncOpts_?: { signal: AbortSignal }
): Promise<EventInterface> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_gift_wrap(
          FfiConverterTypeNostrSigner.lower(signer),
          FfiConverterTypePublicKey.lower(receiverPubkey),
          FfiConverterTypeUnsignedEvent.lower(rumor),
          FfiConverterArrayTypeTag.lower(extraTags)
        );
      },
      /*pollFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
      /*freeFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
      /*liftFunc:*/ FfiConverterTypeEvent.lift.bind(FfiConverterTypeEvent),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
/**
 * Build Gift Wrap from Seal
 *
 * <https://github.com/nostr-protocol/nips/blob/master/59.md>
 */
export function giftWrapFromSeal(
  receiver: PublicKeyInterface,
  seal: EventInterface,
  extraTags: Array<TagInterface> = []
): EventInterface /*throws*/ {
  return FfiConverterTypeEvent.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_gift_wrap_from_seal(
          FfiConverterTypePublicKey.lower(receiver),
          FfiConverterTypeEvent.lower(seal),
          FfiConverterArrayTypeTag.lower(extraTags),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Get git hash version of `rust-nostr` libraries
 */
export function gitHashVersion(): string | undefined {
  return FfiConverterOptionalString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_git_hash_version(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function initLogger(level: LogLevel): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_init_logger(
        FfiConverterTypeLogLevel.lower(level),
        callStatus
      );
    },
    /*liftString:*/ FfiConverterString.lift
  );
}
/**
 * Private Direct message
 *
 * <https://github.com/nostr-protocol/nips/blob/master/17.md>
 */
export async function makePrivateMsg(
  signer: NostrSignerInterface,
  receiver: PublicKeyInterface,
  message: string,
  rumorExtraTags: Array<TagInterface> = [],
  asyncOpts_?: { signal: AbortSignal }
): Promise<EventInterface> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_make_private_msg(
          FfiConverterTypeNostrSigner.lower(signer),
          FfiConverterTypePublicKey.lower(receiver),
          FfiConverterString.lower(message),
          FfiConverterArrayTypeTag.lower(rumorExtraTags)
        );
      },
      /*pollFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
      /*freeFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
      /*liftFunc:*/ FfiConverterTypeEvent.lift.bind(FfiConverterTypeEvent),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
export function nip04Decrypt(
  secretKey: SecretKeyInterface,
  publicKey: PublicKeyInterface,
  encryptedContent: string
): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_nip04_decrypt(
          FfiConverterTypeSecretKey.lower(secretKey),
          FfiConverterTypePublicKey.lower(publicKey),
          FfiConverterString.lower(encryptedContent),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function nip04Encrypt(
  secretKey: SecretKeyInterface,
  publicKey: PublicKeyInterface,
  content: string
): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_nip04_encrypt(
          FfiConverterTypeSecretKey.lower(secretKey),
          FfiConverterTypePublicKey.lower(publicKey),
          FfiConverterString.lower(content),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export async function nip11GetInformationDocument(
  url: string,
  proxy: string | undefined = undefined,
  asyncOpts_?: { signal: AbortSignal }
): Promise<RelayInformationDocumentInterface> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_nip11_get_information_document(
          FfiConverterString.lower(url),
          FfiConverterOptionalString.lower(proxy)
        );
      },
      /*pollFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
      /*freeFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
      /*liftFunc:*/ FfiConverterTypeRelayInformationDocument.lift.bind(
        FfiConverterTypeRelayInformationDocument
      ),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
/**
 * Extract `nostr:` URIs from a text
 */
export function nip21ExtractFromText(text: string): Array<Nip21Interface> {
  return FfiConverterArrayTypeNip21.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_nip21_extract_from_text(
          FfiConverterString.lower(text),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function nip44Decrypt(
  secretKey: SecretKeyInterface,
  publicKey: PublicKeyInterface,
  payload: string
): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_nip44_decrypt(
          FfiConverterTypeSecretKey.lower(secretKey),
          FfiConverterTypePublicKey.lower(publicKey),
          FfiConverterString.lower(payload),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function nip44Encrypt(
  secretKey: SecretKeyInterface,
  publicKey: PublicKeyInterface,
  content: string,
  version: Nip44Version
): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_nip44_encrypt(
          FfiConverterTypeSecretKey.lower(secretKey),
          FfiConverterTypePublicKey.lower(publicKey),
          FfiConverterString.lower(content),
          FfiConverterTypeNip44Version.lower(version),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function nip57AnonymousZapRequest(
  data: ZapRequestDataInterface
): EventInterface /*throws*/ {
  return FfiConverterTypeEvent.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_nip57_anonymous_zap_request(
          FfiConverterTypeZapRequestData.lower(data),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function nip57PrivateZapRequest(
  data: ZapRequestDataInterface,
  keys: KeysInterface
): EventInterface /*throws*/ {
  return FfiConverterTypeEvent.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_nip57_private_zap_request(
          FfiConverterTypeZapRequestData.lower(data),
          FfiConverterTypeKeys.lower(keys),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uploads some data to a NIP-96 server and returns the file's download URL
 *
 * <https://github.com/nostr-protocol/nips/blob/master/96.md>
 */
export async function nip96Upload(
  signer: NostrSignerInterface,
  config: ServerConfigInterface,
  fileData: ArrayBuffer,
  mimeType: string | undefined = undefined,
  proxy: string | undefined = undefined,
  asyncOpts_?: { signal: AbortSignal }
): Promise<string> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_nip96_upload(
          FfiConverterTypeNostrSigner.lower(signer),
          FfiConverterTypeServerConfig.lower(config),
          FfiConverterArrayBuffer.lower(fileData),
          FfiConverterOptionalString.lower(mimeType),
          FfiConverterOptionalString.lower(proxy)
        );
      },
      /*pollFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
      /*freeFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
      /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
/**
 * Sign delegation.
 * See `create_delegation_tag` for more complete functionality.
 *
 * <https://github.com/nostr-protocol/nips/blob/master/26.md>
 */
export function signDelegation(
  delegatorKeys: KeysInterface,
  delegateePk: PublicKeyInterface,
  conditions: string
): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_sign_delegation(
          FfiConverterTypeKeys.lower(delegatorKeys),
          FfiConverterTypePublicKey.lower(delegateePk),
          FfiConverterString.lower(conditions),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Convert tag kind to string
 */
export function tagKindToString(kind: TagKind): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_tag_kind_to_string(
          FfiConverterTypeTagKind.lower(kind),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Validate a NIP26 delegation tag, check signature and conditions.
 *
 * <https://github.com/nostr-protocol/nips/blob/master/26.md>
 */
export function validateDelegationTag(
  delegationTag: string,
  delegateePubkey: PublicKeyInterface,
  eventKind: KindInterface,
  createdAt: /*u64*/ bigint
): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_validate_delegation_tag(
          FfiConverterString.lower(delegationTag),
          FfiConverterTypePublicKey.lower(delegateePubkey),
          FfiConverterTypeKind.lower(eventKind),
          FfiConverterUInt64.lower(createdAt),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Verify delegation signature
 *
 * <https://github.com/nostr-protocol/nips/blob/master/26.md>
 */
export function verifyDelegationSignature(
  delegatorPublicKey: PublicKeyInterface,
  delegateePublicKey: PublicKeyInterface,
  conditions: string,
  signature: string
): boolean /*throws*/ {
  return FfiConverterBool.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_verify_delegation_signature(
          FfiConverterTypePublicKey.lower(delegatorPublicKey),
          FfiConverterTypePublicKey.lower(delegateePublicKey),
          FfiConverterString.lower(conditions),
          FfiConverterString.lower(signature),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export async function verifyNip05(
  publicKey: PublicKeyInterface,
  nip05: string,
  proxy: string | undefined = undefined,
  asyncOpts_?: { signal: AbortSignal }
): Promise<boolean> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_func_verify_nip05(
          FfiConverterTypePublicKey.lower(publicKey),
          FfiConverterString.lower(nip05),
          FfiConverterOptionalString.lower(proxy)
        );
      },
      /*pollFunc:*/ nativeModule().ubrn_ffi_nostr_sdk_ffi_rust_future_poll_i8,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_i8,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_i8,
      /*freeFunc:*/ nativeModule().ubrn_ffi_nostr_sdk_ffi_rust_future_free_i8,
      /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}

/**
 * Groups of articles picked by users as interesting and/or belonging to the same category
 *
 * <https://github.com/nostr-protocol/nips/blob/master/51.md>
 */
export type ArticlesCuration = {
  /**
   * Coordinates
   */
  coordinate: Array<CoordinateInterface>;
  /**
   * Event IDs
   */
  eventIds: Array<EventIdInterface>;
};

/**
 * Generated factory for {@link ArticlesCuration} record objects.
 */
export const ArticlesCuration = (() => {
  const defaults = () => ({ coordinate: [], eventIds: [] });
  const create = (() => {
    return uniffiCreateRecord<ArticlesCuration, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ArticlesCuration}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ArticlesCuration}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ArticlesCuration>,
  });
})();

const FfiConverterTypeArticlesCuration = (() => {
  type TypeName = ArticlesCuration;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        coordinate: FfiConverterArrayTypeCoordinate.read(from),
        eventIds: FfiConverterArrayTypeEventId.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeCoordinate.write(value.coordinate, into);
      FfiConverterArrayTypeEventId.write(value.eventIds, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeCoordinate.allocationSize(value.coordinate) +
        FfiConverterArrayTypeEventId.allocationSize(value.eventIds)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Uncategorized, "global" list of things a user wants to save
 *
 * <https://github.com/nostr-protocol/nips/blob/master/51.md>
 */
export type Bookmarks = {
  eventIds: Array<EventIdInterface>;
  coordinate: Array<CoordinateInterface>;
  hashtags: Array<string>;
  urls: Array<string>;
};

/**
 * Generated factory for {@link Bookmarks} record objects.
 */
export const Bookmarks = (() => {
  const defaults = () => ({
    eventIds: [],
    coordinate: [],
    hashtags: [],
    urls: [],
  });
  const create = (() => {
    return uniffiCreateRecord<Bookmarks, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Bookmarks}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Bookmarks}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Bookmarks>,
  });
})();

const FfiConverterTypeBookmarks = (() => {
  type TypeName = Bookmarks;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        eventIds: FfiConverterArrayTypeEventId.read(from),
        coordinate: FfiConverterArrayTypeCoordinate.read(from),
        hashtags: FfiConverterArrayString.read(from),
        urls: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeEventId.write(value.eventIds, into);
      FfiConverterArrayTypeCoordinate.write(value.coordinate, into);
      FfiConverterArrayString.write(value.hashtags, into);
      FfiConverterArrayString.write(value.urls, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeEventId.allocationSize(value.eventIds) +
        FfiConverterArrayTypeCoordinate.allocationSize(value.coordinate) +
        FfiConverterArrayString.allocationSize(value.hashtags) +
        FfiConverterArrayString.allocationSize(value.urls)
      );
    }
  }
  return new FFIConverter();
})();

export type Contact = {
  publicKey: PublicKeyInterface;
  relayUrl: string | undefined;
  alias: string | undefined;
};

/**
 * Generated factory for {@link Contact} record objects.
 */
export const Contact = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Contact, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Contact}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Contact}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Contact>,
  });
})();

const FfiConverterTypeContact = (() => {
  type TypeName = Contact;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        publicKey: FfiConverterTypePublicKey.read(from),
        relayUrl: FfiConverterOptionalString.read(from),
        alias: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePublicKey.write(value.publicKey, into);
      FfiConverterOptionalString.write(value.relayUrl, into);
      FfiConverterOptionalString.write(value.alias, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypePublicKey.allocationSize(value.publicKey) +
        FfiConverterOptionalString.allocationSize(value.relayUrl) +
        FfiConverterOptionalString.allocationSize(value.alias)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Emoji
 *
 * <https://github.com/nostr-protocol/nips/blob/master/51.md>
 */
export type EmojiInfo = {
  shortcode: string;
  url: string;
};

/**
 * Generated factory for {@link EmojiInfo} record objects.
 */
export const EmojiInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<EmojiInfo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EmojiInfo}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link EmojiInfo}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<EmojiInfo>,
  });
})();

const FfiConverterTypeEmojiInfo = (() => {
  type TypeName = EmojiInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        shortcode: FfiConverterString.read(from),
        url: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.shortcode, into);
      FfiConverterString.write(value.url, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.shortcode) +
        FfiConverterString.allocationSize(value.url)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * User preferred emojis and pointers to emoji sets
 *
 * <https://github.com/nostr-protocol/nips/blob/master/51.md>
 */
export type Emojis = {
  /**
   * Emojis
   */
  emojis: Array<EmojiInfo>;
  /**
   * Coordinates
   */
  coordinate: Array<CoordinateInterface>;
};

/**
 * Generated factory for {@link Emojis} record objects.
 */
export const Emojis = (() => {
  const defaults = () => ({ emojis: [], coordinate: [] });
  const create = (() => {
    return uniffiCreateRecord<Emojis, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Emojis}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Emojis}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Emojis>,
  });
})();

const FfiConverterTypeEmojis = (() => {
  type TypeName = Emojis;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        emojis: FfiConverterArrayTypeEmojiInfo.read(from),
        coordinate: FfiConverterArrayTypeCoordinate.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeEmojiInfo.write(value.emojis, into);
      FfiConverterArrayTypeCoordinate.write(value.coordinate, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeEmojiInfo.allocationSize(value.emojis) +
        FfiConverterArrayTypeCoordinate.allocationSize(value.coordinate)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Event deletion request
 */
export type EventDeletionRequest = {
  /**
   * Event IDs
   */
  ids: Array<EventIdInterface>;
  /**
   * Event coordinates
   */
  coordinates: Array<CoordinateInterface>;
  /**
   * Optional reason
   */
  reason: string | undefined;
};

/**
 * Generated factory for {@link EventDeletionRequest} record objects.
 */
export const EventDeletionRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      EventDeletionRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EventDeletionRequest}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link EventDeletionRequest}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<EventDeletionRequest>,
  });
})();

const FfiConverterTypeEventDeletionRequest = (() => {
  type TypeName = EventDeletionRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        ids: FfiConverterArrayTypeEventId.read(from),
        coordinates: FfiConverterArrayTypeCoordinate.read(from),
        reason: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeEventId.write(value.ids, into);
      FfiConverterArrayTypeCoordinate.write(value.coordinates, into);
      FfiConverterOptionalString.write(value.reason, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeEventId.allocationSize(value.ids) +
        FfiConverterArrayTypeCoordinate.allocationSize(value.coordinates) +
        FfiConverterOptionalString.allocationSize(value.reason)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * The specific information about a fee schedule
 */
export type FeeSchedule = {
  /**
   * The fee amount
   */
  amount: /*i32*/ number;
  /**
   * The denomination of the feed
   */
  unit: string;
  /**
   * The duration for which the fee is valid
   */
  period: /*i32*/ number | undefined;
  /**
   * The event kinds the fee allows the client to publish to the relay
   */
  kinds: Array<string> | undefined;
};

/**
 * Generated factory for {@link FeeSchedule} record objects.
 */
export const FeeSchedule = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FeeSchedule, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FeeSchedule}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FeeSchedule}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FeeSchedule>,
  });
})();

const FfiConverterTypeFeeSchedule = (() => {
  type TypeName = FeeSchedule;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        amount: FfiConverterInt32.read(from),
        unit: FfiConverterString.read(from),
        period: FfiConverterOptionalInt32.read(from),
        kinds: FfiConverterOptionalArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterInt32.write(value.amount, into);
      FfiConverterString.write(value.unit, into);
      FfiConverterOptionalInt32.write(value.period, into);
      FfiConverterOptionalArrayString.write(value.kinds, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterInt32.allocationSize(value.amount) +
        FfiConverterString.allocationSize(value.unit) +
        FfiConverterOptionalInt32.allocationSize(value.period) +
        FfiConverterOptionalArrayString.allocationSize(value.kinds)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Available fee schedules
 */
export type FeeSchedules = {
  /**
   * Fees for admission to use the relay
   */
  admission: Array<FeeSchedule>;
  /**
   * Fees for subscription to use the relay
   */
  subscription: Array<FeeSchedule>;
  /**
   * Fees to publish to the relay
   */
  publication: Array<FeeSchedule>;
};

/**
 * Generated factory for {@link FeeSchedules} record objects.
 */
export const FeeSchedules = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FeeSchedules, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FeeSchedules}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FeeSchedules}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FeeSchedules>,
  });
})();

const FfiConverterTypeFeeSchedules = (() => {
  type TypeName = FeeSchedules;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        admission: FfiConverterArrayTypeFeeSchedule.read(from),
        subscription: FfiConverterArrayTypeFeeSchedule.read(from),
        publication: FfiConverterArrayTypeFeeSchedule.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeFeeSchedule.write(value.admission, into);
      FfiConverterArrayTypeFeeSchedule.write(value.subscription, into);
      FfiConverterArrayTypeFeeSchedule.write(value.publication, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeFeeSchedule.allocationSize(value.admission) +
        FfiConverterArrayTypeFeeSchedule.allocationSize(value.subscription) +
        FfiConverterArrayTypeFeeSchedule.allocationSize(value.publication)
      );
    }
  }
  return new FFIConverter();
})();

export type FilterRecord = {
  ids: Array<EventIdInterface> | undefined;
  authors: Array<PublicKeyInterface> | undefined;
  kinds: Array<KindInterface> | undefined;
  /**
   * It's a string describing a query in a human-readable form, i.e. "best nostr apps"
   *
   * <https://github.com/nostr-protocol/nips/blob/master/50.md>
   */
  search: string | undefined;
  /**
   * An integer unix timestamp, events must be newer than this to pass
   */
  since: TimestampInterface | undefined;
  /**
   * An integer unix timestamp, events must be older than this to pass
   */
  until: TimestampInterface | undefined;
  /**
   * Maximum number of events to be returned in the initial query
   */
  limit: /*u64*/ bigint | undefined;
  /**
   * Generic tag queries
   */
  genericTags: Array<GenericTag>;
};

/**
 * Generated factory for {@link FilterRecord} record objects.
 */
export const FilterRecord = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FilterRecord, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FilterRecord}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FilterRecord}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FilterRecord>,
  });
})();

const FfiConverterTypeFilterRecord = (() => {
  type TypeName = FilterRecord;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        ids: FfiConverterOptionalArrayTypeEventId.read(from),
        authors: FfiConverterOptionalArrayTypePublicKey.read(from),
        kinds: FfiConverterOptionalArrayTypeKind.read(from),
        search: FfiConverterOptionalString.read(from),
        since: FfiConverterOptionalTypeTimestamp.read(from),
        until: FfiConverterOptionalTypeTimestamp.read(from),
        limit: FfiConverterOptionalUInt64.read(from),
        genericTags: FfiConverterArrayTypeGenericTag.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalArrayTypeEventId.write(value.ids, into);
      FfiConverterOptionalArrayTypePublicKey.write(value.authors, into);
      FfiConverterOptionalArrayTypeKind.write(value.kinds, into);
      FfiConverterOptionalString.write(value.search, into);
      FfiConverterOptionalTypeTimestamp.write(value.since, into);
      FfiConverterOptionalTypeTimestamp.write(value.until, into);
      FfiConverterOptionalUInt64.write(value.limit, into);
      FfiConverterArrayTypeGenericTag.write(value.genericTags, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalArrayTypeEventId.allocationSize(value.ids) +
        FfiConverterOptionalArrayTypePublicKey.allocationSize(value.authors) +
        FfiConverterOptionalArrayTypeKind.allocationSize(value.kinds) +
        FfiConverterOptionalString.allocationSize(value.search) +
        FfiConverterOptionalTypeTimestamp.allocationSize(value.since) +
        FfiConverterOptionalTypeTimestamp.allocationSize(value.until) +
        FfiConverterOptionalUInt64.allocationSize(value.limit) +
        FfiConverterArrayTypeGenericTag.allocationSize(value.genericTags)
      );
    }
  }
  return new FFIConverter();
})();

export type GenericTag = {
  key: SingleLetterTagInterface;
  value: Array<string>;
};

/**
 * Generated factory for {@link GenericTag} record objects.
 */
export const GenericTag = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GenericTag, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GenericTag}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GenericTag}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GenericTag>,
  });
})();

const FfiConverterTypeGenericTag = (() => {
  type TypeName = GenericTag;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        key: FfiConverterTypeSingleLetterTag.read(from),
        value: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeSingleLetterTag.write(value.key, into);
      FfiConverterArrayString.write(value.value, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeSingleLetterTag.allocationSize(value.key) +
        FfiConverterArrayString.allocationSize(value.value)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * NIP47 Response Result
 */
export type GetBalanceResponse = {
  /**
   * Balance amount in msats
   */
  balance: /*u64*/ bigint;
};

/**
 * Generated factory for {@link GetBalanceResponse} record objects.
 */
export const GetBalanceResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GetBalanceResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetBalanceResponse}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetBalanceResponse}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GetBalanceResponse>,
  });
})();

const FfiConverterTypeGetBalanceResponse = (() => {
  type TypeName = GetBalanceResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        balance: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.balance, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterUInt64.allocationSize(value.balance);
    }
  }
  return new FFIConverter();
})();

/**
 * NIP47 Response Result
 */
export type GetInfoResponse = {
  /**
   * The alias of the lightning node
   */
  alias: string | undefined;
  /**
   * The color of the current node in hex code format
   */
  color: string | undefined;
  /**
   * Lightning Node's public key
   */
  pubkey: string | undefined;
  /**
   * Active network
   */
  network: string | undefined;
  /**
   * Current block height
   */
  blockHeight: /*u32*/ number | undefined;
  /**
   * Most Recent Block Hash
   */
  blockHash: string | undefined;
  /**
   * Available methods for this connection
   */
  methods: Array<string>;
  /**
   * List of supported notifications for this connection (optional)
   */
  notifications: Array<string>;
};

/**
 * Generated factory for {@link GetInfoResponse} record objects.
 */
export const GetInfoResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GetInfoResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GetInfoResponse}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GetInfoResponse}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GetInfoResponse>,
  });
})();

const FfiConverterTypeGetInfoResponse = (() => {
  type TypeName = GetInfoResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        alias: FfiConverterOptionalString.read(from),
        color: FfiConverterOptionalString.read(from),
        pubkey: FfiConverterOptionalString.read(from),
        network: FfiConverterOptionalString.read(from),
        blockHeight: FfiConverterOptionalUInt32.read(from),
        blockHash: FfiConverterOptionalString.read(from),
        methods: FfiConverterArrayString.read(from),
        notifications: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.alias, into);
      FfiConverterOptionalString.write(value.color, into);
      FfiConverterOptionalString.write(value.pubkey, into);
      FfiConverterOptionalString.write(value.network, into);
      FfiConverterOptionalUInt32.write(value.blockHeight, into);
      FfiConverterOptionalString.write(value.blockHash, into);
      FfiConverterArrayString.write(value.methods, into);
      FfiConverterArrayString.write(value.notifications, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.alias) +
        FfiConverterOptionalString.allocationSize(value.color) +
        FfiConverterOptionalString.allocationSize(value.pubkey) +
        FfiConverterOptionalString.allocationSize(value.network) +
        FfiConverterOptionalUInt32.allocationSize(value.blockHeight) +
        FfiConverterOptionalString.allocationSize(value.blockHash) +
        FfiConverterArrayString.allocationSize(value.methods) +
        FfiConverterArrayString.allocationSize(value.notifications)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Git Issue
 */
export type GitIssue = {
  /**
   * The repository address
   */
  repository: CoordinateInterface;
  /**
   * The issue content (markdown)
   */
  content: string;
  /**
   * Subject
   */
  subject: string | undefined;
  /**
   * Labels
   */
  labels: Array<string>;
};

/**
 * Generated factory for {@link GitIssue} record objects.
 */
export const GitIssue = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GitIssue, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GitIssue}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GitIssue}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GitIssue>,
  });
})();

const FfiConverterTypeGitIssue = (() => {
  type TypeName = GitIssue;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        repository: FfiConverterTypeCoordinate.read(from),
        content: FfiConverterString.read(from),
        subject: FfiConverterOptionalString.read(from),
        labels: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeCoordinate.write(value.repository, into);
      FfiConverterString.write(value.content, into);
      FfiConverterOptionalString.write(value.subject, into);
      FfiConverterArrayString.write(value.labels, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeCoordinate.allocationSize(value.repository) +
        FfiConverterString.allocationSize(value.content) +
        FfiConverterOptionalString.allocationSize(value.subject) +
        FfiConverterArrayString.allocationSize(value.labels)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Git Patch
 */
export type GitPatch = {
  /**
   * Repository
   */
  repository: CoordinateInterface;
  /**
   * Patch
   */
  content: GitPatchContent;
  /**
   * Earliest unique commit ID of repo
   */
  euc: string;
  /**
   * Labels
   */
  labels: Array<string>;
};

/**
 * Generated factory for {@link GitPatch} record objects.
 */
export const GitPatch = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GitPatch, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GitPatch}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GitPatch}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GitPatch>,
  });
})();

const FfiConverterTypeGitPatch = (() => {
  type TypeName = GitPatch;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        repository: FfiConverterTypeCoordinate.read(from),
        content: FfiConverterTypeGitPatchContent.read(from),
        euc: FfiConverterString.read(from),
        labels: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeCoordinate.write(value.repository, into);
      FfiConverterTypeGitPatchContent.write(value.content, into);
      FfiConverterString.write(value.euc, into);
      FfiConverterArrayString.write(value.labels, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeCoordinate.allocationSize(value.repository) +
        FfiConverterTypeGitPatchContent.allocationSize(value.content) +
        FfiConverterString.allocationSize(value.euc) +
        FfiConverterArrayString.allocationSize(value.labels)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Git Patch Committer
 */
export type GitPatchCommitter = {
  /**
   * Name
   */
  name: string | undefined;
  /**
   * Email
   */
  email: string | undefined;
  /**
   * Timestamp
   */
  timestamp: TimestampInterface;
  /**
   * Timezone offset in minutes
   */
  offsetMinutes: /*i32*/ number;
};

/**
 * Generated factory for {@link GitPatchCommitter} record objects.
 */
export const GitPatchCommitter = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<GitPatchCommitter, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GitPatchCommitter}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GitPatchCommitter}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GitPatchCommitter>,
  });
})();

const FfiConverterTypeGitPatchCommitter = (() => {
  type TypeName = GitPatchCommitter;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        name: FfiConverterOptionalString.read(from),
        email: FfiConverterOptionalString.read(from),
        timestamp: FfiConverterTypeTimestamp.read(from),
        offsetMinutes: FfiConverterInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterOptionalString.write(value.email, into);
      FfiConverterTypeTimestamp.write(value.timestamp, into);
      FfiConverterInt32.write(value.offsetMinutes, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterOptionalString.allocationSize(value.email) +
        FfiConverterTypeTimestamp.allocationSize(value.timestamp) +
        FfiConverterInt32.allocationSize(value.offsetMinutes)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Git Repository Announcement
 *
 * Git repositories are hosted in Git-enabled servers, but their existence can be announced using Nostr events,
 * as well as their willingness to receive patches, bug reports and comments in general.
 */
export type GitRepositoryAnnouncement = {
  /**
   * Repository ID (usually kebab-case short name)
   */
  id: string;
  /**
   * Human-readable project name
   */
  name: string | undefined;
  /**
   * Brief human-readable project description
   */
  description: string | undefined;
  /**
   * Webpage urls, if the git server being used provides such a thing
   */
  web: Array<string>;
  /**
   * Urls for git-cloning
   */
  clone: Array<string>;
  /**
   * Relays that this repository will monitor for patches and issues
   */
  relays: Array<string>;
  /**
   * Earliest unique commit ID
   *
   * `euc` marker should be the commit ID of the earliest unique commit of this repo,
   * made to identify it among forks and group it with other repositories hosted elsewhere that may represent essentially the same project.
   * In most cases it will be the root commit of a repository.
   * In case of a permanent fork between two projects, then the first commit after the fork should be used.
   */
  euc: string | undefined;
  /**
   * Other recognized maintainers
   */
  maintainers: Array<PublicKeyInterface>;
};

/**
 * Generated factory for {@link GitRepositoryAnnouncement} record objects.
 */
export const GitRepositoryAnnouncement = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      GitRepositoryAnnouncement,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GitRepositoryAnnouncement}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GitRepositoryAnnouncement}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<GitRepositoryAnnouncement>,
  });
})();

const FfiConverterTypeGitRepositoryAnnouncement = (() => {
  type TypeName = GitRepositoryAnnouncement;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        name: FfiConverterOptionalString.read(from),
        description: FfiConverterOptionalString.read(from),
        web: FfiConverterArrayString.read(from),
        clone: FfiConverterArrayString.read(from),
        relays: FfiConverterArrayString.read(from),
        euc: FfiConverterOptionalString.read(from),
        maintainers: FfiConverterArrayTypePublicKey.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterOptionalString.write(value.description, into);
      FfiConverterArrayString.write(value.web, into);
      FfiConverterArrayString.write(value.clone, into);
      FfiConverterArrayString.write(value.relays, into);
      FfiConverterOptionalString.write(value.euc, into);
      FfiConverterArrayTypePublicKey.write(value.maintainers, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterOptionalString.allocationSize(value.description) +
        FfiConverterArrayString.allocationSize(value.web) +
        FfiConverterArrayString.allocationSize(value.clone) +
        FfiConverterArrayString.allocationSize(value.relays) +
        FfiConverterOptionalString.allocationSize(value.euc) +
        FfiConverterArrayTypePublicKey.allocationSize(value.maintainers)
      );
    }
  }
  return new FFIConverter();
})();

export type HttpData = {
  url: string;
  method: HttpMethod;
  payload: string | undefined;
};

/**
 * Generated factory for {@link HttpData} record objects.
 */
export const HttpData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<HttpData, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link HttpData}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link HttpData}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<HttpData>,
  });
})();

const FfiConverterTypeHttpData = (() => {
  type TypeName = HttpData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        url: FfiConverterString.read(from),
        method: FfiConverterTypeHttpMethod.read(from),
        payload: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.url, into);
      FfiConverterTypeHttpMethod.write(value.method, into);
      FfiConverterOptionalString.write(value.payload, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.url) +
        FfiConverterTypeHttpMethod.allocationSize(value.method) +
        FfiConverterOptionalString.allocationSize(value.payload)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * External identity
 *
 * <https://github.com/nostr-protocol/nips/blob/master/39.md>
 */
export type Identity = {
  /**
   * The external identity provider
   */
  platform: ExternalIdentity;
  /**
   * The user's identity (username) on the provider
   */
  ident: string;
  /**
   * The user's proof on the provider
   */
  proof: string;
};

/**
 * Generated factory for {@link Identity} record objects.
 */
export const Identity = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Identity, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Identity}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Identity}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Identity>,
  });
})();

const FfiConverterTypeIdentity = (() => {
  type TypeName = Identity;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        platform: FfiConverterTypeExternalIdentity.read(from),
        ident: FfiConverterString.read(from),
        proof: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeExternalIdentity.write(value.platform, into);
      FfiConverterString.write(value.ident, into);
      FfiConverterString.write(value.proof, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeExternalIdentity.allocationSize(value.platform) +
        FfiConverterString.allocationSize(value.ident) +
        FfiConverterString.allocationSize(value.proof)
      );
    }
  }
  return new FFIConverter();
})();

export type Image = {
  url: string;
  dimensions: ImageDimensions | undefined;
};

/**
 * Generated factory for {@link Image} record objects.
 */
export const Image = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Image, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Image}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Image}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Image>,
  });
})();

const FfiConverterTypeImage = (() => {
  type TypeName = Image;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        url: FfiConverterString.read(from),
        dimensions: FfiConverterOptionalTypeImageDimensions.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.url, into);
      FfiConverterOptionalTypeImageDimensions.write(value.dimensions, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.url) +
        FfiConverterOptionalTypeImageDimensions.allocationSize(value.dimensions)
      );
    }
  }
  return new FFIConverter();
})();

export type ImageDimensions = {
  /**
   * Width
   */
  width: /*u64*/ bigint;
  /**
   * Height
   */
  height: /*u64*/ bigint;
};

/**
 * Generated factory for {@link ImageDimensions} record objects.
 */
export const ImageDimensions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ImageDimensions, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ImageDimensions}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ImageDimensions}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ImageDimensions>,
  });
})();

const FfiConverterTypeImageDimensions = (() => {
  type TypeName = ImageDimensions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        width: FfiConverterUInt64.read(from),
        height: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.width, into);
      FfiConverterUInt64.write(value.height, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.width) +
        FfiConverterUInt64.allocationSize(value.height)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Topics a user may be interested in and pointers
 *
 * <https://github.com/nostr-protocol/nips/blob/master/51.md>
 */
export type Interests = {
  hashtags: Array<string>;
  coordinate: Array<CoordinateInterface>;
};

/**
 * Generated factory for {@link Interests} record objects.
 */
export const Interests = (() => {
  const defaults = () => ({ hashtags: [], coordinate: [] });
  const create = (() => {
    return uniffiCreateRecord<Interests, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Interests}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Interests}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Interests>,
  });
})();

const FfiConverterTypeInterests = (() => {
  type TypeName = Interests;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        hashtags: FfiConverterArrayString.read(from),
        coordinate: FfiConverterArrayTypeCoordinate.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayString.write(value.hashtags, into);
      FfiConverterArrayTypeCoordinate.write(value.coordinate, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayString.allocationSize(value.hashtags) +
        FfiConverterArrayTypeCoordinate.allocationSize(value.coordinate)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * TLVs to be added to the keysend payment
 */
export type KeysendTlvRecord = {
  /**
   * TLV type
   */
  tlvType: /*u64*/ bigint;
  /**
   * TLV value
   */
  value: string;
};

/**
 * Generated factory for {@link KeysendTlvRecord} record objects.
 */
export const KeysendTlvRecord = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<KeysendTlvRecord, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link KeysendTlvRecord}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link KeysendTlvRecord}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<KeysendTlvRecord>,
  });
})();

const FfiConverterTypeKeysendTLVRecord = (() => {
  type TypeName = KeysendTlvRecord;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        tlvType: FfiConverterUInt64.read(from),
        value: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.tlvType, into);
      FfiConverterString.write(value.value, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.tlvType) +
        FfiConverterString.allocationSize(value.value)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * These are limitations imposed by the relay on clients. Your client should
 * expect that requests which exceed these practical limitations are rejected or fail immediately.
 */
export type Limitation = {
  /**
   * Maximum number of bytes for incoming JSON that the relay will attempt to decode and act upon
   */
  maxMessageLength: /*i32*/ number | undefined;
  /**
   * Total number of subscriptions that may be active on a single websocket connection
   */
  maxSubscriptions: /*i32*/ number | undefined;
  /**
   * Maximum number of filter values in each subscription
   */
  maxFilters: /*i32*/ number | undefined;
  /**
   * Relay will clamp each filter's limit value to this number
   */
  maxLimit: /*i32*/ number | undefined;
  /**
   * Maximum length of subscription id as a string
   */
  maxSubidLength: /*i32*/ number | undefined;
  /**
   * Maximum number of elements in the tags list
   */
  maxEventTags: /*i32*/ number | undefined;
  /**
   * Maximum number of characters in the content field of any event
   */
  maxContentLength: /*i32*/ number | undefined;
  /**
   * New events will require at least this difficulty of PoW,
   */
  minPowDifficulty: /*i32*/ number | undefined;
  /**
   * Relay requires NIP42 authentication to happen before a new connection may perform any other action
   */
  authRequired: boolean | undefined;
  /**
   * Relay requires payment before a new connection may perform any action
   */
  paymentRequired: boolean | undefined;
  /**
   * 'created_at' lower limit
   */
  createdAtLowerLimit: TimestampInterface | undefined;
  /**
   * 'created_at' upper limit
   */
  createdAtUpperLimit: TimestampInterface | undefined;
};

/**
 * Generated factory for {@link Limitation} record objects.
 */
export const Limitation = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Limitation, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Limitation}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Limitation}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Limitation>,
  });
})();

const FfiConverterTypeLimitation = (() => {
  type TypeName = Limitation;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        maxMessageLength: FfiConverterOptionalInt32.read(from),
        maxSubscriptions: FfiConverterOptionalInt32.read(from),
        maxFilters: FfiConverterOptionalInt32.read(from),
        maxLimit: FfiConverterOptionalInt32.read(from),
        maxSubidLength: FfiConverterOptionalInt32.read(from),
        maxEventTags: FfiConverterOptionalInt32.read(from),
        maxContentLength: FfiConverterOptionalInt32.read(from),
        minPowDifficulty: FfiConverterOptionalInt32.read(from),
        authRequired: FfiConverterOptionalBool.read(from),
        paymentRequired: FfiConverterOptionalBool.read(from),
        createdAtLowerLimit: FfiConverterOptionalTypeTimestamp.read(from),
        createdAtUpperLimit: FfiConverterOptionalTypeTimestamp.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalInt32.write(value.maxMessageLength, into);
      FfiConverterOptionalInt32.write(value.maxSubscriptions, into);
      FfiConverterOptionalInt32.write(value.maxFilters, into);
      FfiConverterOptionalInt32.write(value.maxLimit, into);
      FfiConverterOptionalInt32.write(value.maxSubidLength, into);
      FfiConverterOptionalInt32.write(value.maxEventTags, into);
      FfiConverterOptionalInt32.write(value.maxContentLength, into);
      FfiConverterOptionalInt32.write(value.minPowDifficulty, into);
      FfiConverterOptionalBool.write(value.authRequired, into);
      FfiConverterOptionalBool.write(value.paymentRequired, into);
      FfiConverterOptionalTypeTimestamp.write(value.createdAtLowerLimit, into);
      FfiConverterOptionalTypeTimestamp.write(value.createdAtUpperLimit, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalInt32.allocationSize(value.maxMessageLength) +
        FfiConverterOptionalInt32.allocationSize(value.maxSubscriptions) +
        FfiConverterOptionalInt32.allocationSize(value.maxFilters) +
        FfiConverterOptionalInt32.allocationSize(value.maxLimit) +
        FfiConverterOptionalInt32.allocationSize(value.maxSubidLength) +
        FfiConverterOptionalInt32.allocationSize(value.maxEventTags) +
        FfiConverterOptionalInt32.allocationSize(value.maxContentLength) +
        FfiConverterOptionalInt32.allocationSize(value.minPowDifficulty) +
        FfiConverterOptionalBool.allocationSize(value.authRequired) +
        FfiConverterOptionalBool.allocationSize(value.paymentRequired) +
        FfiConverterOptionalTypeTimestamp.allocationSize(
          value.createdAtLowerLimit
        ) +
        FfiConverterOptionalTypeTimestamp.allocationSize(
          value.createdAtUpperLimit
        )
      );
    }
  }
  return new FFIConverter();
})();

/**
 * List Invoice Request
 */
export type ListTransactionsRequest = {
  /**
   * Starting timestamp in seconds since epoch
   */
  from: TimestampInterface | undefined;
  /**
   * Ending timestamp in seconds since epoch
   */
  until: TimestampInterface | undefined;
  /**
   * Number of invoices to return
   */
  limit: /*u64*/ bigint | undefined;
  /**
   * Offset of the first invoice to return
   */
  offset: /*u64*/ bigint | undefined;
  /**
   * If true, include unpaid invoices
   */
  unpaid: boolean | undefined;
  /**
   * [`TransactionType::Incoming`] for invoices, [`TransactionType::Outgoing`] for payments, [`None`] for both
   */
  transactionType: TransactionType | undefined;
};

/**
 * Generated factory for {@link ListTransactionsRequest} record objects.
 */
export const ListTransactionsRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ListTransactionsRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ListTransactionsRequest}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ListTransactionsRequest}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<ListTransactionsRequest>,
  });
})();

const FfiConverterTypeListTransactionsRequest = (() => {
  type TypeName = ListTransactionsRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        from: FfiConverterOptionalTypeTimestamp.read(from),
        until: FfiConverterOptionalTypeTimestamp.read(from),
        limit: FfiConverterOptionalUInt64.read(from),
        offset: FfiConverterOptionalUInt64.read(from),
        unpaid: FfiConverterOptionalBool.read(from),
        transactionType: FfiConverterOptionalTypeTransactionType.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalTypeTimestamp.write(value.from, into);
      FfiConverterOptionalTypeTimestamp.write(value.until, into);
      FfiConverterOptionalUInt64.write(value.limit, into);
      FfiConverterOptionalUInt64.write(value.offset, into);
      FfiConverterOptionalBool.write(value.unpaid, into);
      FfiConverterOptionalTypeTransactionType.write(
        value.transactionType,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalTypeTimestamp.allocationSize(value.from) +
        FfiConverterOptionalTypeTimestamp.allocationSize(value.until) +
        FfiConverterOptionalUInt64.allocationSize(value.limit) +
        FfiConverterOptionalUInt64.allocationSize(value.offset) +
        FfiConverterOptionalBool.allocationSize(value.unpaid) +
        FfiConverterOptionalTypeTransactionType.allocationSize(
          value.transactionType
        )
      );
    }
  }
  return new FFIConverter();
})();

export type LiveEvent = {
  id: string;
  title: string | undefined;
  summary: string | undefined;
  image: Image | undefined;
  hashtags: Array<string>;
  streaming: string | undefined;
  recording: string | undefined;
  start: TimestampInterface | undefined;
  ends: TimestampInterface | undefined;
  status: LiveEventStatus | undefined;
  currentParticipants: /*u64*/ bigint | undefined;
  totalParticipants: /*u64*/ bigint | undefined;
  relays: Array<string>;
  host: LiveEventHost | undefined;
  speakers: Array<Person>;
  participants: Array<Person>;
};

/**
 * Generated factory for {@link LiveEvent} record objects.
 */
export const LiveEvent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LiveEvent, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LiveEvent}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LiveEvent}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LiveEvent>,
  });
})();

const FfiConverterTypeLiveEvent = (() => {
  type TypeName = LiveEvent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        title: FfiConverterOptionalString.read(from),
        summary: FfiConverterOptionalString.read(from),
        image: FfiConverterOptionalTypeImage.read(from),
        hashtags: FfiConverterArrayString.read(from),
        streaming: FfiConverterOptionalString.read(from),
        recording: FfiConverterOptionalString.read(from),
        start: FfiConverterOptionalTypeTimestamp.read(from),
        ends: FfiConverterOptionalTypeTimestamp.read(from),
        status: FfiConverterOptionalTypeLiveEventStatus.read(from),
        currentParticipants: FfiConverterOptionalUInt64.read(from),
        totalParticipants: FfiConverterOptionalUInt64.read(from),
        relays: FfiConverterArrayString.read(from),
        host: FfiConverterOptionalTypeLiveEventHost.read(from),
        speakers: FfiConverterArrayTypePerson.read(from),
        participants: FfiConverterArrayTypePerson.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterOptionalString.write(value.title, into);
      FfiConverterOptionalString.write(value.summary, into);
      FfiConverterOptionalTypeImage.write(value.image, into);
      FfiConverterArrayString.write(value.hashtags, into);
      FfiConverterOptionalString.write(value.streaming, into);
      FfiConverterOptionalString.write(value.recording, into);
      FfiConverterOptionalTypeTimestamp.write(value.start, into);
      FfiConverterOptionalTypeTimestamp.write(value.ends, into);
      FfiConverterOptionalTypeLiveEventStatus.write(value.status, into);
      FfiConverterOptionalUInt64.write(value.currentParticipants, into);
      FfiConverterOptionalUInt64.write(value.totalParticipants, into);
      FfiConverterArrayString.write(value.relays, into);
      FfiConverterOptionalTypeLiveEventHost.write(value.host, into);
      FfiConverterArrayTypePerson.write(value.speakers, into);
      FfiConverterArrayTypePerson.write(value.participants, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterOptionalString.allocationSize(value.title) +
        FfiConverterOptionalString.allocationSize(value.summary) +
        FfiConverterOptionalTypeImage.allocationSize(value.image) +
        FfiConverterArrayString.allocationSize(value.hashtags) +
        FfiConverterOptionalString.allocationSize(value.streaming) +
        FfiConverterOptionalString.allocationSize(value.recording) +
        FfiConverterOptionalTypeTimestamp.allocationSize(value.start) +
        FfiConverterOptionalTypeTimestamp.allocationSize(value.ends) +
        FfiConverterOptionalTypeLiveEventStatus.allocationSize(value.status) +
        FfiConverterOptionalUInt64.allocationSize(value.currentParticipants) +
        FfiConverterOptionalUInt64.allocationSize(value.totalParticipants) +
        FfiConverterArrayString.allocationSize(value.relays) +
        FfiConverterOptionalTypeLiveEventHost.allocationSize(value.host) +
        FfiConverterArrayTypePerson.allocationSize(value.speakers) +
        FfiConverterArrayTypePerson.allocationSize(value.participants)
      );
    }
  }
  return new FFIConverter();
})();

export type LiveEventHost = {
  publicKey: PublicKeyInterface;
  relayUrl: string | undefined;
  proof: string | undefined;
};

/**
 * Generated factory for {@link LiveEventHost} record objects.
 */
export const LiveEventHost = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LiveEventHost, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LiveEventHost}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LiveEventHost}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LiveEventHost>,
  });
})();

const FfiConverterTypeLiveEventHost = (() => {
  type TypeName = LiveEventHost;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        publicKey: FfiConverterTypePublicKey.read(from),
        relayUrl: FfiConverterOptionalString.read(from),
        proof: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePublicKey.write(value.publicKey, into);
      FfiConverterOptionalString.write(value.relayUrl, into);
      FfiConverterOptionalString.write(value.proof, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypePublicKey.allocationSize(value.publicKey) +
        FfiConverterOptionalString.allocationSize(value.relayUrl) +
        FfiConverterOptionalString.allocationSize(value.proof)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Lookup Invoice Request
 */
export type LookupInvoiceRequest = {
  /**
   * Payment hash of invoice
   */
  paymentHash: string | undefined;
  /**
   * Bolt11 invoice
   */
  invoice: string | undefined;
};

/**
 * Generated factory for {@link LookupInvoiceRequest} record objects.
 */
export const LookupInvoiceRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      LookupInvoiceRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LookupInvoiceRequest}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LookupInvoiceRequest}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LookupInvoiceRequest>,
  });
})();

const FfiConverterTypeLookupInvoiceRequest = (() => {
  type TypeName = LookupInvoiceRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        paymentHash: FfiConverterOptionalString.read(from),
        invoice: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.paymentHash, into);
      FfiConverterOptionalString.write(value.invoice, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.paymentHash) +
        FfiConverterOptionalString.allocationSize(value.invoice)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * NIP47 Response Result
 */
export type LookupInvoiceResponse = {
  /**
   * Transaction type
   */
  transactionType: TransactionType | undefined;
  /**
   * Bolt11 invoice
   */
  invoice: string | undefined;
  /**
   * Invoice's description
   */
  description: string | undefined;
  /**
   * Invoice's description hash
   */
  descriptionHash: string | undefined;
  /**
   * Payment preimage
   */
  preimage: string | undefined;
  /**
   * Payment hash
   */
  paymentHash: string;
  /**
   * Amount in millisatoshis
   */
  amount: /*u64*/ bigint;
  /**
   * Fees paid in millisatoshis
   */
  feesPaid: /*u64*/ bigint;
  /**
   * Creation timestamp in seconds since epoch
   */
  createdAt: TimestampInterface;
  /**
   * Expiration timestamp in seconds since epoch
   */
  expiresAt: TimestampInterface | undefined;
  /**
   * Settled timestamp in seconds since epoch
   */
  settledAt: TimestampInterface | undefined;
  /**
   * Optional metadata about the payment
   */
  metadata: JsonValue | undefined;
};

/**
 * Generated factory for {@link LookupInvoiceResponse} record objects.
 */
export const LookupInvoiceResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      LookupInvoiceResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LookupInvoiceResponse}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LookupInvoiceResponse}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LookupInvoiceResponse>,
  });
})();

const FfiConverterTypeLookupInvoiceResponse = (() => {
  type TypeName = LookupInvoiceResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        transactionType: FfiConverterOptionalTypeTransactionType.read(from),
        invoice: FfiConverterOptionalString.read(from),
        description: FfiConverterOptionalString.read(from),
        descriptionHash: FfiConverterOptionalString.read(from),
        preimage: FfiConverterOptionalString.read(from),
        paymentHash: FfiConverterString.read(from),
        amount: FfiConverterUInt64.read(from),
        feesPaid: FfiConverterUInt64.read(from),
        createdAt: FfiConverterTypeTimestamp.read(from),
        expiresAt: FfiConverterOptionalTypeTimestamp.read(from),
        settledAt: FfiConverterOptionalTypeTimestamp.read(from),
        metadata: FfiConverterOptionalTypeJsonValue.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalTypeTransactionType.write(
        value.transactionType,
        into
      );
      FfiConverterOptionalString.write(value.invoice, into);
      FfiConverterOptionalString.write(value.description, into);
      FfiConverterOptionalString.write(value.descriptionHash, into);
      FfiConverterOptionalString.write(value.preimage, into);
      FfiConverterString.write(value.paymentHash, into);
      FfiConverterUInt64.write(value.amount, into);
      FfiConverterUInt64.write(value.feesPaid, into);
      FfiConverterTypeTimestamp.write(value.createdAt, into);
      FfiConverterOptionalTypeTimestamp.write(value.expiresAt, into);
      FfiConverterOptionalTypeTimestamp.write(value.settledAt, into);
      FfiConverterOptionalTypeJsonValue.write(value.metadata, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalTypeTransactionType.allocationSize(
          value.transactionType
        ) +
        FfiConverterOptionalString.allocationSize(value.invoice) +
        FfiConverterOptionalString.allocationSize(value.description) +
        FfiConverterOptionalString.allocationSize(value.descriptionHash) +
        FfiConverterOptionalString.allocationSize(value.preimage) +
        FfiConverterString.allocationSize(value.paymentHash) +
        FfiConverterUInt64.allocationSize(value.amount) +
        FfiConverterUInt64.allocationSize(value.feesPaid) +
        FfiConverterTypeTimestamp.allocationSize(value.createdAt) +
        FfiConverterOptionalTypeTimestamp.allocationSize(value.expiresAt) +
        FfiConverterOptionalTypeTimestamp.allocationSize(value.settledAt) +
        FfiConverterOptionalTypeJsonValue.allocationSize(value.metadata)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Make Invoice Request
 */
export type MakeInvoiceRequest = {
  /**
   * Amount in millisatoshis
   */
  amount: /*u64*/ bigint;
  /**
   * Invoice description
   */
  description: string | undefined;
  /**
   * Invoice description hash
   */
  descriptionHash: string | undefined;
  /**
   * Invoice expiry in seconds
   */
  expiry: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link MakeInvoiceRequest} record objects.
 */
export const MakeInvoiceRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<MakeInvoiceRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MakeInvoiceRequest}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MakeInvoiceRequest}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<MakeInvoiceRequest>,
  });
})();

const FfiConverterTypeMakeInvoiceRequest = (() => {
  type TypeName = MakeInvoiceRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        amount: FfiConverterUInt64.read(from),
        description: FfiConverterOptionalString.read(from),
        descriptionHash: FfiConverterOptionalString.read(from),
        expiry: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.amount, into);
      FfiConverterOptionalString.write(value.description, into);
      FfiConverterOptionalString.write(value.descriptionHash, into);
      FfiConverterOptionalUInt64.write(value.expiry, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.amount) +
        FfiConverterOptionalString.allocationSize(value.description) +
        FfiConverterOptionalString.allocationSize(value.descriptionHash) +
        FfiConverterOptionalUInt64.allocationSize(value.expiry)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * NIP47 Response Result
 */
export type MakeInvoiceResponse = {
  /**
   * Bolt 11 invoice
   */
  invoice: string;
  /**
   * Invoice's payment hash
   */
  paymentHash: string;
};

/**
 * Generated factory for {@link MakeInvoiceResponse} record objects.
 */
export const MakeInvoiceResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<MakeInvoiceResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MakeInvoiceResponse}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MakeInvoiceResponse}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<MakeInvoiceResponse>,
  });
})();

const FfiConverterTypeMakeInvoiceResponse = (() => {
  type TypeName = MakeInvoiceResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        invoice: FfiConverterString.read(from),
        paymentHash: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.invoice, into);
      FfiConverterString.write(value.paymentHash, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.invoice) +
        FfiConverterString.allocationSize(value.paymentHash)
      );
    }
  }
  return new FFIConverter();
})();

export type MetadataRecord = {
  /**
   * Name
   */
  name: string | undefined;
  /**
   * Display name
   */
  displayName: string | undefined;
  /**
   * Description
   */
  about: string | undefined;
  /**
   * Website url
   */
  website: string | undefined;
  /**
   * Picture url
   */
  picture: string | undefined;
  /**
   * Banner url
   */
  banner: string | undefined;
  /**
   * NIP05 (ex. name@example.com)
   */
  nip05: string | undefined;
  /**
   * LNURL
   */
  lud06: string | undefined;
  /**
   * Lightning Address
   */
  lud16: string | undefined;
};

/**
 * Generated factory for {@link MetadataRecord} record objects.
 */
export const MetadataRecord = (() => {
  const defaults = () => ({
    name: undefined,
    displayName: undefined,
    about: undefined,
    website: undefined,
    picture: undefined,
    banner: undefined,
    nip05: undefined,
    lud06: undefined,
    lud16: undefined,
  });
  const create = (() => {
    return uniffiCreateRecord<MetadataRecord, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MetadataRecord}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MetadataRecord}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<MetadataRecord>,
  });
})();

const FfiConverterTypeMetadataRecord = (() => {
  type TypeName = MetadataRecord;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        name: FfiConverterOptionalString.read(from),
        displayName: FfiConverterOptionalString.read(from),
        about: FfiConverterOptionalString.read(from),
        website: FfiConverterOptionalString.read(from),
        picture: FfiConverterOptionalString.read(from),
        banner: FfiConverterOptionalString.read(from),
        nip05: FfiConverterOptionalString.read(from),
        lud06: FfiConverterOptionalString.read(from),
        lud16: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterOptionalString.write(value.displayName, into);
      FfiConverterOptionalString.write(value.about, into);
      FfiConverterOptionalString.write(value.website, into);
      FfiConverterOptionalString.write(value.picture, into);
      FfiConverterOptionalString.write(value.banner, into);
      FfiConverterOptionalString.write(value.nip05, into);
      FfiConverterOptionalString.write(value.lud06, into);
      FfiConverterOptionalString.write(value.lud16, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterOptionalString.allocationSize(value.displayName) +
        FfiConverterOptionalString.allocationSize(value.about) +
        FfiConverterOptionalString.allocationSize(value.website) +
        FfiConverterOptionalString.allocationSize(value.picture) +
        FfiConverterOptionalString.allocationSize(value.banner) +
        FfiConverterOptionalString.allocationSize(value.nip05) +
        FfiConverterOptionalString.allocationSize(value.lud06) +
        FfiConverterOptionalString.allocationSize(value.lud16)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Multi Pay Invoice Request Params
 */
export type MultiPayInvoiceRequest = {
  /**
   * Invoices to pay
   */
  invoices: Array<PayInvoiceRequest>;
};

/**
 * Generated factory for {@link MultiPayInvoiceRequest} record objects.
 */
export const MultiPayInvoiceRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      MultiPayInvoiceRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MultiPayInvoiceRequest}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MultiPayInvoiceRequest}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<MultiPayInvoiceRequest>,
  });
})();

const FfiConverterTypeMultiPayInvoiceRequest = (() => {
  type TypeName = MultiPayInvoiceRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        invoices: FfiConverterArrayTypePayInvoiceRequest.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypePayInvoiceRequest.write(value.invoices, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayTypePayInvoiceRequest.allocationSize(
        value.invoices
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Multi Pay Keysend Request
 */
export type MultiPayKeysendRequest = {
  /**
   * Keysends
   */
  keysends: Array<PayKeysendRequest>;
};

/**
 * Generated factory for {@link MultiPayKeysendRequest} record objects.
 */
export const MultiPayKeysendRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      MultiPayKeysendRequest,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MultiPayKeysendRequest}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MultiPayKeysendRequest}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<MultiPayKeysendRequest>,
  });
})();

const FfiConverterTypeMultiPayKeysendRequest = (() => {
  type TypeName = MultiPayKeysendRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        keysends: FfiConverterArrayTypePayKeysendRequest.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypePayKeysendRequest.write(value.keysends, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayTypePayKeysendRequest.allocationSize(
        value.keysends
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Things the user doesn't want to see in their feeds
 *
 * <https://github.com/nostr-protocol/nips/blob/master/51.md>
 */
export type MuteList = {
  publicKeys: Array<PublicKeyInterface>;
  hashtags: Array<string>;
  eventIds: Array<EventIdInterface>;
  words: Array<string>;
};

/**
 * Generated factory for {@link MuteList} record objects.
 */
export const MuteList = (() => {
  const defaults = () => ({
    publicKeys: [],
    hashtags: [],
    eventIds: [],
    words: [],
  });
  const create = (() => {
    return uniffiCreateRecord<MuteList, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MuteList}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MuteList}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<MuteList>,
  });
})();

const FfiConverterTypeMuteList = (() => {
  type TypeName = MuteList;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        publicKeys: FfiConverterArrayTypePublicKey.read(from),
        hashtags: FfiConverterArrayString.read(from),
        eventIds: FfiConverterArrayTypeEventId.read(from),
        words: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypePublicKey.write(value.publicKeys, into);
      FfiConverterArrayString.write(value.hashtags, into);
      FfiConverterArrayTypeEventId.write(value.eventIds, into);
      FfiConverterArrayString.write(value.words, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypePublicKey.allocationSize(value.publicKeys) +
        FfiConverterArrayString.allocationSize(value.hashtags) +
        FfiConverterArrayTypeEventId.allocationSize(value.eventIds) +
        FfiConverterArrayString.allocationSize(value.words)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * NIP47 Error message
 */
export type Nip47Error = {
  /**
   * Error Code
   */
  code: ErrorCode;
  /**
   * Human Readable error message
   */
  message: string;
};

/**
 * Generated factory for {@link Nip47Error} record objects.
 */
export const Nip47Error = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Nip47Error, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Nip47Error}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Nip47Error}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Nip47Error>,
  });
})();

const FfiConverterTypeNIP47Error = (() => {
  type TypeName = Nip47Error;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        code: FfiConverterTypeErrorCode.read(from),
        message: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeErrorCode.write(value.code, into);
      FfiConverterString.write(value.message, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeErrorCode.allocationSize(value.code) +
        FfiConverterString.allocationSize(value.message)
      );
    }
  }
  return new FFIConverter();
})();

export type NegentropyItem = {
  id: EventIdInterface;
  timestamp: TimestampInterface;
};

/**
 * Generated factory for {@link NegentropyItem} record objects.
 */
export const NegentropyItem = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<NegentropyItem, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link NegentropyItem}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link NegentropyItem}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<NegentropyItem>,
  });
})();

const FfiConverterTypeNegentropyItem = (() => {
  type TypeName = NegentropyItem;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterTypeEventId.read(from),
        timestamp: FfiConverterTypeTimestamp.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeEventId.write(value.id, into);
      FfiConverterTypeTimestamp.write(value.timestamp, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeEventId.allocationSize(value.id) +
        FfiConverterTypeTimestamp.allocationSize(value.timestamp)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Output
 *
 * Send or negentropy reconciliation output
 */
export type Output = {
  /**
   * Set of relays that success
   */
  success: Array<string>;
  /**
   * Map of relays that failed, with related errors.
   */
  failed: Map<string, string>;
};

/**
 * Generated factory for {@link Output} record objects.
 */
export const Output = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Output, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Output}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Output}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Output>,
  });
})();

const FfiConverterTypeOutput = (() => {
  type TypeName = Output;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        success: FfiConverterArrayString.read(from),
        failed: FfiConverterMapStringString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayString.write(value.success, into);
      FfiConverterMapStringString.write(value.failed, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayString.allocationSize(value.success) +
        FfiConverterMapStringString.allocationSize(value.failed)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Pay Invoice Request
 */
export type PayInvoiceRequest = {
  /**
   * Optional id
   */
  id: string | undefined;
  /**
   * Request invoice
   */
  invoice: string;
  /**
   * Optional amount in millisatoshis
   */
  amount: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link PayInvoiceRequest} record objects.
 */
export const PayInvoiceRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PayInvoiceRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PayInvoiceRequest}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PayInvoiceRequest}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PayInvoiceRequest>,
  });
})();

const FfiConverterTypePayInvoiceRequest = (() => {
  type TypeName = PayInvoiceRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterOptionalString.read(from),
        invoice: FfiConverterString.read(from),
        amount: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.id, into);
      FfiConverterString.write(value.invoice, into);
      FfiConverterOptionalUInt64.write(value.amount, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.invoice) +
        FfiConverterOptionalUInt64.allocationSize(value.amount)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * NIP47 Response Result
 */
export type PayInvoiceResponse = {
  /**
   * Response preimage
   */
  preimage: string;
};

/**
 * Generated factory for {@link PayInvoiceResponse} record objects.
 */
export const PayInvoiceResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PayInvoiceResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PayInvoiceResponse}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PayInvoiceResponse}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PayInvoiceResponse>,
  });
})();

const FfiConverterTypePayInvoiceResponse = (() => {
  type TypeName = PayInvoiceResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        preimage: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.preimage, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.preimage);
    }
  }
  return new FFIConverter();
})();

/**
 * Pay Invoice Request
 */
export type PayKeysendRequest = {
  /**
   * Optional id
   */
  id: string | undefined;
  /**
   * Amount in millisatoshis
   */
  amount: /*u64*/ bigint;
  /**
   * Receiver's node id
   */
  pubkey: string;
  /**
   * Optional preimage
   */
  preimage: string | undefined;
  /**
   * Optional TLVs to be added to the keysend payment
   */
  tlvRecords: Array<KeysendTlvRecord>;
};

/**
 * Generated factory for {@link PayKeysendRequest} record objects.
 */
export const PayKeysendRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PayKeysendRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PayKeysendRequest}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PayKeysendRequest}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PayKeysendRequest>,
  });
})();

const FfiConverterTypePayKeysendRequest = (() => {
  type TypeName = PayKeysendRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterOptionalString.read(from),
        amount: FfiConverterUInt64.read(from),
        pubkey: FfiConverterString.read(from),
        preimage: FfiConverterOptionalString.read(from),
        tlvRecords: FfiConverterArrayTypeKeysendTLVRecord.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.id, into);
      FfiConverterUInt64.write(value.amount, into);
      FfiConverterString.write(value.pubkey, into);
      FfiConverterOptionalString.write(value.preimage, into);
      FfiConverterArrayTypeKeysendTLVRecord.write(value.tlvRecords, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.id) +
        FfiConverterUInt64.allocationSize(value.amount) +
        FfiConverterString.allocationSize(value.pubkey) +
        FfiConverterOptionalString.allocationSize(value.preimage) +
        FfiConverterArrayTypeKeysendTLVRecord.allocationSize(value.tlvRecords)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * NIP47 Response Result
 */
export type PayKeysendResponse = {
  /**
   * Response preimage
   */
  preimage: string;
};

/**
 * Generated factory for {@link PayKeysendResponse} record objects.
 */
export const PayKeysendResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PayKeysendResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PayKeysendResponse}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PayKeysendResponse}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PayKeysendResponse>,
  });
})();

const FfiConverterTypePayKeysendResponse = (() => {
  type TypeName = PayKeysendResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        preimage: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.preimage, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.preimage);
    }
  }
  return new FFIConverter();
})();

export type Person = {
  publicKey: PublicKeyInterface;
  url: string | undefined;
};

/**
 * Generated factory for {@link Person} record objects.
 */
export const Person = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Person, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Person}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Person}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Person>,
  });
})();

const FfiConverterTypePerson = (() => {
  type TypeName = Person;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        publicKey: FfiConverterTypePublicKey.read(from),
        url: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePublicKey.write(value.publicKey, into);
      FfiConverterOptionalString.write(value.url, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypePublicKey.allocationSize(value.publicKey) +
        FfiConverterOptionalString.allocationSize(value.url)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Payload for creating or updating product
 */
export type ProductData = {
  /**
   * UUID of the product generated by merchant
   */
  id: string;
  /**
   * Id of the stall that this product belongs to
   */
  stallId: string;
  /**
   * Product name
   */
  name: string;
  /**
   * Description of the product
   */
  description: string | undefined;
  /**
   * Image urls of the product
   */
  images: Array<string> | undefined;
  /**
   * Currency used
   */
  currency: string;
  /**
   * Price of the product
   */
  price: /*f64*/ number;
  /**
   * Available items
   */
  quantity: /*u64*/ bigint;
  /**
   * Specifications of the product
   */
  specs: Array<Array<string>> | undefined;
  /**
   * Shipping method costs
   */
  shipping: Array<ShippingCost>;
  /**
   * Categories of the product (will be added to tags)
   */
  categories: Array<string> | undefined;
};

/**
 * Generated factory for {@link ProductData} record objects.
 */
export const ProductData = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ProductData, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ProductData}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ProductData}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ProductData>,
  });
})();

const FfiConverterTypeProductData = (() => {
  type TypeName = ProductData;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        stallId: FfiConverterString.read(from),
        name: FfiConverterString.read(from),
        description: FfiConverterOptionalString.read(from),
        images: FfiConverterOptionalArrayString.read(from),
        currency: FfiConverterString.read(from),
        price: FfiConverterFloat64.read(from),
        quantity: FfiConverterUInt64.read(from),
        specs: FfiConverterOptionalArrayArrayString.read(from),
        shipping: FfiConverterArrayTypeShippingCost.read(from),
        categories: FfiConverterOptionalArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterString.write(value.stallId, into);
      FfiConverterString.write(value.name, into);
      FfiConverterOptionalString.write(value.description, into);
      FfiConverterOptionalArrayString.write(value.images, into);
      FfiConverterString.write(value.currency, into);
      FfiConverterFloat64.write(value.price, into);
      FfiConverterUInt64.write(value.quantity, into);
      FfiConverterOptionalArrayArrayString.write(value.specs, into);
      FfiConverterArrayTypeShippingCost.write(value.shipping, into);
      FfiConverterOptionalArrayString.write(value.categories, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.stallId) +
        FfiConverterString.allocationSize(value.name) +
        FfiConverterOptionalString.allocationSize(value.description) +
        FfiConverterOptionalArrayString.allocationSize(value.images) +
        FfiConverterString.allocationSize(value.currency) +
        FfiConverterFloat64.allocationSize(value.price) +
        FfiConverterUInt64.allocationSize(value.quantity) +
        FfiConverterOptionalArrayArrayString.allocationSize(value.specs) +
        FfiConverterArrayTypeShippingCost.allocationSize(value.shipping) +
        FfiConverterOptionalArrayString.allocationSize(value.categories)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Reconciliation output
 */
export type Reconciliation = {
  /**
   * The IDs that were stored locally
   */
  local: Array<EventIdInterface>;
  /**
   * The IDs that were missing locally (stored on relay)
   */
  remote: Array<EventIdInterface>;
  /**
   * Events that are **successfully** sent to relays during reconciliation
   */
  sent: Array<EventIdInterface>;
  /**
   * Event that are **successfully** received from relay
   */
  received: Array<EventIdInterface>;
  sendFailures: Map<string, Array<ReconciliationSendFailureItem>>;
};

/**
 * Generated factory for {@link Reconciliation} record objects.
 */
export const Reconciliation = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Reconciliation, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Reconciliation}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Reconciliation}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Reconciliation>,
  });
})();

const FfiConverterTypeReconciliation = (() => {
  type TypeName = Reconciliation;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        local: FfiConverterArrayTypeEventId.read(from),
        remote: FfiConverterArrayTypeEventId.read(from),
        sent: FfiConverterArrayTypeEventId.read(from),
        received: FfiConverterArrayTypeEventId.read(from),
        sendFailures:
          FfiConverterMapStringArrayTypeReconciliationSendFailureItem.read(
            from
          ),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeEventId.write(value.local, into);
      FfiConverterArrayTypeEventId.write(value.remote, into);
      FfiConverterArrayTypeEventId.write(value.sent, into);
      FfiConverterArrayTypeEventId.write(value.received, into);
      FfiConverterMapStringArrayTypeReconciliationSendFailureItem.write(
        value.sendFailures,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeEventId.allocationSize(value.local) +
        FfiConverterArrayTypeEventId.allocationSize(value.remote) +
        FfiConverterArrayTypeEventId.allocationSize(value.sent) +
        FfiConverterArrayTypeEventId.allocationSize(value.received) +
        FfiConverterMapStringArrayTypeReconciliationSendFailureItem.allocationSize(
          value.sendFailures
        )
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Reconciliation output
 */
export type ReconciliationOutput = {
  /**
   * Reconciliation report
   */
  report: Reconciliation;
  /**
   * Set of relays that success
   */
  success: Array<string>;
  /**
   * Map of relays that failed, with related errors.
   */
  failed: Map<string, string>;
};

/**
 * Generated factory for {@link ReconciliationOutput} record objects.
 */
export const ReconciliationOutput = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ReconciliationOutput,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ReconciliationOutput}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ReconciliationOutput}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ReconciliationOutput>,
  });
})();

const FfiConverterTypeReconciliationOutput = (() => {
  type TypeName = ReconciliationOutput;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        report: FfiConverterTypeReconciliation.read(from),
        success: FfiConverterArrayString.read(from),
        failed: FfiConverterMapStringString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeReconciliation.write(value.report, into);
      FfiConverterArrayString.write(value.success, into);
      FfiConverterMapStringString.write(value.failed, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeReconciliation.allocationSize(value.report) +
        FfiConverterArrayString.allocationSize(value.success) +
        FfiConverterMapStringString.allocationSize(value.failed)
      );
    }
  }
  return new FFIConverter();
})();

export type ReconciliationSendFailureItem = {
  id: EventIdInterface;
  error: string;
};

/**
 * Generated factory for {@link ReconciliationSendFailureItem} record objects.
 */
export const ReconciliationSendFailureItem = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ReconciliationSendFailureItem,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ReconciliationSendFailureItem}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ReconciliationSendFailureItem}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<ReconciliationSendFailureItem>,
  });
})();

const FfiConverterTypeReconciliationSendFailureItem = (() => {
  type TypeName = ReconciliationSendFailureItem;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterTypeEventId.read(from),
        error: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeEventId.write(value.id, into);
      FfiConverterString.write(value.error, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeEventId.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.error)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A retention schedule for the relay
 */
export type Retention = {
  /**
   * The event kinds this retention pertains to
   */
  kinds: Array<RetentionKind> | undefined;
  /**
   * The amount of time these events are kept
   */
  time: /*u64*/ bigint | undefined;
  /**
   * The max number of events kept before removing older events
   */
  count: /*u64*/ bigint | undefined;
};

/**
 * Generated factory for {@link Retention} record objects.
 */
export const Retention = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Retention, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Retention}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Retention}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Retention>,
  });
})();

const FfiConverterTypeRetention = (() => {
  type TypeName = Retention;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        kinds: FfiConverterOptionalArrayTypeRetentionKind.read(from),
        time: FfiConverterOptionalUInt64.read(from),
        count: FfiConverterOptionalUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalArrayTypeRetentionKind.write(value.kinds, into);
      FfiConverterOptionalUInt64.write(value.time, into);
      FfiConverterOptionalUInt64.write(value.count, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalArrayTypeRetentionKind.allocationSize(value.kinds) +
        FfiConverterOptionalUInt64.allocationSize(value.time) +
        FfiConverterOptionalUInt64.allocationSize(value.count)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Send event output
 */
export type SendEventOutput = {
  /**
   * Event ID
   */
  id: EventIdInterface;
  /**
   * Set of relays that success
   */
  success: Array<string>;
  /**
   * Map of relays that failed, with related errors.
   */
  failed: Map<string, string>;
};

/**
 * Generated factory for {@link SendEventOutput} record objects.
 */
export const SendEventOutput = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SendEventOutput, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SendEventOutput}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SendEventOutput}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SendEventOutput>,
  });
})();

const FfiConverterTypeSendEventOutput = (() => {
  type TypeName = SendEventOutput;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterTypeEventId.read(from),
        success: FfiConverterArrayString.read(from),
        failed: FfiConverterMapStringString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeEventId.write(value.id, into);
      FfiConverterArrayString.write(value.success, into);
      FfiConverterMapStringString.write(value.failed, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeEventId.allocationSize(value.id) +
        FfiConverterArrayString.allocationSize(value.success) +
        FfiConverterMapStringString.allocationSize(value.failed)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Delivery cost for shipping method as defined by the merchant in the product
 */
export type ShippingCost = {
  /**
   * Id of the shipping method
   */
  id: string;
  /**
   * Cost to use this shipping method
   */
  cost: /*f64*/ number;
};

/**
 * Generated factory for {@link ShippingCost} record objects.
 */
export const ShippingCost = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ShippingCost, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ShippingCost}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ShippingCost}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ShippingCost>,
  });
})();

const FfiConverterTypeShippingCost = (() => {
  type TypeName = ShippingCost;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        cost: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterFloat64.write(value.cost, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterFloat64.allocationSize(value.cost)
      );
    }
  }
  return new FFIConverter();
})();

export type ShippingMethodRecord = {
  /**
   * Shipping method unique id by merchant
   */
  id: string;
  /**
   * Shipping method name
   */
  name: string | undefined;
  /**
   * Shipping method cost (currency is the same as the stall)
   */
  cost: /*f64*/ number;
  /**
   * Covered regions
   */
  regions: Array<string>;
};

/**
 * Generated factory for {@link ShippingMethodRecord} record objects.
 */
export const ShippingMethodRecord = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ShippingMethodRecord,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ShippingMethodRecord}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ShippingMethodRecord}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ShippingMethodRecord>,
  });
})();

const FfiConverterTypeShippingMethodRecord = (() => {
  type TypeName = ShippingMethodRecord;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        name: FfiConverterOptionalString.read(from),
        cost: FfiConverterFloat64.read(from),
        regions: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterFloat64.write(value.cost, into);
      FfiConverterArrayString.write(value.regions, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterFloat64.allocationSize(value.cost) +
        FfiConverterArrayString.allocationSize(value.regions)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Payload for creating or updating stall
 */
export type StallDataRecord = {
  /**
   * UUID of the stall generated by merchant
   */
  id: string;
  /**
   * Stall name
   */
  name: string;
  /**
   * Stall description
   */
  description: string | undefined;
  /**
   * Currency used
   */
  currency: string;
  /**
   * Available shipping methods
   */
  shipping: Array<ShippingMethodRecord>;
};

/**
 * Generated factory for {@link StallDataRecord} record objects.
 */
export const StallDataRecord = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<StallDataRecord, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link StallDataRecord}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link StallDataRecord}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<StallDataRecord>,
  });
})();

const FfiConverterTypeStallDataRecord = (() => {
  type TypeName = StallDataRecord;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        name: FfiConverterString.read(from),
        description: FfiConverterOptionalString.read(from),
        currency: FfiConverterString.read(from),
        shipping: FfiConverterArrayTypeShippingMethodRecord.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterString.write(value.name, into);
      FfiConverterOptionalString.write(value.description, into);
      FfiConverterString.write(value.currency, into);
      FfiConverterArrayTypeShippingMethodRecord.write(value.shipping, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterString.allocationSize(value.name) +
        FfiConverterOptionalString.allocationSize(value.description) +
        FfiConverterString.allocationSize(value.currency) +
        FfiConverterArrayTypeShippingMethodRecord.allocationSize(value.shipping)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Subscribe output
 */
export type SubscribeOutput = {
  /**
   * Subscription ID
   */
  id: string;
  /**
   * Set of relays that success
   */
  success: Array<string>;
  /**
   * Map of relays that failed, with related errors.
   */
  failed: Map<string, string>;
};

/**
 * Generated factory for {@link SubscribeOutput} record objects.
 */
export const SubscribeOutput = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SubscribeOutput, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SubscribeOutput}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SubscribeOutput}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SubscribeOutput>,
  });
})();

const FfiConverterTypeSubscribeOutput = (() => {
  type TypeName = SubscribeOutput;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        success: FfiConverterArrayString.read(from),
        failed: FfiConverterMapStringString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterArrayString.write(value.success, into);
      FfiConverterMapStringString.write(value.failed, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterArrayString.allocationSize(value.success) +
        FfiConverterMapStringString.allocationSize(value.failed)
      );
    }
  }
  return new FFIConverter();
})();

export type TagClientAddress = {
  /**
   * Coordinate
   */
  coordinate: CoordinateInterface;
  /**
   * Relay hint
   */
  hint: string | undefined;
};

/**
 * Generated factory for {@link TagClientAddress} record objects.
 */
export const TagClientAddress = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TagClientAddress, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TagClientAddress}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TagClientAddress}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TagClientAddress>,
  });
})();

const FfiConverterTypeTagClientAddress = (() => {
  type TypeName = TagClientAddress;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        coordinate: FfiConverterTypeCoordinate.read(from),
        hint: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeCoordinate.write(value.coordinate, into);
      FfiConverterOptionalString.write(value.hint, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeCoordinate.allocationSize(value.coordinate) +
        FfiConverterOptionalString.allocationSize(value.hint)
      );
    }
  }
  return new FFIConverter();
})();

export type WebSocketCloseFrame = {
  code: /*u16*/ number;
  reason: string;
};

/**
 * Generated factory for {@link WebSocketCloseFrame} record objects.
 */
export const WebSocketCloseFrame = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<WebSocketCloseFrame, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link WebSocketCloseFrame}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link WebSocketCloseFrame}, with defaults specified
     * in Rust, in the {@link nostr_sdk} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link nostr_sdk} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<WebSocketCloseFrame>,
  });
})();

const FfiConverterTypeWebSocketCloseFrame = (() => {
  type TypeName = WebSocketCloseFrame;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        code: FfiConverterUInt16.read(from),
        reason: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt16.write(value.code, into);
      FfiConverterString.write(value.reason, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt16.allocationSize(value.code) +
        FfiConverterString.allocationSize(value.reason)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

export enum AdmitStatus {
  Success,
  Rejected,
}

const FfiConverterTypeAdmitStatus = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = AdmitStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return AdmitStatus.Success;
        case 2:
          return AdmitStatus.Rejected;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case AdmitStatus.Success:
          return ordinalConverter.write(1, into);
        case AdmitStatus.Rejected:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum Alphabet {
  A,
  B,
  C,
  D,
  E,
  F,
  G,
  H,
  I,
  J,
  K,
  L,
  M,
  N,
  O,
  P,
  Q,
  R,
  S,
  T,
  U,
  V,
  W,
  X,
  Y,
  Z,
}

const FfiConverterTypeAlphabet = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Alphabet;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return Alphabet.A;
        case 2:
          return Alphabet.B;
        case 3:
          return Alphabet.C;
        case 4:
          return Alphabet.D;
        case 5:
          return Alphabet.E;
        case 6:
          return Alphabet.F;
        case 7:
          return Alphabet.G;
        case 8:
          return Alphabet.H;
        case 9:
          return Alphabet.I;
        case 10:
          return Alphabet.J;
        case 11:
          return Alphabet.K;
        case 12:
          return Alphabet.L;
        case 13:
          return Alphabet.M;
        case 14:
          return Alphabet.N;
        case 15:
          return Alphabet.O;
        case 16:
          return Alphabet.P;
        case 17:
          return Alphabet.Q;
        case 18:
          return Alphabet.R;
        case 19:
          return Alphabet.S;
        case 20:
          return Alphabet.T;
        case 21:
          return Alphabet.U;
        case 22:
          return Alphabet.V;
        case 23:
          return Alphabet.W;
        case 24:
          return Alphabet.X;
        case 25:
          return Alphabet.Y;
        case 26:
          return Alphabet.Z;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case Alphabet.A:
          return ordinalConverter.write(1, into);
        case Alphabet.B:
          return ordinalConverter.write(2, into);
        case Alphabet.C:
          return ordinalConverter.write(3, into);
        case Alphabet.D:
          return ordinalConverter.write(4, into);
        case Alphabet.E:
          return ordinalConverter.write(5, into);
        case Alphabet.F:
          return ordinalConverter.write(6, into);
        case Alphabet.G:
          return ordinalConverter.write(7, into);
        case Alphabet.H:
          return ordinalConverter.write(8, into);
        case Alphabet.I:
          return ordinalConverter.write(9, into);
        case Alphabet.J:
          return ordinalConverter.write(10, into);
        case Alphabet.K:
          return ordinalConverter.write(11, into);
        case Alphabet.L:
          return ordinalConverter.write(12, into);
        case Alphabet.M:
          return ordinalConverter.write(13, into);
        case Alphabet.N:
          return ordinalConverter.write(14, into);
        case Alphabet.O:
          return ordinalConverter.write(15, into);
        case Alphabet.P:
          return ordinalConverter.write(16, into);
        case Alphabet.Q:
          return ordinalConverter.write(17, into);
        case Alphabet.R:
          return ordinalConverter.write(18, into);
        case Alphabet.S:
          return ordinalConverter.write(19, into);
        case Alphabet.T:
          return ordinalConverter.write(20, into);
        case Alphabet.U:
          return ordinalConverter.write(21, into);
        case Alphabet.V:
          return ordinalConverter.write(22, into);
        case Alphabet.W:
          return ordinalConverter.write(23, into);
        case Alphabet.X:
          return ordinalConverter.write(24, into);
        case Alphabet.Y:
          return ordinalConverter.write(25, into);
        case Alphabet.Z:
          return ordinalConverter.write(26, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: ClientMessageEnum
export enum ClientMessageEnum_Tags {
  EventMsg = 'EventMsg',
  Req = 'Req',
  ReqMultiFilter = 'ReqMultiFilter',
  Count = 'Count',
  Close = 'Close',
  Auth = 'Auth',
  NegOpen = 'NegOpen',
  NegMsg = 'NegMsg',
  NegClose = 'NegClose',
}
/**
 * Messages sent by clients, received by relays
 */
export const ClientMessageEnum = (() => {
  type EventMsg__interface = {
    tag: ClientMessageEnum_Tags.EventMsg;
    inner: Readonly<{ event: EventInterface }>;
  };

  class EventMsg_ extends UniffiEnum implements EventMsg__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ClientMessageEnum';
    readonly tag = ClientMessageEnum_Tags.EventMsg;
    readonly inner: Readonly<{ event: EventInterface }>;
    constructor(inner: { event: EventInterface }) {
      super('ClientMessageEnum', 'EventMsg');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { event: EventInterface }): EventMsg_ {
      return new EventMsg_(inner);
    }

    static instanceOf(obj: any): obj is EventMsg_ {
      return obj.tag === ClientMessageEnum_Tags.EventMsg;
    }
  }

  type Req__interface = {
    tag: ClientMessageEnum_Tags.Req;
    inner: Readonly<{ subscriptionId: string; filter: FilterInterface }>;
  };

  class Req_ extends UniffiEnum implements Req__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ClientMessageEnum';
    readonly tag = ClientMessageEnum_Tags.Req;
    readonly inner: Readonly<{
      subscriptionId: string;
      filter: FilterInterface;
    }>;
    constructor(inner: { subscriptionId: string; filter: FilterInterface }) {
      super('ClientMessageEnum', 'Req');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      subscriptionId: string;
      filter: FilterInterface;
    }): Req_ {
      return new Req_(inner);
    }

    static instanceOf(obj: any): obj is Req_ {
      return obj.tag === ClientMessageEnum_Tags.Req;
    }
  }

  type ReqMultiFilter__interface = {
    tag: ClientMessageEnum_Tags.ReqMultiFilter;
    inner: Readonly<{
      subscriptionId: string;
      filters: Array<FilterInterface>;
    }>;
  };

  /**
   * Multi-filter REQ (deprecated)
   *
   * <https://github.com/nostr-protocol/nips/pull/1645>
   */
  class ReqMultiFilter_
    extends UniffiEnum
    implements ReqMultiFilter__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ClientMessageEnum';
    readonly tag = ClientMessageEnum_Tags.ReqMultiFilter;
    readonly inner: Readonly<{
      subscriptionId: string;
      filters: Array<FilterInterface>;
    }>;
    constructor(inner: {
      subscriptionId: string;
      filters: Array<FilterInterface>;
    }) {
      super('ClientMessageEnum', 'ReqMultiFilter');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      subscriptionId: string;
      filters: Array<FilterInterface>;
    }): ReqMultiFilter_ {
      return new ReqMultiFilter_(inner);
    }

    static instanceOf(obj: any): obj is ReqMultiFilter_ {
      return obj.tag === ClientMessageEnum_Tags.ReqMultiFilter;
    }
  }

  type Count__interface = {
    tag: ClientMessageEnum_Tags.Count;
    inner: Readonly<{ subscriptionId: string; filter: FilterInterface }>;
  };

  class Count_ extends UniffiEnum implements Count__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ClientMessageEnum';
    readonly tag = ClientMessageEnum_Tags.Count;
    readonly inner: Readonly<{
      subscriptionId: string;
      filter: FilterInterface;
    }>;
    constructor(inner: { subscriptionId: string; filter: FilterInterface }) {
      super('ClientMessageEnum', 'Count');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      subscriptionId: string;
      filter: FilterInterface;
    }): Count_ {
      return new Count_(inner);
    }

    static instanceOf(obj: any): obj is Count_ {
      return obj.tag === ClientMessageEnum_Tags.Count;
    }
  }

  type Close__interface = {
    tag: ClientMessageEnum_Tags.Close;
    inner: Readonly<{ subscriptionId: string }>;
  };

  class Close_ extends UniffiEnum implements Close__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ClientMessageEnum';
    readonly tag = ClientMessageEnum_Tags.Close;
    readonly inner: Readonly<{ subscriptionId: string }>;
    constructor(inner: { subscriptionId: string }) {
      super('ClientMessageEnum', 'Close');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { subscriptionId: string }): Close_ {
      return new Close_(inner);
    }

    static instanceOf(obj: any): obj is Close_ {
      return obj.tag === ClientMessageEnum_Tags.Close;
    }
  }

  type Auth__interface = {
    tag: ClientMessageEnum_Tags.Auth;
    inner: Readonly<{ event: EventInterface }>;
  };

  class Auth_ extends UniffiEnum implements Auth__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ClientMessageEnum';
    readonly tag = ClientMessageEnum_Tags.Auth;
    readonly inner: Readonly<{ event: EventInterface }>;
    constructor(inner: { event: EventInterface }) {
      super('ClientMessageEnum', 'Auth');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { event: EventInterface }): Auth_ {
      return new Auth_(inner);
    }

    static instanceOf(obj: any): obj is Auth_ {
      return obj.tag === ClientMessageEnum_Tags.Auth;
    }
  }

  type NegOpen__interface = {
    tag: ClientMessageEnum_Tags.NegOpen;
    inner: Readonly<{
      subscriptionId: string;
      filter: FilterInterface;
      idSize: /*u8*/ number | undefined;
      initialMessage: string;
    }>;
  };

  /**
   * Negentropy Open
   */
  class NegOpen_ extends UniffiEnum implements NegOpen__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ClientMessageEnum';
    readonly tag = ClientMessageEnum_Tags.NegOpen;
    readonly inner: Readonly<{
      subscriptionId: string;
      filter: FilterInterface;
      idSize: /*u8*/ number | undefined;
      initialMessage: string;
    }>;
    constructor(inner: {
      subscriptionId: string;
      filter: FilterInterface;
      /**
       * ID size (deprecated)
       */ idSize: /*u8*/ number | undefined;
      initialMessage: string;
    }) {
      super('ClientMessageEnum', 'NegOpen');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      subscriptionId: string;
      filter: FilterInterface;
      /**
       * ID size (deprecated)
       */ idSize: /*u8*/ number | undefined;
      initialMessage: string;
    }): NegOpen_ {
      return new NegOpen_(inner);
    }

    static instanceOf(obj: any): obj is NegOpen_ {
      return obj.tag === ClientMessageEnum_Tags.NegOpen;
    }
  }

  type NegMsg__interface = {
    tag: ClientMessageEnum_Tags.NegMsg;
    inner: Readonly<{ subscriptionId: string; message: string }>;
  };

  /**
   * Negentropy Message
   */
  class NegMsg_ extends UniffiEnum implements NegMsg__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ClientMessageEnum';
    readonly tag = ClientMessageEnum_Tags.NegMsg;
    readonly inner: Readonly<{ subscriptionId: string; message: string }>;
    constructor(inner: { subscriptionId: string; message: string }) {
      super('ClientMessageEnum', 'NegMsg');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { subscriptionId: string; message: string }): NegMsg_ {
      return new NegMsg_(inner);
    }

    static instanceOf(obj: any): obj is NegMsg_ {
      return obj.tag === ClientMessageEnum_Tags.NegMsg;
    }
  }

  type NegClose__interface = {
    tag: ClientMessageEnum_Tags.NegClose;
    inner: Readonly<{ subscriptionId: string }>;
  };

  /**
   * Negentropy Close
   */
  class NegClose_ extends UniffiEnum implements NegClose__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ClientMessageEnum';
    readonly tag = ClientMessageEnum_Tags.NegClose;
    readonly inner: Readonly<{ subscriptionId: string }>;
    constructor(inner: { subscriptionId: string }) {
      super('ClientMessageEnum', 'NegClose');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { subscriptionId: string }): NegClose_ {
      return new NegClose_(inner);
    }

    static instanceOf(obj: any): obj is NegClose_ {
      return obj.tag === ClientMessageEnum_Tags.NegClose;
    }
  }

  function instanceOf(obj: any): obj is ClientMessageEnum {
    return obj[uniffiTypeNameSymbol] === 'ClientMessageEnum';
  }

  return Object.freeze({
    instanceOf,
    EventMsg: EventMsg_,
    Req: Req_,
    ReqMultiFilter: ReqMultiFilter_,
    Count: Count_,
    Close: Close_,
    Auth: Auth_,
    NegOpen: NegOpen_,
    NegMsg: NegMsg_,
    NegClose: NegClose_,
  });
})();

/**
 * Messages sent by clients, received by relays
 */

export type ClientMessageEnum = InstanceType<
  (typeof ClientMessageEnum)[keyof Omit<typeof ClientMessageEnum, 'instanceOf'>]
>;

// FfiConverter for enum ClientMessageEnum
const FfiConverterTypeClientMessageEnum = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ClientMessageEnum;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ClientMessageEnum.EventMsg({
            event: FfiConverterTypeEvent.read(from),
          });
        case 2:
          return new ClientMessageEnum.Req({
            subscriptionId: FfiConverterString.read(from),
            filter: FfiConverterTypeFilter.read(from),
          });
        case 3:
          return new ClientMessageEnum.ReqMultiFilter({
            subscriptionId: FfiConverterString.read(from),
            filters: FfiConverterArrayTypeFilter.read(from),
          });
        case 4:
          return new ClientMessageEnum.Count({
            subscriptionId: FfiConverterString.read(from),
            filter: FfiConverterTypeFilter.read(from),
          });
        case 5:
          return new ClientMessageEnum.Close({
            subscriptionId: FfiConverterString.read(from),
          });
        case 6:
          return new ClientMessageEnum.Auth({
            event: FfiConverterTypeEvent.read(from),
          });
        case 7:
          return new ClientMessageEnum.NegOpen({
            subscriptionId: FfiConverterString.read(from),
            filter: FfiConverterTypeFilter.read(from),
            idSize: FfiConverterOptionalUInt8.read(from),
            initialMessage: FfiConverterString.read(from),
          });
        case 8:
          return new ClientMessageEnum.NegMsg({
            subscriptionId: FfiConverterString.read(from),
            message: FfiConverterString.read(from),
          });
        case 9:
          return new ClientMessageEnum.NegClose({
            subscriptionId: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ClientMessageEnum_Tags.EventMsg: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeEvent.write(inner.event, into);
          return;
        }
        case ClientMessageEnum_Tags.Req: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.subscriptionId, into);
          FfiConverterTypeFilter.write(inner.filter, into);
          return;
        }
        case ClientMessageEnum_Tags.ReqMultiFilter: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.subscriptionId, into);
          FfiConverterArrayTypeFilter.write(inner.filters, into);
          return;
        }
        case ClientMessageEnum_Tags.Count: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.subscriptionId, into);
          FfiConverterTypeFilter.write(inner.filter, into);
          return;
        }
        case ClientMessageEnum_Tags.Close: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.subscriptionId, into);
          return;
        }
        case ClientMessageEnum_Tags.Auth: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterTypeEvent.write(inner.event, into);
          return;
        }
        case ClientMessageEnum_Tags.NegOpen: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterString.write(inner.subscriptionId, into);
          FfiConverterTypeFilter.write(inner.filter, into);
          FfiConverterOptionalUInt8.write(inner.idSize, into);
          FfiConverterString.write(inner.initialMessage, into);
          return;
        }
        case ClientMessageEnum_Tags.NegMsg: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterString.write(inner.subscriptionId, into);
          FfiConverterString.write(inner.message, into);
          return;
        }
        case ClientMessageEnum_Tags.NegClose: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterString.write(inner.subscriptionId, into);
          return;
        }
        default:
          // Throwing from here means that ClientMessageEnum_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ClientMessageEnum_Tags.EventMsg: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeEvent.allocationSize(inner.event);
          return size;
        }
        case ClientMessageEnum_Tags.Req: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.subscriptionId);
          size += FfiConverterTypeFilter.allocationSize(inner.filter);
          return size;
        }
        case ClientMessageEnum_Tags.ReqMultiFilter: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.subscriptionId);
          size += FfiConverterArrayTypeFilter.allocationSize(inner.filters);
          return size;
        }
        case ClientMessageEnum_Tags.Count: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.subscriptionId);
          size += FfiConverterTypeFilter.allocationSize(inner.filter);
          return size;
        }
        case ClientMessageEnum_Tags.Close: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.subscriptionId);
          return size;
        }
        case ClientMessageEnum_Tags.Auth: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterTypeEvent.allocationSize(inner.event);
          return size;
        }
        case ClientMessageEnum_Tags.NegOpen: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterString.allocationSize(inner.subscriptionId);
          size += FfiConverterTypeFilter.allocationSize(inner.filter);
          size += FfiConverterOptionalUInt8.allocationSize(inner.idSize);
          size += FfiConverterString.allocationSize(inner.initialMessage);
          return size;
        }
        case ClientMessageEnum_Tags.NegMsg: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterString.allocationSize(inner.subscriptionId);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        case ClientMessageEnum_Tags.NegClose: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterString.allocationSize(inner.subscriptionId);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: ConnectionMode
export enum ConnectionMode_Tags {
  Direct = 'Direct',
  Proxy = 'Proxy',
}
export const ConnectionMode = (() => {
  type Direct__interface = {
    tag: ConnectionMode_Tags.Direct;
  };

  class Direct_ extends UniffiEnum implements Direct__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ConnectionMode';
    readonly tag = ConnectionMode_Tags.Direct;
    constructor() {
      super('ConnectionMode', 'Direct');
    }

    static new(): Direct_ {
      return new Direct_();
    }

    static instanceOf(obj: any): obj is Direct_ {
      return obj.tag === ConnectionMode_Tags.Direct;
    }
  }

  type Proxy__interface = {
    tag: ConnectionMode_Tags.Proxy;
    inner: Readonly<{ ip: string; port: /*u16*/ number }>;
  };

  class Proxy_ extends UniffiEnum implements Proxy__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ConnectionMode';
    readonly tag = ConnectionMode_Tags.Proxy;
    readonly inner: Readonly<{ ip: string; port: /*u16*/ number }>;
    constructor(inner: {
      /**
       * IP
       */ ip: string;
      /**
       * Port
       */ port: /*u16*/ number;
    }) {
      super('ConnectionMode', 'Proxy');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * IP
       */ ip: string;
      /**
       * Port
       */ port: /*u16*/ number;
    }): Proxy_ {
      return new Proxy_(inner);
    }

    static instanceOf(obj: any): obj is Proxy_ {
      return obj.tag === ConnectionMode_Tags.Proxy;
    }
  }

  function instanceOf(obj: any): obj is ConnectionMode {
    return obj[uniffiTypeNameSymbol] === 'ConnectionMode';
  }

  return Object.freeze({
    instanceOf,
    Direct: Direct_,
    Proxy: Proxy_,
  });
})();

export type ConnectionMode = InstanceType<
  (typeof ConnectionMode)[keyof Omit<typeof ConnectionMode, 'instanceOf'>]
>;

// FfiConverter for enum ConnectionMode
const FfiConverterTypeConnectionMode = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ConnectionMode;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ConnectionMode.Direct();
        case 2:
          return new ConnectionMode.Proxy({
            ip: FfiConverterString.read(from),
            port: FfiConverterUInt16.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ConnectionMode_Tags.Direct: {
          ordinalConverter.write(1, into);
          return;
        }
        case ConnectionMode_Tags.Proxy: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.ip, into);
          FfiConverterUInt16.write(inner.port, into);
          return;
        }
        default:
          // Throwing from here means that ConnectionMode_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ConnectionMode_Tags.Direct: {
          return ordinalConverter.allocationSize(1);
        }
        case ConnectionMode_Tags.Proxy: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.ip);
          size += FfiConverterUInt16.allocationSize(inner.port);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * Connection target
 */
export enum ConnectionTarget {
  /**
   * Use proxy for all relays
   */
  All,
  /**
   * Use proxy only for `.onion` relays
   */
  Onion,
}

const FfiConverterTypeConnectionTarget = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ConnectionTarget;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return ConnectionTarget.All;
        case 2:
          return ConnectionTarget.Onion;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case ConnectionTarget.All:
          return ordinalConverter.write(1, into);
        case ConnectionTarget.Onion:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum DataVendingMachineStatus {
  PaymentRequired,
  Processing,
  Error,
  Success,
  Partial,
}

const FfiConverterTypeDataVendingMachineStatus = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = DataVendingMachineStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return DataVendingMachineStatus.PaymentRequired;
        case 2:
          return DataVendingMachineStatus.Processing;
        case 3:
          return DataVendingMachineStatus.Error;
        case 4:
          return DataVendingMachineStatus.Success;
        case 5:
          return DataVendingMachineStatus.Partial;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case DataVendingMachineStatus.PaymentRequired:
          return ordinalConverter.write(1, into);
        case DataVendingMachineStatus.Processing:
          return ordinalConverter.write(2, into);
        case DataVendingMachineStatus.Error:
          return ordinalConverter.write(3, into);
        case DataVendingMachineStatus.Success:
          return ordinalConverter.write(4, into);
        case DataVendingMachineStatus.Partial:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Encrypted Secret Key version (NIP49)
 */
export enum EncryptedSecretKeyVersion {
  V2,
}

const FfiConverterTypeEncryptedSecretKeyVersion = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EncryptedSecretKeyVersion;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return EncryptedSecretKeyVersion.V2;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case EncryptedSecretKeyVersion.V2:
          return ordinalConverter.write(1, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * NIP47 Response Error codes
 */
export enum ErrorCode {
  /**
   * The client is sending commands too fast.
   */
  RateLimited,
  /**
   * The command is not known of is intentionally not implemented
   */
  NotImplemented,
  /**
   * The wallet does not have enough funds to cover a fee reserve or the payment amount
   */
  InsufficientBalance,
  /**
   * The payment failed. This may be due to a timeout, exhausting all routes, insufficient capacity or similar.
   */
  PaymentFailed,
  /**
   * The invoice could not be found by the given parameters.
   */
  NotFound,
  /**
   * The wallet has exceeded its spending quota
   */
  QuotaExceeded,
  /**
   * This public key is not allowed to do this operation
   */
  Restricted,
  /**
   * This public key has no wallet connected
   */
  Unauthorized,
  /**
   * An internal error
   */
  Internal,
  /**
   * Other error
   */
  Other,
}

const FfiConverterTypeErrorCode = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ErrorCode;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return ErrorCode.RateLimited;
        case 2:
          return ErrorCode.NotImplemented;
        case 3:
          return ErrorCode.InsufficientBalance;
        case 4:
          return ErrorCode.PaymentFailed;
        case 5:
          return ErrorCode.NotFound;
        case 6:
          return ErrorCode.QuotaExceeded;
        case 7:
          return ErrorCode.Restricted;
        case 8:
          return ErrorCode.Unauthorized;
        case 9:
          return ErrorCode.Internal;
        case 10:
          return ErrorCode.Other;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case ErrorCode.RateLimited:
          return ordinalConverter.write(1, into);
        case ErrorCode.NotImplemented:
          return ordinalConverter.write(2, into);
        case ErrorCode.InsufficientBalance:
          return ordinalConverter.write(3, into);
        case ErrorCode.PaymentFailed:
          return ordinalConverter.write(4, into);
        case ErrorCode.NotFound:
          return ordinalConverter.write(5, into);
        case ErrorCode.QuotaExceeded:
          return ordinalConverter.write(6, into);
        case ErrorCode.Restricted:
          return ordinalConverter.write(7, into);
        case ErrorCode.Unauthorized:
          return ordinalConverter.write(8, into);
        case ErrorCode.Internal:
          return ordinalConverter.write(9, into);
        case ErrorCode.Other:
          return ordinalConverter.write(10, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: ExternalContentId
export enum ExternalContentId_Tags {
  Url = 'Url',
  Hashtag = 'Hashtag',
  Geohash = 'Geohash',
  Book = 'Book',
  PodcastFeed = 'PodcastFeed',
  PodcastEpisode = 'PodcastEpisode',
  PodcastPublisher = 'PodcastPublisher',
  Movie = 'Movie',
  Paper = 'Paper',
}
/**
 * External Content ID
 */
export const ExternalContentId = (() => {
  type Url__interface = {
    tag: ExternalContentId_Tags.Url;
    inner: Readonly<[string]>;
  };

  /**
   * URL
   */
  class Url_ extends UniffiEnum implements Url__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ExternalContentId';
    readonly tag = ExternalContentId_Tags.Url;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ExternalContentId', 'Url');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Url_ {
      return new Url_(v0);
    }

    static instanceOf(obj: any): obj is Url_ {
      return obj.tag === ExternalContentId_Tags.Url;
    }
  }

  type Hashtag__interface = {
    tag: ExternalContentId_Tags.Hashtag;
    inner: Readonly<[string]>;
  };

  /**
   * Hashtag
   */
  class Hashtag_ extends UniffiEnum implements Hashtag__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ExternalContentId';
    readonly tag = ExternalContentId_Tags.Hashtag;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ExternalContentId', 'Hashtag');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Hashtag_ {
      return new Hashtag_(v0);
    }

    static instanceOf(obj: any): obj is Hashtag_ {
      return obj.tag === ExternalContentId_Tags.Hashtag;
    }
  }

  type Geohash__interface = {
    tag: ExternalContentId_Tags.Geohash;
    inner: Readonly<[string]>;
  };

  /**
   * Geohash
   */
  class Geohash_ extends UniffiEnum implements Geohash__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ExternalContentId';
    readonly tag = ExternalContentId_Tags.Geohash;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ExternalContentId', 'Geohash');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Geohash_ {
      return new Geohash_(v0);
    }

    static instanceOf(obj: any): obj is Geohash_ {
      return obj.tag === ExternalContentId_Tags.Geohash;
    }
  }

  type Book__interface = {
    tag: ExternalContentId_Tags.Book;
    inner: Readonly<[string]>;
  };

  /**
   * Book
   */
  class Book_ extends UniffiEnum implements Book__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ExternalContentId';
    readonly tag = ExternalContentId_Tags.Book;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ExternalContentId', 'Book');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Book_ {
      return new Book_(v0);
    }

    static instanceOf(obj: any): obj is Book_ {
      return obj.tag === ExternalContentId_Tags.Book;
    }
  }

  type PodcastFeed__interface = {
    tag: ExternalContentId_Tags.PodcastFeed;
    inner: Readonly<[string]>;
  };

  /**
   * Podcast Feed
   */
  class PodcastFeed_ extends UniffiEnum implements PodcastFeed__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ExternalContentId';
    readonly tag = ExternalContentId_Tags.PodcastFeed;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ExternalContentId', 'PodcastFeed');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): PodcastFeed_ {
      return new PodcastFeed_(v0);
    }

    static instanceOf(obj: any): obj is PodcastFeed_ {
      return obj.tag === ExternalContentId_Tags.PodcastFeed;
    }
  }

  type PodcastEpisode__interface = {
    tag: ExternalContentId_Tags.PodcastEpisode;
    inner: Readonly<[string]>;
  };

  /**
   * Podcast Episode
   */
  class PodcastEpisode_
    extends UniffiEnum
    implements PodcastEpisode__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ExternalContentId';
    readonly tag = ExternalContentId_Tags.PodcastEpisode;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ExternalContentId', 'PodcastEpisode');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): PodcastEpisode_ {
      return new PodcastEpisode_(v0);
    }

    static instanceOf(obj: any): obj is PodcastEpisode_ {
      return obj.tag === ExternalContentId_Tags.PodcastEpisode;
    }
  }

  type PodcastPublisher__interface = {
    tag: ExternalContentId_Tags.PodcastPublisher;
    inner: Readonly<[string]>;
  };

  /**
   * Podcast Publisher
   */
  class PodcastPublisher_
    extends UniffiEnum
    implements PodcastPublisher__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ExternalContentId';
    readonly tag = ExternalContentId_Tags.PodcastPublisher;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ExternalContentId', 'PodcastPublisher');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): PodcastPublisher_ {
      return new PodcastPublisher_(v0);
    }

    static instanceOf(obj: any): obj is PodcastPublisher_ {
      return obj.tag === ExternalContentId_Tags.PodcastPublisher;
    }
  }

  type Movie__interface = {
    tag: ExternalContentId_Tags.Movie;
    inner: Readonly<[string]>;
  };

  /**
   * Movie
   */
  class Movie_ extends UniffiEnum implements Movie__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ExternalContentId';
    readonly tag = ExternalContentId_Tags.Movie;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ExternalContentId', 'Movie');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Movie_ {
      return new Movie_(v0);
    }

    static instanceOf(obj: any): obj is Movie_ {
      return obj.tag === ExternalContentId_Tags.Movie;
    }
  }

  type Paper__interface = {
    tag: ExternalContentId_Tags.Paper;
    inner: Readonly<[string]>;
  };

  /**
   * Paper
   */
  class Paper_ extends UniffiEnum implements Paper__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ExternalContentId';
    readonly tag = ExternalContentId_Tags.Paper;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ExternalContentId', 'Paper');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Paper_ {
      return new Paper_(v0);
    }

    static instanceOf(obj: any): obj is Paper_ {
      return obj.tag === ExternalContentId_Tags.Paper;
    }
  }

  function instanceOf(obj: any): obj is ExternalContentId {
    return obj[uniffiTypeNameSymbol] === 'ExternalContentId';
  }

  return Object.freeze({
    instanceOf,
    Url: Url_,
    Hashtag: Hashtag_,
    Geohash: Geohash_,
    Book: Book_,
    PodcastFeed: PodcastFeed_,
    PodcastEpisode: PodcastEpisode_,
    PodcastPublisher: PodcastPublisher_,
    Movie: Movie_,
    Paper: Paper_,
  });
})();

/**
 * External Content ID
 */

export type ExternalContentId = InstanceType<
  (typeof ExternalContentId)[keyof Omit<typeof ExternalContentId, 'instanceOf'>]
>;

// FfiConverter for enum ExternalContentId
const FfiConverterTypeExternalContentId = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ExternalContentId;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ExternalContentId.Url(FfiConverterString.read(from));
        case 2:
          return new ExternalContentId.Hashtag(FfiConverterString.read(from));
        case 3:
          return new ExternalContentId.Geohash(FfiConverterString.read(from));
        case 4:
          return new ExternalContentId.Book(FfiConverterString.read(from));
        case 5:
          return new ExternalContentId.PodcastFeed(
            FfiConverterString.read(from)
          );
        case 6:
          return new ExternalContentId.PodcastEpisode(
            FfiConverterString.read(from)
          );
        case 7:
          return new ExternalContentId.PodcastPublisher(
            FfiConverterString.read(from)
          );
        case 8:
          return new ExternalContentId.Movie(FfiConverterString.read(from));
        case 9:
          return new ExternalContentId.Paper(FfiConverterString.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ExternalContentId_Tags.Url: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ExternalContentId_Tags.Hashtag: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ExternalContentId_Tags.Geohash: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ExternalContentId_Tags.Book: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ExternalContentId_Tags.PodcastFeed: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ExternalContentId_Tags.PodcastEpisode: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ExternalContentId_Tags.PodcastPublisher: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ExternalContentId_Tags.Movie: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ExternalContentId_Tags.Paper: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that ExternalContentId_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ExternalContentId_Tags.Url: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ExternalContentId_Tags.Hashtag: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ExternalContentId_Tags.Geohash: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ExternalContentId_Tags.Book: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ExternalContentId_Tags.PodcastFeed: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ExternalContentId_Tags.PodcastEpisode: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ExternalContentId_Tags.PodcastPublisher: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ExternalContentId_Tags.Movie: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ExternalContentId_Tags.Paper: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * Supported external identity providers
 *
 * <https://github.com/nostr-protocol/nips/blob/master/39.md>
 */
export enum ExternalIdentity {
  /**
   * github.com
   */
  GitHub,
  /**
   * twitter.com
   */
  Twitter,
  /**
   * mastodon.social
   */
  Mastodon,
  /**
   * telegram.org
   */
  Telegram,
}

const FfiConverterTypeExternalIdentity = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ExternalIdentity;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return ExternalIdentity.GitHub;
        case 2:
          return ExternalIdentity.Twitter;
        case 3:
          return ExternalIdentity.Mastodon;
        case 4:
          return ExternalIdentity.Telegram;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case ExternalIdentity.GitHub:
          return ordinalConverter.write(1, into);
        case ExternalIdentity.Twitter:
          return ordinalConverter.write(2, into);
        case ExternalIdentity.Mastodon:
          return ordinalConverter.write(3, into);
        case ExternalIdentity.Telegram:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: ExtractedComment
export enum ExtractedComment_Tags {
  Event = 'Event',
  Address = 'Address',
  External = 'External',
}
/**
 * Extracted NIP22 comment
 *
 * <https://github.com/nostr-protocol/nips/blob/master/22.md>
 */
export const ExtractedComment = (() => {
  type Event__interface = {
    tag: ExtractedComment_Tags.Event;
    inner: Readonly<{
      id: EventIdInterface;
      relayHint: string | undefined;
      pubkeyHint: PublicKeyInterface | undefined;
      kind: KindInterface | undefined;
    }>;
  };

  /**
   * Event
   */
  class Event_ extends UniffiEnum implements Event__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ExtractedComment';
    readonly tag = ExtractedComment_Tags.Event;
    readonly inner: Readonly<{
      id: EventIdInterface;
      relayHint: string | undefined;
      pubkeyHint: PublicKeyInterface | undefined;
      kind: KindInterface | undefined;
    }>;
    constructor(inner: {
      /**
       * Event ID
       */ id: EventIdInterface;
      /**
       * Relay hint
       */ relayHint: string | undefined;
      /**
       * Public key hint
       */ pubkeyHint: PublicKeyInterface | undefined;
      /**
       * Kind
       */ kind: KindInterface | undefined;
    }) {
      super('ExtractedComment', 'Event');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Event ID
       */ id: EventIdInterface;
      /**
       * Relay hint
       */ relayHint: string | undefined;
      /**
       * Public key hint
       */ pubkeyHint: PublicKeyInterface | undefined;
      /**
       * Kind
       */ kind: KindInterface | undefined;
    }): Event_ {
      return new Event_(inner);
    }

    static instanceOf(obj: any): obj is Event_ {
      return obj.tag === ExtractedComment_Tags.Event;
    }
  }

  type Address__interface = {
    tag: ExtractedComment_Tags.Address;
    inner: Readonly<{
      address: CoordinateInterface;
      relayHint: string | undefined;
      kind: KindInterface | undefined;
    }>;
  };

  /**
   * Coordinate
   */
  class Address_ extends UniffiEnum implements Address__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ExtractedComment';
    readonly tag = ExtractedComment_Tags.Address;
    readonly inner: Readonly<{
      address: CoordinateInterface;
      relayHint: string | undefined;
      kind: KindInterface | undefined;
    }>;
    constructor(inner: {
      /**
       * Coordinate
       */ address: CoordinateInterface;
      /**
       * Relay hint
       */ relayHint: string | undefined;
      /**
       * Kind
       */ kind: KindInterface | undefined;
    }) {
      super('ExtractedComment', 'Address');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Coordinate
       */ address: CoordinateInterface;
      /**
       * Relay hint
       */ relayHint: string | undefined;
      /**
       * Kind
       */ kind: KindInterface | undefined;
    }): Address_ {
      return new Address_(inner);
    }

    static instanceOf(obj: any): obj is Address_ {
      return obj.tag === ExtractedComment_Tags.Address;
    }
  }

  type External__interface = {
    tag: ExtractedComment_Tags.External;
    inner: Readonly<{ content: ExternalContentId; hint: string | undefined }>;
  };

  /**
   * External content
   */
  class External_ extends UniffiEnum implements External__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ExtractedComment';
    readonly tag = ExtractedComment_Tags.External;
    readonly inner: Readonly<{
      content: ExternalContentId;
      hint: string | undefined;
    }>;
    constructor(inner: {
      /**
       * Content
       */ content: ExternalContentId;
      /**
       * Web hint
       */ hint: string | undefined;
    }) {
      super('ExtractedComment', 'External');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Content
       */ content: ExternalContentId;
      /**
       * Web hint
       */ hint: string | undefined;
    }): External_ {
      return new External_(inner);
    }

    static instanceOf(obj: any): obj is External_ {
      return obj.tag === ExtractedComment_Tags.External;
    }
  }

  function instanceOf(obj: any): obj is ExtractedComment {
    return obj[uniffiTypeNameSymbol] === 'ExtractedComment';
  }

  return Object.freeze({
    instanceOf,
    Event: Event_,
    Address: Address_,
    External: External_,
  });
})();

/**
 * Extracted NIP22 comment
 *
 * <https://github.com/nostr-protocol/nips/blob/master/22.md>
 */

export type ExtractedComment = InstanceType<
  (typeof ExtractedComment)[keyof Omit<typeof ExtractedComment, 'instanceOf'>]
>;

// FfiConverter for enum ExtractedComment
const FfiConverterTypeExtractedComment = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ExtractedComment;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ExtractedComment.Event({
            id: FfiConverterTypeEventId.read(from),
            relayHint: FfiConverterOptionalString.read(from),
            pubkeyHint: FfiConverterOptionalTypePublicKey.read(from),
            kind: FfiConverterOptionalTypeKind.read(from),
          });
        case 2:
          return new ExtractedComment.Address({
            address: FfiConverterTypeCoordinate.read(from),
            relayHint: FfiConverterOptionalString.read(from),
            kind: FfiConverterOptionalTypeKind.read(from),
          });
        case 3:
          return new ExtractedComment.External({
            content: FfiConverterTypeExternalContentId.read(from),
            hint: FfiConverterOptionalString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ExtractedComment_Tags.Event: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeEventId.write(inner.id, into);
          FfiConverterOptionalString.write(inner.relayHint, into);
          FfiConverterOptionalTypePublicKey.write(inner.pubkeyHint, into);
          FfiConverterOptionalTypeKind.write(inner.kind, into);
          return;
        }
        case ExtractedComment_Tags.Address: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeCoordinate.write(inner.address, into);
          FfiConverterOptionalString.write(inner.relayHint, into);
          FfiConverterOptionalTypeKind.write(inner.kind, into);
          return;
        }
        case ExtractedComment_Tags.External: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeExternalContentId.write(inner.content, into);
          FfiConverterOptionalString.write(inner.hint, into);
          return;
        }
        default:
          // Throwing from here means that ExtractedComment_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ExtractedComment_Tags.Event: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeEventId.allocationSize(inner.id);
          size += FfiConverterOptionalString.allocationSize(inner.relayHint);
          size += FfiConverterOptionalTypePublicKey.allocationSize(
            inner.pubkeyHint
          );
          size += FfiConverterOptionalTypeKind.allocationSize(inner.kind);
          return size;
        }
        case ExtractedComment_Tags.Address: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeCoordinate.allocationSize(inner.address);
          size += FfiConverterOptionalString.allocationSize(inner.relayHint);
          size += FfiConverterOptionalTypeKind.allocationSize(inner.kind);
          return size;
        }
        case ExtractedComment_Tags.External: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeExternalContentId.allocationSize(
            inner.content
          );
          size += FfiConverterOptionalString.allocationSize(inner.hint);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: GitPatchContent
export enum GitPatchContent_Tags {
  CoverLetter = 'CoverLetter',
  Patch = 'Patch',
}
/**
 * Git Patch Content
 */
export const GitPatchContent = (() => {
  type CoverLetter__interface = {
    tag: GitPatchContent_Tags.CoverLetter;
    inner: Readonly<{
      title: string;
      description: string;
      lastCommit: string;
      commitsLen: /*u64*/ bigint;
    }>;
  };

  /**
   * Cover letter
   */
  class CoverLetter_ extends UniffiEnum implements CoverLetter__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'GitPatchContent';
    readonly tag = GitPatchContent_Tags.CoverLetter;
    readonly inner: Readonly<{
      title: string;
      description: string;
      lastCommit: string;
      commitsLen: /*u64*/ bigint;
    }>;
    constructor(inner: {
      /**
       * Title
       */ title: string;
      /**
       * Description
       */ description: string;
      /**
       * Last commit
       */ lastCommit: string;
      /**
       * Number of commits
       */ commitsLen: /*u64*/ bigint;
    }) {
      super('GitPatchContent', 'CoverLetter');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Title
       */ title: string;
      /**
       * Description
       */ description: string;
      /**
       * Last commit
       */ lastCommit: string;
      /**
       * Number of commits
       */ commitsLen: /*u64*/ bigint;
    }): CoverLetter_ {
      return new CoverLetter_(inner);
    }

    static instanceOf(obj: any): obj is CoverLetter_ {
      return obj.tag === GitPatchContent_Tags.CoverLetter;
    }
  }

  type Patch__interface = {
    tag: GitPatchContent_Tags.Patch;
    inner: Readonly<{
      content: string;
      commit: string;
      parentCommit: string;
      commitPgpSig: string | undefined;
      committer: GitPatchCommitter;
    }>;
  };

  /**
   * Patch
   */
  class Patch_ extends UniffiEnum implements Patch__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'GitPatchContent';
    readonly tag = GitPatchContent_Tags.Patch;
    readonly inner: Readonly<{
      content: string;
      commit: string;
      parentCommit: string;
      commitPgpSig: string | undefined;
      committer: GitPatchCommitter;
    }>;
    constructor(inner: {
      /**
       * Patch content
       */ content: string;
      /**
       * Commit hash
       */ commit: string;
      /**
       * Parent commit
       */ parentCommit: string;
      /**
       * PGP signature of commit
       */ commitPgpSig: string | undefined;
      /**
       * Committer
       */ committer: GitPatchCommitter;
    }) {
      super('GitPatchContent', 'Patch');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Patch content
       */ content: string;
      /**
       * Commit hash
       */ commit: string;
      /**
       * Parent commit
       */ parentCommit: string;
      /**
       * PGP signature of commit
       */ commitPgpSig: string | undefined;
      /**
       * Committer
       */ committer: GitPatchCommitter;
    }): Patch_ {
      return new Patch_(inner);
    }

    static instanceOf(obj: any): obj is Patch_ {
      return obj.tag === GitPatchContent_Tags.Patch;
    }
  }

  function instanceOf(obj: any): obj is GitPatchContent {
    return obj[uniffiTypeNameSymbol] === 'GitPatchContent';
  }

  return Object.freeze({
    instanceOf,
    CoverLetter: CoverLetter_,
    Patch: Patch_,
  });
})();

/**
 * Git Patch Content
 */

export type GitPatchContent = InstanceType<
  (typeof GitPatchContent)[keyof Omit<typeof GitPatchContent, 'instanceOf'>]
>;

// FfiConverter for enum GitPatchContent
const FfiConverterTypeGitPatchContent = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = GitPatchContent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new GitPatchContent.CoverLetter({
            title: FfiConverterString.read(from),
            description: FfiConverterString.read(from),
            lastCommit: FfiConverterString.read(from),
            commitsLen: FfiConverterUInt64.read(from),
          });
        case 2:
          return new GitPatchContent.Patch({
            content: FfiConverterString.read(from),
            commit: FfiConverterString.read(from),
            parentCommit: FfiConverterString.read(from),
            commitPgpSig: FfiConverterOptionalString.read(from),
            committer: FfiConverterTypeGitPatchCommitter.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case GitPatchContent_Tags.CoverLetter: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.title, into);
          FfiConverterString.write(inner.description, into);
          FfiConverterString.write(inner.lastCommit, into);
          FfiConverterUInt64.write(inner.commitsLen, into);
          return;
        }
        case GitPatchContent_Tags.Patch: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.content, into);
          FfiConverterString.write(inner.commit, into);
          FfiConverterString.write(inner.parentCommit, into);
          FfiConverterOptionalString.write(inner.commitPgpSig, into);
          FfiConverterTypeGitPatchCommitter.write(inner.committer, into);
          return;
        }
        default:
          // Throwing from here means that GitPatchContent_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case GitPatchContent_Tags.CoverLetter: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.title);
          size += FfiConverterString.allocationSize(inner.description);
          size += FfiConverterString.allocationSize(inner.lastCommit);
          size += FfiConverterUInt64.allocationSize(inner.commitsLen);
          return size;
        }
        case GitPatchContent_Tags.Patch: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.content);
          size += FfiConverterString.allocationSize(inner.commit);
          size += FfiConverterString.allocationSize(inner.parentCommit);
          size += FfiConverterOptionalString.allocationSize(inner.commitPgpSig);
          size += FfiConverterTypeGitPatchCommitter.allocationSize(
            inner.committer
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum HttpMethod {
  Get,
  Post,
  Put,
  Patch,
}

const FfiConverterTypeHttpMethod = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = HttpMethod;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return HttpMethod.Get;
        case 2:
          return HttpMethod.Post;
        case 3:
          return HttpMethod.Put;
        case 4:
          return HttpMethod.Patch;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case HttpMethod.Get:
          return ordinalConverter.write(1, into);
        case HttpMethod.Post:
          return ordinalConverter.write(2, into);
        case HttpMethod.Put:
          return ordinalConverter.write(3, into);
        case HttpMethod.Patch:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: JsonValue
export enum JsonValue_Tags {
  Bool = 'Bool',
  NumberPosInt = 'NumberPosInt',
  NumberNegInt = 'NumberNegInt',
  NumberFloat = 'NumberFloat',
  Str = 'Str',
  Array = 'Array',
  Object = 'Object',
  Null = 'Null',
}
export const JsonValue = (() => {
  type Bool__interface = {
    tag: JsonValue_Tags.Bool;
    inner: Readonly<{ bool: boolean }>;
  };

  class Bool_ extends UniffiEnum implements Bool__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JsonValue';
    readonly tag = JsonValue_Tags.Bool;
    readonly inner: Readonly<{ bool: boolean }>;
    constructor(inner: { bool: boolean }) {
      super('JsonValue', 'Bool');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { bool: boolean }): Bool_ {
      return new Bool_(inner);
    }

    static instanceOf(obj: any): obj is Bool_ {
      return obj.tag === JsonValue_Tags.Bool;
    }
  }

  type NumberPosInt__interface = {
    tag: JsonValue_Tags.NumberPosInt;
    inner: Readonly<{ number: /*u64*/ bigint }>;
  };

  class NumberPosInt_ extends UniffiEnum implements NumberPosInt__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JsonValue';
    readonly tag = JsonValue_Tags.NumberPosInt;
    readonly inner: Readonly<{ number: /*u64*/ bigint }>;
    constructor(inner: { number: /*u64*/ bigint }) {
      super('JsonValue', 'NumberPosInt');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { number: /*u64*/ bigint }): NumberPosInt_ {
      return new NumberPosInt_(inner);
    }

    static instanceOf(obj: any): obj is NumberPosInt_ {
      return obj.tag === JsonValue_Tags.NumberPosInt;
    }
  }

  type NumberNegInt__interface = {
    tag: JsonValue_Tags.NumberNegInt;
    inner: Readonly<{ number: /*i64*/ bigint }>;
  };

  class NumberNegInt_ extends UniffiEnum implements NumberNegInt__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JsonValue';
    readonly tag = JsonValue_Tags.NumberNegInt;
    readonly inner: Readonly<{ number: /*i64*/ bigint }>;
    constructor(inner: { number: /*i64*/ bigint }) {
      super('JsonValue', 'NumberNegInt');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { number: /*i64*/ bigint }): NumberNegInt_ {
      return new NumberNegInt_(inner);
    }

    static instanceOf(obj: any): obj is NumberNegInt_ {
      return obj.tag === JsonValue_Tags.NumberNegInt;
    }
  }

  type NumberFloat__interface = {
    tag: JsonValue_Tags.NumberFloat;
    inner: Readonly<{ number: /*f64*/ number }>;
  };

  class NumberFloat_ extends UniffiEnum implements NumberFloat__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JsonValue';
    readonly tag = JsonValue_Tags.NumberFloat;
    readonly inner: Readonly<{ number: /*f64*/ number }>;
    constructor(inner: { number: /*f64*/ number }) {
      super('JsonValue', 'NumberFloat');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { number: /*f64*/ number }): NumberFloat_ {
      return new NumberFloat_(inner);
    }

    static instanceOf(obj: any): obj is NumberFloat_ {
      return obj.tag === JsonValue_Tags.NumberFloat;
    }
  }

  type Str__interface = {
    tag: JsonValue_Tags.Str;
    inner: Readonly<{ s: string }>;
  };

  class Str_ extends UniffiEnum implements Str__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JsonValue';
    readonly tag = JsonValue_Tags.Str;
    readonly inner: Readonly<{ s: string }>;
    constructor(inner: { s: string }) {
      super('JsonValue', 'Str');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { s: string }): Str_ {
      return new Str_(inner);
    }

    static instanceOf(obj: any): obj is Str_ {
      return obj.tag === JsonValue_Tags.Str;
    }
  }

  type Array__interface = {
    tag: JsonValue_Tags.Array;
    inner: Readonly<{ array: Array<JsonValue> }>;
  };

  class Array_ extends UniffiEnum implements Array__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JsonValue';
    readonly tag = JsonValue_Tags.Array;
    readonly inner: Readonly<{ array: Array<JsonValue> }>;
    constructor(inner: { array: Array<JsonValue> }) {
      super('JsonValue', 'Array');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { array: Array<JsonValue> }): Array_ {
      return new Array_(inner);
    }

    static instanceOf(obj: any): obj is Array_ {
      return obj.tag === JsonValue_Tags.Array;
    }
  }

  type Object__interface = {
    tag: JsonValue_Tags.Object;
    inner: Readonly<{ map: Map<string, JsonValue> }>;
  };

  class Object_ extends UniffiEnum implements Object__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JsonValue';
    readonly tag = JsonValue_Tags.Object;
    readonly inner: Readonly<{ map: Map<string, JsonValue> }>;
    constructor(inner: { map: Map<string, JsonValue> }) {
      super('JsonValue', 'Object');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { map: Map<string, JsonValue> }): Object_ {
      return new Object_(inner);
    }

    static instanceOf(obj: any): obj is Object_ {
      return obj.tag === JsonValue_Tags.Object;
    }
  }

  type Null__interface = {
    tag: JsonValue_Tags.Null;
  };

  class Null_ extends UniffiEnum implements Null__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'JsonValue';
    readonly tag = JsonValue_Tags.Null;
    constructor() {
      super('JsonValue', 'Null');
    }

    static new(): Null_ {
      return new Null_();
    }

    static instanceOf(obj: any): obj is Null_ {
      return obj.tag === JsonValue_Tags.Null;
    }
  }

  function instanceOf(obj: any): obj is JsonValue {
    return obj[uniffiTypeNameSymbol] === 'JsonValue';
  }

  return Object.freeze({
    instanceOf,
    Bool: Bool_,
    NumberPosInt: NumberPosInt_,
    NumberNegInt: NumberNegInt_,
    NumberFloat: NumberFloat_,
    Str: Str_,
    Array: Array_,
    Object: Object_,
    Null: Null_,
  });
})();

export type JsonValue = InstanceType<
  (typeof JsonValue)[keyof Omit<typeof JsonValue, 'instanceOf'>]
>;

// FfiConverter for enum JsonValue
const FfiConverterTypeJsonValue = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = JsonValue;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new JsonValue.Bool({ bool: FfiConverterBool.read(from) });
        case 2:
          return new JsonValue.NumberPosInt({
            number: FfiConverterUInt64.read(from),
          });
        case 3:
          return new JsonValue.NumberNegInt({
            number: FfiConverterInt64.read(from),
          });
        case 4:
          return new JsonValue.NumberFloat({
            number: FfiConverterFloat64.read(from),
          });
        case 5:
          return new JsonValue.Str({ s: FfiConverterString.read(from) });
        case 6:
          return new JsonValue.Array({
            array: FfiConverterArrayTypeJsonValue.read(from),
          });
        case 7:
          return new JsonValue.Object({
            map: FfiConverterMapStringTypeJsonValue.read(from),
          });
        case 8:
          return new JsonValue.Null();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case JsonValue_Tags.Bool: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterBool.write(inner.bool, into);
          return;
        }
        case JsonValue_Tags.NumberPosInt: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.number, into);
          return;
        }
        case JsonValue_Tags.NumberNegInt: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterInt64.write(inner.number, into);
          return;
        }
        case JsonValue_Tags.NumberFloat: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterFloat64.write(inner.number, into);
          return;
        }
        case JsonValue_Tags.Str: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.s, into);
          return;
        }
        case JsonValue_Tags.Array: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterArrayTypeJsonValue.write(inner.array, into);
          return;
        }
        case JsonValue_Tags.Object: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterMapStringTypeJsonValue.write(inner.map, into);
          return;
        }
        case JsonValue_Tags.Null: {
          ordinalConverter.write(8, into);
          return;
        }
        default:
          // Throwing from here means that JsonValue_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case JsonValue_Tags.Bool: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterBool.allocationSize(inner.bool);
          return size;
        }
        case JsonValue_Tags.NumberPosInt: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt64.allocationSize(inner.number);
          return size;
        }
        case JsonValue_Tags.NumberNegInt: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterInt64.allocationSize(inner.number);
          return size;
        }
        case JsonValue_Tags.NumberFloat: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterFloat64.allocationSize(inner.number);
          return size;
        }
        case JsonValue_Tags.Str: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.s);
          return size;
        }
        case JsonValue_Tags.Array: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterArrayTypeJsonValue.allocationSize(inner.array);
          return size;
        }
        case JsonValue_Tags.Object: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterMapStringTypeJsonValue.allocationSize(inner.map);
          return size;
        }
        case JsonValue_Tags.Null: {
          return ordinalConverter.allocationSize(8);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * Key security
 */
export enum KeySecurity {
  /**
   * The key has been known to have been handled insecurely (stored unencrypted, cut and paste unencrypted, etc)
   */
  Weak,
  /**
   * The key has NOT been known to have been handled insecurely (stored encrypted, cut and paste encrypted, etc)
   */
  Medium,
  /**
   * The client does not track this data
   */
  Unknown,
}

const FfiConverterTypeKeySecurity = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = KeySecurity;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return KeySecurity.Weak;
        case 2:
          return KeySecurity.Medium;
        case 3:
          return KeySecurity.Unknown;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case KeySecurity.Weak:
          return ordinalConverter.write(1, into);
        case KeySecurity.Medium:
          return ordinalConverter.write(2, into);
        case KeySecurity.Unknown:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Standardized kind
 */
export enum KindStandard {
  /**
   * Metadata (NIP01 and NIP05)
   */
  Metadata,
  /**
   * Short Text Note (NIP01)
   */
  TextNote,
  /**
   * Contacts (NIP02)
   */
  ContactList,
  /**
   * OpenTimestamps Attestations (NIP03)
   */
  OpenTimestamps,
  /**
   * Event Deletion (NIP09)
   */
  EventDeletion,
  /**
   * Repost (NIP18)
   */
  Repost,
  /**
   * Generic Repost (NIP18)
   */
  GenericRepost,
  /**
   * Comment (NIP22)
   */
  Comment,
  /**
   * Reaction (NIP25)
   */
  Reaction,
  /**
   * Badge Award (NIP58)
   */
  BadgeAward,
  /**
   * Channel Creation (NIP28)
   */
  ChannelCreation,
  /**
   * Channel Metadata (NIP28)
   */
  ChannelMetadata,
  /**
   * Channel Message (NIP28)
   */
  ChannelMessage,
  /**
   * Channel Hide Message (NIP28)
   */
  ChannelHideMessage,
  /**
   * Channel Mute User (NIP28)
   */
  ChannelMuteUser,
  /**
   * Git Patch
   *
   * <https://github.com/nostr-protocol/nips/blob/master/34.md>
   */
  GitPatch,
  /**
   * Git Issue
   *
   * <https://github.com/nostr-protocol/nips/blob/master/34.md>
   */
  GitIssue,
  /**
   * Git Reply
   *
   * <https://github.com/nostr-protocol/nips/blob/master/34.md>
   */
  GitReply,
  /**
   * Open Status of Git Patch or Issue
   *
   * <https://github.com/nostr-protocol/nips/blob/master/34.md>
   */
  GitStatusOpen,
  /**
   * Applied / Merged Status of Git Patch or Resolved Status of Git Issue
   *
   * <https://github.com/nostr-protocol/nips/blob/master/34.md>
   */
  GitStatusApplied,
  /**
   * Closed Status of Git Patch or Issue
   *
   * <https://github.com/nostr-protocol/nips/blob/master/34.md>
   */
  GitStatusClosed,
  /**
   * Draft Status of Git Patch or Issue
   *
   * <https://github.com/nostr-protocol/nips/blob/master/34.md>
   */
  GitStatusDraft,
  /**
   * Torrent
   *
   * <https://github.com/nostr-protocol/nips/blob/master/35.md>
   */
  Torrent,
  /**
   * Torrent comment
   *
   * <https://github.com/nostr-protocol/nips/blob/master/35.md>
   */
  TorrentComment,
  /**
   * Label
   *
   * <https://github.com/nostr-protocol/nips/blob/master/32.md>
   */
  Label,
  /**
   * Wallet Service Info (NIP47)
   */
  WalletConnectInfo,
  /**
   * Reporting (NIP56)
   */
  Reporting,
  /**
   * Zap Private Message (NIP57)
   */
  ZapPrivateMessage,
  /**
   * Zap Request (NIP57)
   */
  ZapRequest,
  /**
   * Zap Receipt (NIP57)
   */
  ZapReceipt,
  /**
   * Mute List
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  MuteList,
  /**
   * Pin List
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  PinList,
  /**
   * Bookmarks
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  Bookmarks,
  /**
   * Communities
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  Communities,
  /**
   * Public Chats
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  PublicChats,
  /**
   * Blocked Relays
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  BlockedRelays,
  /**
   * Search Relays
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  SearchRelays,
  /**
   * Simple Groups
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  SimpleGroups,
  /**
   * Interests
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  Interests,
  /**
   * Emojis
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  Emojis,
  /**
   * Follow Set
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  FollowSet,
  /**
   * Relay Set
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  RelaySet,
  /**
   * Bookmark Set
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  BookmarkSet,
  /**
   * Articles Curation Set
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  ArticlesCurationSet,
  /**
   * Videos Curation Set
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  VideosCurationSet,
  /**
   * Interest Set
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  InterestSet,
  /**
   * Emoji Set
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  EmojiSet,
  /**
   * Release Artifact Set
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  ReleaseArtifactSet,
  /**
   * Relay List Metadata (NIP65)
   */
  RelayList,
  /**
   * Peer-to-peer Order events
   *
   * <https://github.com/nostr-protocol/nips/blob/master/69.md>
   */
  PeerToPeerOrder,
  /**
   * Request to Vanish (NIP62)
   *
   * <https://github.com/nostr-protocol/nips/blob/master/62.md>
   */
  RequestToVanish,
  /**
   * Client Authentication (NIP42)
   */
  Authentication,
  /**
   * Wallet Connect Request (NIP47)
   */
  WalletConnectRequest,
  /**
   * Wallet Connect Response (NIP47)
   */
  WalletConnectResponse,
  /**
   * Nostr Connect (NIP46)
   */
  NostrConnect,
  /**
   * Live Event (NIP53)
   */
  LiveEvent,
  /**
   * Live Event Message (NIP53)
   */
  LiveEventMessage,
  /**
   * Profile Badges (NIP58)
   */
  ProfileBadges,
  /**
   * Badge Definition (NIP58)
   */
  BadgeDefinition,
  /**
   * Seal (NIP59)
   */
  Seal,
  /**
   * Gift Wrap (NIP59)
   */
  GiftWrap,
  /**
   * Private Direct message
   *
   * <https://github.com/nostr-protocol/nips/blob/master/17.md>
   */
  PrivateDirectMessage,
  /**
   * Inbox Relays (NIP17)
   */
  InboxRelays,
  /**
   * MLS Key Package Relays (NIP104)
   */
  MlsKeyPackageRelays,
  /**
   * MLS Key Package (NIP104)
   */
  MlsKeyPackage,
  /**
   * MLS Welcome (NIP104)
   */
  MlsWelcome,
  /**
   * MLS Group Message (NIP104)
   */
  MlsGroupMessage,
  /**
   * Long-form Text Note (NIP23)
   */
  LongFormTextNote,
  /**
   * Git Repository Announcement
   *
   * <https://github.com/nostr-protocol/nips/blob/master/34.md>
   */
  GitRepoAnnouncement,
  /**
   * Application-specific Data (NIP78)
   */
  ApplicationSpecificData,
  /**
   * File Metadata (NIP94)
   */
  FileMetadata,
  /**
   * HTTP Auth (NIP98)
   */
  HttpAuth,
  /**
   * Set stall (NIP15)
   */
  SetStall,
  /**
   * Set product (NIP15)
   */
  SetProduct,
  /**
   * Job Feedback (NIP90)
   */
  JobFeedback,
  /**
   * User Status
   *
   * <https://github.com/nostr-protocol/nips/blob/master/38.md>
   */
  UserStatus,
  /**
   * Cashu Wallet
   *
   * <https://github.com/nostr-protocol/nips/blob/master/60.md>
   */
  CashuWallet,
  /**
   * Cashu Wallet Unspent Proof
   *
   * <https://github.com/nostr-protocol/nips/blob/master/60.md>
   */
  CashuWalletUnspentProof,
  /**
   * Cashu Wallet Spending History
   *
   * <https://github.com/nostr-protocol/nips/blob/master/60.md>
   */
  CashuWalletSpendingHistory,
}

const FfiConverterTypeKindStandard = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = KindStandard;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return KindStandard.Metadata;
        case 2:
          return KindStandard.TextNote;
        case 3:
          return KindStandard.ContactList;
        case 4:
          return KindStandard.OpenTimestamps;
        case 5:
          return KindStandard.EventDeletion;
        case 6:
          return KindStandard.Repost;
        case 7:
          return KindStandard.GenericRepost;
        case 8:
          return KindStandard.Comment;
        case 9:
          return KindStandard.Reaction;
        case 10:
          return KindStandard.BadgeAward;
        case 11:
          return KindStandard.ChannelCreation;
        case 12:
          return KindStandard.ChannelMetadata;
        case 13:
          return KindStandard.ChannelMessage;
        case 14:
          return KindStandard.ChannelHideMessage;
        case 15:
          return KindStandard.ChannelMuteUser;
        case 16:
          return KindStandard.GitPatch;
        case 17:
          return KindStandard.GitIssue;
        case 18:
          return KindStandard.GitReply;
        case 19:
          return KindStandard.GitStatusOpen;
        case 20:
          return KindStandard.GitStatusApplied;
        case 21:
          return KindStandard.GitStatusClosed;
        case 22:
          return KindStandard.GitStatusDraft;
        case 23:
          return KindStandard.Torrent;
        case 24:
          return KindStandard.TorrentComment;
        case 25:
          return KindStandard.Label;
        case 26:
          return KindStandard.WalletConnectInfo;
        case 27:
          return KindStandard.Reporting;
        case 28:
          return KindStandard.ZapPrivateMessage;
        case 29:
          return KindStandard.ZapRequest;
        case 30:
          return KindStandard.ZapReceipt;
        case 31:
          return KindStandard.MuteList;
        case 32:
          return KindStandard.PinList;
        case 33:
          return KindStandard.Bookmarks;
        case 34:
          return KindStandard.Communities;
        case 35:
          return KindStandard.PublicChats;
        case 36:
          return KindStandard.BlockedRelays;
        case 37:
          return KindStandard.SearchRelays;
        case 38:
          return KindStandard.SimpleGroups;
        case 39:
          return KindStandard.Interests;
        case 40:
          return KindStandard.Emojis;
        case 41:
          return KindStandard.FollowSet;
        case 42:
          return KindStandard.RelaySet;
        case 43:
          return KindStandard.BookmarkSet;
        case 44:
          return KindStandard.ArticlesCurationSet;
        case 45:
          return KindStandard.VideosCurationSet;
        case 46:
          return KindStandard.InterestSet;
        case 47:
          return KindStandard.EmojiSet;
        case 48:
          return KindStandard.ReleaseArtifactSet;
        case 49:
          return KindStandard.RelayList;
        case 50:
          return KindStandard.PeerToPeerOrder;
        case 51:
          return KindStandard.RequestToVanish;
        case 52:
          return KindStandard.Authentication;
        case 53:
          return KindStandard.WalletConnectRequest;
        case 54:
          return KindStandard.WalletConnectResponse;
        case 55:
          return KindStandard.NostrConnect;
        case 56:
          return KindStandard.LiveEvent;
        case 57:
          return KindStandard.LiveEventMessage;
        case 58:
          return KindStandard.ProfileBadges;
        case 59:
          return KindStandard.BadgeDefinition;
        case 60:
          return KindStandard.Seal;
        case 61:
          return KindStandard.GiftWrap;
        case 62:
          return KindStandard.PrivateDirectMessage;
        case 63:
          return KindStandard.InboxRelays;
        case 64:
          return KindStandard.MlsKeyPackageRelays;
        case 65:
          return KindStandard.MlsKeyPackage;
        case 66:
          return KindStandard.MlsWelcome;
        case 67:
          return KindStandard.MlsGroupMessage;
        case 68:
          return KindStandard.LongFormTextNote;
        case 69:
          return KindStandard.GitRepoAnnouncement;
        case 70:
          return KindStandard.ApplicationSpecificData;
        case 71:
          return KindStandard.FileMetadata;
        case 72:
          return KindStandard.HttpAuth;
        case 73:
          return KindStandard.SetStall;
        case 74:
          return KindStandard.SetProduct;
        case 75:
          return KindStandard.JobFeedback;
        case 76:
          return KindStandard.UserStatus;
        case 77:
          return KindStandard.CashuWallet;
        case 78:
          return KindStandard.CashuWalletUnspentProof;
        case 79:
          return KindStandard.CashuWalletSpendingHistory;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case KindStandard.Metadata:
          return ordinalConverter.write(1, into);
        case KindStandard.TextNote:
          return ordinalConverter.write(2, into);
        case KindStandard.ContactList:
          return ordinalConverter.write(3, into);
        case KindStandard.OpenTimestamps:
          return ordinalConverter.write(4, into);
        case KindStandard.EventDeletion:
          return ordinalConverter.write(5, into);
        case KindStandard.Repost:
          return ordinalConverter.write(6, into);
        case KindStandard.GenericRepost:
          return ordinalConverter.write(7, into);
        case KindStandard.Comment:
          return ordinalConverter.write(8, into);
        case KindStandard.Reaction:
          return ordinalConverter.write(9, into);
        case KindStandard.BadgeAward:
          return ordinalConverter.write(10, into);
        case KindStandard.ChannelCreation:
          return ordinalConverter.write(11, into);
        case KindStandard.ChannelMetadata:
          return ordinalConverter.write(12, into);
        case KindStandard.ChannelMessage:
          return ordinalConverter.write(13, into);
        case KindStandard.ChannelHideMessage:
          return ordinalConverter.write(14, into);
        case KindStandard.ChannelMuteUser:
          return ordinalConverter.write(15, into);
        case KindStandard.GitPatch:
          return ordinalConverter.write(16, into);
        case KindStandard.GitIssue:
          return ordinalConverter.write(17, into);
        case KindStandard.GitReply:
          return ordinalConverter.write(18, into);
        case KindStandard.GitStatusOpen:
          return ordinalConverter.write(19, into);
        case KindStandard.GitStatusApplied:
          return ordinalConverter.write(20, into);
        case KindStandard.GitStatusClosed:
          return ordinalConverter.write(21, into);
        case KindStandard.GitStatusDraft:
          return ordinalConverter.write(22, into);
        case KindStandard.Torrent:
          return ordinalConverter.write(23, into);
        case KindStandard.TorrentComment:
          return ordinalConverter.write(24, into);
        case KindStandard.Label:
          return ordinalConverter.write(25, into);
        case KindStandard.WalletConnectInfo:
          return ordinalConverter.write(26, into);
        case KindStandard.Reporting:
          return ordinalConverter.write(27, into);
        case KindStandard.ZapPrivateMessage:
          return ordinalConverter.write(28, into);
        case KindStandard.ZapRequest:
          return ordinalConverter.write(29, into);
        case KindStandard.ZapReceipt:
          return ordinalConverter.write(30, into);
        case KindStandard.MuteList:
          return ordinalConverter.write(31, into);
        case KindStandard.PinList:
          return ordinalConverter.write(32, into);
        case KindStandard.Bookmarks:
          return ordinalConverter.write(33, into);
        case KindStandard.Communities:
          return ordinalConverter.write(34, into);
        case KindStandard.PublicChats:
          return ordinalConverter.write(35, into);
        case KindStandard.BlockedRelays:
          return ordinalConverter.write(36, into);
        case KindStandard.SearchRelays:
          return ordinalConverter.write(37, into);
        case KindStandard.SimpleGroups:
          return ordinalConverter.write(38, into);
        case KindStandard.Interests:
          return ordinalConverter.write(39, into);
        case KindStandard.Emojis:
          return ordinalConverter.write(40, into);
        case KindStandard.FollowSet:
          return ordinalConverter.write(41, into);
        case KindStandard.RelaySet:
          return ordinalConverter.write(42, into);
        case KindStandard.BookmarkSet:
          return ordinalConverter.write(43, into);
        case KindStandard.ArticlesCurationSet:
          return ordinalConverter.write(44, into);
        case KindStandard.VideosCurationSet:
          return ordinalConverter.write(45, into);
        case KindStandard.InterestSet:
          return ordinalConverter.write(46, into);
        case KindStandard.EmojiSet:
          return ordinalConverter.write(47, into);
        case KindStandard.ReleaseArtifactSet:
          return ordinalConverter.write(48, into);
        case KindStandard.RelayList:
          return ordinalConverter.write(49, into);
        case KindStandard.PeerToPeerOrder:
          return ordinalConverter.write(50, into);
        case KindStandard.RequestToVanish:
          return ordinalConverter.write(51, into);
        case KindStandard.Authentication:
          return ordinalConverter.write(52, into);
        case KindStandard.WalletConnectRequest:
          return ordinalConverter.write(53, into);
        case KindStandard.WalletConnectResponse:
          return ordinalConverter.write(54, into);
        case KindStandard.NostrConnect:
          return ordinalConverter.write(55, into);
        case KindStandard.LiveEvent:
          return ordinalConverter.write(56, into);
        case KindStandard.LiveEventMessage:
          return ordinalConverter.write(57, into);
        case KindStandard.ProfileBadges:
          return ordinalConverter.write(58, into);
        case KindStandard.BadgeDefinition:
          return ordinalConverter.write(59, into);
        case KindStandard.Seal:
          return ordinalConverter.write(60, into);
        case KindStandard.GiftWrap:
          return ordinalConverter.write(61, into);
        case KindStandard.PrivateDirectMessage:
          return ordinalConverter.write(62, into);
        case KindStandard.InboxRelays:
          return ordinalConverter.write(63, into);
        case KindStandard.MlsKeyPackageRelays:
          return ordinalConverter.write(64, into);
        case KindStandard.MlsKeyPackage:
          return ordinalConverter.write(65, into);
        case KindStandard.MlsWelcome:
          return ordinalConverter.write(66, into);
        case KindStandard.MlsGroupMessage:
          return ordinalConverter.write(67, into);
        case KindStandard.LongFormTextNote:
          return ordinalConverter.write(68, into);
        case KindStandard.GitRepoAnnouncement:
          return ordinalConverter.write(69, into);
        case KindStandard.ApplicationSpecificData:
          return ordinalConverter.write(70, into);
        case KindStandard.FileMetadata:
          return ordinalConverter.write(71, into);
        case KindStandard.HttpAuth:
          return ordinalConverter.write(72, into);
        case KindStandard.SetStall:
          return ordinalConverter.write(73, into);
        case KindStandard.SetProduct:
          return ordinalConverter.write(74, into);
        case KindStandard.JobFeedback:
          return ordinalConverter.write(75, into);
        case KindStandard.UserStatus:
          return ordinalConverter.write(76, into);
        case KindStandard.CashuWallet:
          return ordinalConverter.write(77, into);
        case KindStandard.CashuWalletUnspentProof:
          return ordinalConverter.write(78, into);
        case KindStandard.CashuWalletSpendingHistory:
          return ordinalConverter.write(79, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Live Event Marker
 */
export enum LiveEventMarker {
  /**
   * Host
   */
  Host,
  /**
   * Speaker
   */
  Speaker,
  /**
   * Participant
   */
  Participant,
}

const FfiConverterTypeLiveEventMarker = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LiveEventMarker;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return LiveEventMarker.Host;
        case 2:
          return LiveEventMarker.Speaker;
        case 3:
          return LiveEventMarker.Participant;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case LiveEventMarker.Host:
          return ordinalConverter.write(1, into);
        case LiveEventMarker.Speaker:
          return ordinalConverter.write(2, into);
        case LiveEventMarker.Participant:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: LiveEventStatus
export enum LiveEventStatus_Tags {
  Planned = 'Planned',
  Live = 'Live',
  Ended = 'Ended',
  Custom = 'Custom',
}
export const LiveEventStatus = (() => {
  type Planned__interface = {
    tag: LiveEventStatus_Tags.Planned;
  };

  class Planned_ extends UniffiEnum implements Planned__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LiveEventStatus';
    readonly tag = LiveEventStatus_Tags.Planned;
    constructor() {
      super('LiveEventStatus', 'Planned');
    }

    static new(): Planned_ {
      return new Planned_();
    }

    static instanceOf(obj: any): obj is Planned_ {
      return obj.tag === LiveEventStatus_Tags.Planned;
    }
  }

  type Live__interface = {
    tag: LiveEventStatus_Tags.Live;
  };

  class Live_ extends UniffiEnum implements Live__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LiveEventStatus';
    readonly tag = LiveEventStatus_Tags.Live;
    constructor() {
      super('LiveEventStatus', 'Live');
    }

    static new(): Live_ {
      return new Live_();
    }

    static instanceOf(obj: any): obj is Live_ {
      return obj.tag === LiveEventStatus_Tags.Live;
    }
  }

  type Ended__interface = {
    tag: LiveEventStatus_Tags.Ended;
  };

  class Ended_ extends UniffiEnum implements Ended__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LiveEventStatus';
    readonly tag = LiveEventStatus_Tags.Ended;
    constructor() {
      super('LiveEventStatus', 'Ended');
    }

    static new(): Ended_ {
      return new Ended_();
    }

    static instanceOf(obj: any): obj is Ended_ {
      return obj.tag === LiveEventStatus_Tags.Ended;
    }
  }

  type Custom__interface = {
    tag: LiveEventStatus_Tags.Custom;
    inner: Readonly<{ custom: string }>;
  };

  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LiveEventStatus';
    readonly tag = LiveEventStatus_Tags.Custom;
    readonly inner: Readonly<{ custom: string }>;
    constructor(inner: { custom: string }) {
      super('LiveEventStatus', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { custom: string }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === LiveEventStatus_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is LiveEventStatus {
    return obj[uniffiTypeNameSymbol] === 'LiveEventStatus';
  }

  return Object.freeze({
    instanceOf,
    Planned: Planned_,
    Live: Live_,
    Ended: Ended_,
    Custom: Custom_,
  });
})();

export type LiveEventStatus = InstanceType<
  (typeof LiveEventStatus)[keyof Omit<typeof LiveEventStatus, 'instanceOf'>]
>;

// FfiConverter for enum LiveEventStatus
const FfiConverterTypeLiveEventStatus = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LiveEventStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new LiveEventStatus.Planned();
        case 2:
          return new LiveEventStatus.Live();
        case 3:
          return new LiveEventStatus.Ended();
        case 4:
          return new LiveEventStatus.Custom({
            custom: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case LiveEventStatus_Tags.Planned: {
          ordinalConverter.write(1, into);
          return;
        }
        case LiveEventStatus_Tags.Live: {
          ordinalConverter.write(2, into);
          return;
        }
        case LiveEventStatus_Tags.Ended: {
          ordinalConverter.write(3, into);
          return;
        }
        case LiveEventStatus_Tags.Custom: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.custom, into);
          return;
        }
        default:
          // Throwing from here means that LiveEventStatus_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case LiveEventStatus_Tags.Planned: {
          return ordinalConverter.allocationSize(1);
        }
        case LiveEventStatus_Tags.Live: {
          return ordinalConverter.allocationSize(2);
        }
        case LiveEventStatus_Tags.Ended: {
          return ordinalConverter.allocationSize(3);
        }
        case LiveEventStatus_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.custom);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum LogLevel {
  Error,
  Warn,
  Info,
  Debug,
  Trace,
}

const FfiConverterTypeLogLevel = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LogLevel;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return LogLevel.Error;
        case 2:
          return LogLevel.Warn;
        case 3:
          return LogLevel.Info;
        case 4:
          return LogLevel.Debug;
        case 5:
          return LogLevel.Trace;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case LogLevel.Error:
          return ordinalConverter.write(1, into);
        case LogLevel.Warn:
          return ordinalConverter.write(2, into);
        case LogLevel.Info:
          return ordinalConverter.write(3, into);
        case LogLevel.Debug:
          return ordinalConverter.write(4, into);
        case LogLevel.Trace:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Marker
 */
export enum Marker {
  /**
   * Root
   */
  Root,
  /**
   * Reply
   */
  Reply,
  /**
   * Mention
   */
  Mention,
}

const FfiConverterTypeMarker = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Marker;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return Marker.Root;
        case 2:
          return Marker.Reply;
        case 3:
          return Marker.Mention;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case Marker.Root:
          return ordinalConverter.write(1, into);
        case Marker.Reply:
          return ordinalConverter.write(2, into);
        case Marker.Mention:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Method
 */
export enum Method {
  /**
   * Pay Invoice
   */
  PayInvoice,
  /**
   * Multi Pay Invoice
   */
  MultiPayInvoice,
  /**
   * Pay Keysend
   */
  PayKeysend,
  /**
   * Multi Pay Keysend
   */
  MultiPayKeysend,
  /**
   * Make Invoice
   */
  MakeInvoice,
  /**
   * Lookup Invoice
   */
  LookupInvoice,
  /**
   * List transactions
   */
  ListTransactions,
  /**
   * Get Balance
   */
  GetBalance,
  /**
   * Get Info
   */
  GetInfo,
}

const FfiConverterTypeMethod = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Method;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return Method.PayInvoice;
        case 2:
          return Method.MultiPayInvoice;
        case 3:
          return Method.PayKeysend;
        case 4:
          return Method.MultiPayKeysend;
        case 5:
          return Method.MakeInvoice;
        case 6:
          return Method.LookupInvoice;
        case 7:
          return Method.ListTransactions;
        case 8:
          return Method.GetBalance;
        case 9:
          return Method.GetInfo;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case Method.PayInvoice:
          return ordinalConverter.write(1, into);
        case Method.MultiPayInvoice:
          return ordinalConverter.write(2, into);
        case Method.PayKeysend:
          return ordinalConverter.write(3, into);
        case Method.MultiPayKeysend:
          return ordinalConverter.write(4, into);
        case Method.MakeInvoice:
          return ordinalConverter.write(5, into);
        case Method.LookupInvoice:
          return ordinalConverter.write(6, into);
        case Method.ListTransactions:
          return ordinalConverter.write(7, into);
        case Method.GetBalance:
          return ordinalConverter.write(8, into);
        case Method.GetInfo:
          return ordinalConverter.write(9, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: Nip19Enum
export enum Nip19Enum_Tags {
  Secret = 'Secret',
  EncryptedSecret = 'EncryptedSecret',
  Pubkey = 'Pubkey',
  Profile = 'Profile',
  Note = 'Note',
  Event = 'Event',
  Addr = 'Addr',
}
/**
 * A representation any `NIP19` bech32 nostr object. Useful for decoding
 * `NIP19` bech32 strings without necessarily knowing what you're decoding
 * ahead of time.
 */
export const Nip19Enum = (() => {
  type Secret__interface = {
    tag: Nip19Enum_Tags.Secret;
    inner: Readonly<{ nsec: SecretKeyInterface }>;
  };

  /**
   * nsec
   */
  class Secret_ extends UniffiEnum implements Secret__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip19Enum';
    readonly tag = Nip19Enum_Tags.Secret;
    readonly inner: Readonly<{ nsec: SecretKeyInterface }>;
    constructor(inner: { nsec: SecretKeyInterface }) {
      super('Nip19Enum', 'Secret');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { nsec: SecretKeyInterface }): Secret_ {
      return new Secret_(inner);
    }

    static instanceOf(obj: any): obj is Secret_ {
      return obj.tag === Nip19Enum_Tags.Secret;
    }
  }

  type EncryptedSecret__interface = {
    tag: Nip19Enum_Tags.EncryptedSecret;
    inner: Readonly<{ ncryptsec: EncryptedSecretKeyInterface }>;
  };

  /**
   * Encrypted Secret Key
   */
  class EncryptedSecret_
    extends UniffiEnum
    implements EncryptedSecret__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip19Enum';
    readonly tag = Nip19Enum_Tags.EncryptedSecret;
    readonly inner: Readonly<{ ncryptsec: EncryptedSecretKeyInterface }>;
    constructor(inner: { ncryptsec: EncryptedSecretKeyInterface }) {
      super('Nip19Enum', 'EncryptedSecret');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      ncryptsec: EncryptedSecretKeyInterface;
    }): EncryptedSecret_ {
      return new EncryptedSecret_(inner);
    }

    static instanceOf(obj: any): obj is EncryptedSecret_ {
      return obj.tag === Nip19Enum_Tags.EncryptedSecret;
    }
  }

  type Pubkey__interface = {
    tag: Nip19Enum_Tags.Pubkey;
    inner: Readonly<{ npub: PublicKeyInterface }>;
  };

  /**
   * npub
   */
  class Pubkey_ extends UniffiEnum implements Pubkey__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip19Enum';
    readonly tag = Nip19Enum_Tags.Pubkey;
    readonly inner: Readonly<{ npub: PublicKeyInterface }>;
    constructor(inner: { npub: PublicKeyInterface }) {
      super('Nip19Enum', 'Pubkey');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { npub: PublicKeyInterface }): Pubkey_ {
      return new Pubkey_(inner);
    }

    static instanceOf(obj: any): obj is Pubkey_ {
      return obj.tag === Nip19Enum_Tags.Pubkey;
    }
  }

  type Profile__interface = {
    tag: Nip19Enum_Tags.Profile;
    inner: Readonly<{ nprofile: Nip19ProfileInterface }>;
  };

  /**
   * nprofile
   */
  class Profile_ extends UniffiEnum implements Profile__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip19Enum';
    readonly tag = Nip19Enum_Tags.Profile;
    readonly inner: Readonly<{ nprofile: Nip19ProfileInterface }>;
    constructor(inner: { nprofile: Nip19ProfileInterface }) {
      super('Nip19Enum', 'Profile');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { nprofile: Nip19ProfileInterface }): Profile_ {
      return new Profile_(inner);
    }

    static instanceOf(obj: any): obj is Profile_ {
      return obj.tag === Nip19Enum_Tags.Profile;
    }
  }

  type Note__interface = {
    tag: Nip19Enum_Tags.Note;
    inner: Readonly<{ eventId: EventIdInterface }>;
  };

  /**
   * note
   */
  class Note_ extends UniffiEnum implements Note__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip19Enum';
    readonly tag = Nip19Enum_Tags.Note;
    readonly inner: Readonly<{ eventId: EventIdInterface }>;
    constructor(inner: { eventId: EventIdInterface }) {
      super('Nip19Enum', 'Note');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventId: EventIdInterface }): Note_ {
      return new Note_(inner);
    }

    static instanceOf(obj: any): obj is Note_ {
      return obj.tag === Nip19Enum_Tags.Note;
    }
  }

  type Event__interface = {
    tag: Nip19Enum_Tags.Event;
    inner: Readonly<{ event: Nip19EventInterface }>;
  };

  /**
   * nevent
   */
  class Event_ extends UniffiEnum implements Event__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip19Enum';
    readonly tag = Nip19Enum_Tags.Event;
    readonly inner: Readonly<{ event: Nip19EventInterface }>;
    constructor(inner: { event: Nip19EventInterface }) {
      super('Nip19Enum', 'Event');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { event: Nip19EventInterface }): Event_ {
      return new Event_(inner);
    }

    static instanceOf(obj: any): obj is Event_ {
      return obj.tag === Nip19Enum_Tags.Event;
    }
  }

  type Addr__interface = {
    tag: Nip19Enum_Tags.Addr;
    inner: Readonly<{ coordinate: Nip19CoordinateInterface }>;
  };

  /**
   * naddr
   */
  class Addr_ extends UniffiEnum implements Addr__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip19Enum';
    readonly tag = Nip19Enum_Tags.Addr;
    readonly inner: Readonly<{ coordinate: Nip19CoordinateInterface }>;
    constructor(inner: { coordinate: Nip19CoordinateInterface }) {
      super('Nip19Enum', 'Addr');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { coordinate: Nip19CoordinateInterface }): Addr_ {
      return new Addr_(inner);
    }

    static instanceOf(obj: any): obj is Addr_ {
      return obj.tag === Nip19Enum_Tags.Addr;
    }
  }

  function instanceOf(obj: any): obj is Nip19Enum {
    return obj[uniffiTypeNameSymbol] === 'Nip19Enum';
  }

  return Object.freeze({
    instanceOf,
    Secret: Secret_,
    EncryptedSecret: EncryptedSecret_,
    Pubkey: Pubkey_,
    Profile: Profile_,
    Note: Note_,
    Event: Event_,
    Addr: Addr_,
  });
})();

/**
 * A representation any `NIP19` bech32 nostr object. Useful for decoding
 * `NIP19` bech32 strings without necessarily knowing what you're decoding
 * ahead of time.
 */

export type Nip19Enum = InstanceType<
  (typeof Nip19Enum)[keyof Omit<typeof Nip19Enum, 'instanceOf'>]
>;

// FfiConverter for enum Nip19Enum
const FfiConverterTypeNip19Enum = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Nip19Enum;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Nip19Enum.Secret({
            nsec: FfiConverterTypeSecretKey.read(from),
          });
        case 2:
          return new Nip19Enum.EncryptedSecret({
            ncryptsec: FfiConverterTypeEncryptedSecretKey.read(from),
          });
        case 3:
          return new Nip19Enum.Pubkey({
            npub: FfiConverterTypePublicKey.read(from),
          });
        case 4:
          return new Nip19Enum.Profile({
            nprofile: FfiConverterTypeNip19Profile.read(from),
          });
        case 5:
          return new Nip19Enum.Note({
            eventId: FfiConverterTypeEventId.read(from),
          });
        case 6:
          return new Nip19Enum.Event({
            event: FfiConverterTypeNip19Event.read(from),
          });
        case 7:
          return new Nip19Enum.Addr({
            coordinate: FfiConverterTypeNip19Coordinate.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Nip19Enum_Tags.Secret: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeSecretKey.write(inner.nsec, into);
          return;
        }
        case Nip19Enum_Tags.EncryptedSecret: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeEncryptedSecretKey.write(inner.ncryptsec, into);
          return;
        }
        case Nip19Enum_Tags.Pubkey: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypePublicKey.write(inner.npub, into);
          return;
        }
        case Nip19Enum_Tags.Profile: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeNip19Profile.write(inner.nprofile, into);
          return;
        }
        case Nip19Enum_Tags.Note: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterTypeEventId.write(inner.eventId, into);
          return;
        }
        case Nip19Enum_Tags.Event: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterTypeNip19Event.write(inner.event, into);
          return;
        }
        case Nip19Enum_Tags.Addr: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterTypeNip19Coordinate.write(inner.coordinate, into);
          return;
        }
        default:
          // Throwing from here means that Nip19Enum_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Nip19Enum_Tags.Secret: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeSecretKey.allocationSize(inner.nsec);
          return size;
        }
        case Nip19Enum_Tags.EncryptedSecret: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeEncryptedSecretKey.allocationSize(
            inner.ncryptsec
          );
          return size;
        }
        case Nip19Enum_Tags.Pubkey: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypePublicKey.allocationSize(inner.npub);
          return size;
        }
        case Nip19Enum_Tags.Profile: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeNip19Profile.allocationSize(inner.nprofile);
          return size;
        }
        case Nip19Enum_Tags.Note: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterTypeEventId.allocationSize(inner.eventId);
          return size;
        }
        case Nip19Enum_Tags.Event: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterTypeNip19Event.allocationSize(inner.event);
          return size;
        }
        case Nip19Enum_Tags.Addr: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterTypeNip19Coordinate.allocationSize(
            inner.coordinate
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: Nip21Enum
export enum Nip21Enum_Tags {
  Pubkey = 'Pubkey',
  Profile = 'Profile',
  Note = 'Note',
  Event = 'Event',
  Addr = 'Addr',
}
/**
 * A representation any `NIP21` object. Useful for decoding
 * `NIP21` strings without necessarily knowing what you're decoding
 * ahead of time.
 */
export const Nip21Enum = (() => {
  type Pubkey__interface = {
    tag: Nip21Enum_Tags.Pubkey;
    inner: Readonly<{ publicKey: PublicKeyInterface }>;
  };

  /**
   * nostr::npub
   */
  class Pubkey_ extends UniffiEnum implements Pubkey__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip21Enum';
    readonly tag = Nip21Enum_Tags.Pubkey;
    readonly inner: Readonly<{ publicKey: PublicKeyInterface }>;
    constructor(inner: { publicKey: PublicKeyInterface }) {
      super('Nip21Enum', 'Pubkey');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { publicKey: PublicKeyInterface }): Pubkey_ {
      return new Pubkey_(inner);
    }

    static instanceOf(obj: any): obj is Pubkey_ {
      return obj.tag === Nip21Enum_Tags.Pubkey;
    }
  }

  type Profile__interface = {
    tag: Nip21Enum_Tags.Profile;
    inner: Readonly<{ profile: Nip19ProfileInterface }>;
  };

  /**
   * nostr::nprofile
   */
  class Profile_ extends UniffiEnum implements Profile__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip21Enum';
    readonly tag = Nip21Enum_Tags.Profile;
    readonly inner: Readonly<{ profile: Nip19ProfileInterface }>;
    constructor(inner: { profile: Nip19ProfileInterface }) {
      super('Nip21Enum', 'Profile');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { profile: Nip19ProfileInterface }): Profile_ {
      return new Profile_(inner);
    }

    static instanceOf(obj: any): obj is Profile_ {
      return obj.tag === Nip21Enum_Tags.Profile;
    }
  }

  type Note__interface = {
    tag: Nip21Enum_Tags.Note;
    inner: Readonly<{ eventId: EventIdInterface }>;
  };

  /**
   * nostr::note (EventId)
   */
  class Note_ extends UniffiEnum implements Note__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip21Enum';
    readonly tag = Nip21Enum_Tags.Note;
    readonly inner: Readonly<{ eventId: EventIdInterface }>;
    constructor(inner: { eventId: EventIdInterface }) {
      super('Nip21Enum', 'Note');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { eventId: EventIdInterface }): Note_ {
      return new Note_(inner);
    }

    static instanceOf(obj: any): obj is Note_ {
      return obj.tag === Nip21Enum_Tags.Note;
    }
  }

  type Event__interface = {
    tag: Nip21Enum_Tags.Event;
    inner: Readonly<{ event: Nip19EventInterface }>;
  };

  /**
   * nostr::nevent
   */
  class Event_ extends UniffiEnum implements Event__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip21Enum';
    readonly tag = Nip21Enum_Tags.Event;
    readonly inner: Readonly<{ event: Nip19EventInterface }>;
    constructor(inner: { event: Nip19EventInterface }) {
      super('Nip21Enum', 'Event');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { event: Nip19EventInterface }): Event_ {
      return new Event_(inner);
    }

    static instanceOf(obj: any): obj is Event_ {
      return obj.tag === Nip21Enum_Tags.Event;
    }
  }

  type Addr__interface = {
    tag: Nip21Enum_Tags.Addr;
    inner: Readonly<{ coordinate: Nip19CoordinateInterface }>;
  };

  /**
   * nostr::naddr
   */
  class Addr_ extends UniffiEnum implements Addr__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip21Enum';
    readonly tag = Nip21Enum_Tags.Addr;
    readonly inner: Readonly<{ coordinate: Nip19CoordinateInterface }>;
    constructor(inner: { coordinate: Nip19CoordinateInterface }) {
      super('Nip21Enum', 'Addr');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { coordinate: Nip19CoordinateInterface }): Addr_ {
      return new Addr_(inner);
    }

    static instanceOf(obj: any): obj is Addr_ {
      return obj.tag === Nip21Enum_Tags.Addr;
    }
  }

  function instanceOf(obj: any): obj is Nip21Enum {
    return obj[uniffiTypeNameSymbol] === 'Nip21Enum';
  }

  return Object.freeze({
    instanceOf,
    Pubkey: Pubkey_,
    Profile: Profile_,
    Note: Note_,
    Event: Event_,
    Addr: Addr_,
  });
})();

/**
 * A representation any `NIP21` object. Useful for decoding
 * `NIP21` strings without necessarily knowing what you're decoding
 * ahead of time.
 */

export type Nip21Enum = InstanceType<
  (typeof Nip21Enum)[keyof Omit<typeof Nip21Enum, 'instanceOf'>]
>;

// FfiConverter for enum Nip21Enum
const FfiConverterTypeNip21Enum = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Nip21Enum;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Nip21Enum.Pubkey({
            publicKey: FfiConverterTypePublicKey.read(from),
          });
        case 2:
          return new Nip21Enum.Profile({
            profile: FfiConverterTypeNip19Profile.read(from),
          });
        case 3:
          return new Nip21Enum.Note({
            eventId: FfiConverterTypeEventId.read(from),
          });
        case 4:
          return new Nip21Enum.Event({
            event: FfiConverterTypeNip19Event.read(from),
          });
        case 5:
          return new Nip21Enum.Addr({
            coordinate: FfiConverterTypeNip19Coordinate.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Nip21Enum_Tags.Pubkey: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypePublicKey.write(inner.publicKey, into);
          return;
        }
        case Nip21Enum_Tags.Profile: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeNip19Profile.write(inner.profile, into);
          return;
        }
        case Nip21Enum_Tags.Note: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeEventId.write(inner.eventId, into);
          return;
        }
        case Nip21Enum_Tags.Event: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeNip19Event.write(inner.event, into);
          return;
        }
        case Nip21Enum_Tags.Addr: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterTypeNip19Coordinate.write(inner.coordinate, into);
          return;
        }
        default:
          // Throwing from here means that Nip21Enum_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Nip21Enum_Tags.Pubkey: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypePublicKey.allocationSize(inner.publicKey);
          return size;
        }
        case Nip21Enum_Tags.Profile: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeNip19Profile.allocationSize(inner.profile);
          return size;
        }
        case Nip21Enum_Tags.Note: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeEventId.allocationSize(inner.eventId);
          return size;
        }
        case Nip21Enum_Tags.Event: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeNip19Event.allocationSize(inner.event);
          return size;
        }
        case Nip21Enum_Tags.Addr: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterTypeNip19Coordinate.allocationSize(
            inner.coordinate
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * NIP44 Version
 */
export enum Nip44Version {
  /**
   * V2 - Secp256k1 ECDH, HKDF, padding, ChaCha20, HMAC-SHA256 and base64
   */
  V2,
}

const FfiConverterTypeNip44Version = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Nip44Version;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return Nip44Version.V2;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case Nip44Version.V2:
          return ordinalConverter.write(1, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: Nip46Request
export enum Nip46Request_Tags {
  Connect = 'Connect',
  GetPublicKey = 'GetPublicKey',
  SignEvent = 'SignEvent',
  GetRelays = 'GetRelays',
  Nip04Encrypt = 'Nip04Encrypt',
  Nip04Decrypt = 'Nip04Decrypt',
  Nip44Encrypt = 'Nip44Encrypt',
  Nip44Decrypt = 'Nip44Decrypt',
  Ping = 'Ping',
}
/**
 * Request (NIP46)
 */
export const Nip46Request = (() => {
  type Connect__interface = {
    tag: Nip46Request_Tags.Connect;
    inner: Readonly<{
      publicKey: PublicKeyInterface;
      secret: string | undefined;
    }>;
  };

  /**
   * Connect
   */
  class Connect_ extends UniffiEnum implements Connect__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip46Request';
    readonly tag = Nip46Request_Tags.Connect;
    readonly inner: Readonly<{
      publicKey: PublicKeyInterface;
      secret: string | undefined;
    }>;
    constructor(inner: {
      /**
       * Remote public key
       */ publicKey: PublicKeyInterface;
      /**
       * Optional secret
       */ secret: string | undefined;
    }) {
      super('Nip46Request', 'Connect');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Remote public key
       */ publicKey: PublicKeyInterface;
      /**
       * Optional secret
       */ secret: string | undefined;
    }): Connect_ {
      return new Connect_(inner);
    }

    static instanceOf(obj: any): obj is Connect_ {
      return obj.tag === Nip46Request_Tags.Connect;
    }
  }

  type GetPublicKey__interface = {
    tag: Nip46Request_Tags.GetPublicKey;
  };

  /**
   * Get public key
   */
  class GetPublicKey_ extends UniffiEnum implements GetPublicKey__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip46Request';
    readonly tag = Nip46Request_Tags.GetPublicKey;
    constructor() {
      super('Nip46Request', 'GetPublicKey');
    }

    static new(): GetPublicKey_ {
      return new GetPublicKey_();
    }

    static instanceOf(obj: any): obj is GetPublicKey_ {
      return obj.tag === Nip46Request_Tags.GetPublicKey;
    }
  }

  type SignEvent__interface = {
    tag: Nip46Request_Tags.SignEvent;
    inner: Readonly<{ unsignedEvent: UnsignedEventInterface }>;
  };

  /**
   * Sign [`UnsignedEvent`]
   */
  class SignEvent_ extends UniffiEnum implements SignEvent__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip46Request';
    readonly tag = Nip46Request_Tags.SignEvent;
    readonly inner: Readonly<{ unsignedEvent: UnsignedEventInterface }>;
    constructor(inner: { unsignedEvent: UnsignedEventInterface }) {
      super('Nip46Request', 'SignEvent');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { unsignedEvent: UnsignedEventInterface }): SignEvent_ {
      return new SignEvent_(inner);
    }

    static instanceOf(obj: any): obj is SignEvent_ {
      return obj.tag === Nip46Request_Tags.SignEvent;
    }
  }

  type GetRelays__interface = {
    tag: Nip46Request_Tags.GetRelays;
  };

  /**
   * Get relays
   */
  class GetRelays_ extends UniffiEnum implements GetRelays__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip46Request';
    readonly tag = Nip46Request_Tags.GetRelays;
    constructor() {
      super('Nip46Request', 'GetRelays');
    }

    static new(): GetRelays_ {
      return new GetRelays_();
    }

    static instanceOf(obj: any): obj is GetRelays_ {
      return obj.tag === Nip46Request_Tags.GetRelays;
    }
  }

  type Nip04Encrypt__interface = {
    tag: Nip46Request_Tags.Nip04Encrypt;
    inner: Readonly<{ publicKey: PublicKeyInterface; text: string }>;
  };

  /**
   * Encrypt text (NIP04)
   */
  class Nip04Encrypt_ extends UniffiEnum implements Nip04Encrypt__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip46Request';
    readonly tag = Nip46Request_Tags.Nip04Encrypt;
    readonly inner: Readonly<{ publicKey: PublicKeyInterface; text: string }>;
    constructor(inner: {
      /**
       * Pubkey
       */ publicKey: PublicKeyInterface;
      /**
       * Plain text
       */ text: string;
    }) {
      super('Nip46Request', 'Nip04Encrypt');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Pubkey
       */ publicKey: PublicKeyInterface;
      /**
       * Plain text
       */ text: string;
    }): Nip04Encrypt_ {
      return new Nip04Encrypt_(inner);
    }

    static instanceOf(obj: any): obj is Nip04Encrypt_ {
      return obj.tag === Nip46Request_Tags.Nip04Encrypt;
    }
  }

  type Nip04Decrypt__interface = {
    tag: Nip46Request_Tags.Nip04Decrypt;
    inner: Readonly<{ publicKey: PublicKeyInterface; ciphertext: string }>;
  };

  /**
   * Decrypt (NIP04)
   */
  class Nip04Decrypt_ extends UniffiEnum implements Nip04Decrypt__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip46Request';
    readonly tag = Nip46Request_Tags.Nip04Decrypt;
    readonly inner: Readonly<{
      publicKey: PublicKeyInterface;
      ciphertext: string;
    }>;
    constructor(inner: {
      /**
       * Pubkey
       */ publicKey: PublicKeyInterface;
      /**
       * Ciphertext
       */ ciphertext: string;
    }) {
      super('Nip46Request', 'Nip04Decrypt');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Pubkey
       */ publicKey: PublicKeyInterface;
      /**
       * Ciphertext
       */ ciphertext: string;
    }): Nip04Decrypt_ {
      return new Nip04Decrypt_(inner);
    }

    static instanceOf(obj: any): obj is Nip04Decrypt_ {
      return obj.tag === Nip46Request_Tags.Nip04Decrypt;
    }
  }

  type Nip44Encrypt__interface = {
    tag: Nip46Request_Tags.Nip44Encrypt;
    inner: Readonly<{ publicKey: PublicKeyInterface; text: string }>;
  };

  /**
   * Encrypt text (NIP44)
   */
  class Nip44Encrypt_ extends UniffiEnum implements Nip44Encrypt__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip46Request';
    readonly tag = Nip46Request_Tags.Nip44Encrypt;
    readonly inner: Readonly<{ publicKey: PublicKeyInterface; text: string }>;
    constructor(inner: {
      /**
       * Pubkey
       */ publicKey: PublicKeyInterface;
      /**
       * Plain text
       */ text: string;
    }) {
      super('Nip46Request', 'Nip44Encrypt');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Pubkey
       */ publicKey: PublicKeyInterface;
      /**
       * Plain text
       */ text: string;
    }): Nip44Encrypt_ {
      return new Nip44Encrypt_(inner);
    }

    static instanceOf(obj: any): obj is Nip44Encrypt_ {
      return obj.tag === Nip46Request_Tags.Nip44Encrypt;
    }
  }

  type Nip44Decrypt__interface = {
    tag: Nip46Request_Tags.Nip44Decrypt;
    inner: Readonly<{ publicKey: PublicKeyInterface; ciphertext: string }>;
  };

  /**
   * Decrypt (NIP44)
   */
  class Nip44Decrypt_ extends UniffiEnum implements Nip44Decrypt__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip46Request';
    readonly tag = Nip46Request_Tags.Nip44Decrypt;
    readonly inner: Readonly<{
      publicKey: PublicKeyInterface;
      ciphertext: string;
    }>;
    constructor(inner: {
      /**
       * Pubkey
       */ publicKey: PublicKeyInterface;
      /**
       * Ciphertext
       */ ciphertext: string;
    }) {
      super('Nip46Request', 'Nip44Decrypt');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Pubkey
       */ publicKey: PublicKeyInterface;
      /**
       * Ciphertext
       */ ciphertext: string;
    }): Nip44Decrypt_ {
      return new Nip44Decrypt_(inner);
    }

    static instanceOf(obj: any): obj is Nip44Decrypt_ {
      return obj.tag === Nip46Request_Tags.Nip44Decrypt;
    }
  }

  type Ping__interface = {
    tag: Nip46Request_Tags.Ping;
  };

  /**
   * Ping
   */
  class Ping_ extends UniffiEnum implements Ping__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Nip46Request';
    readonly tag = Nip46Request_Tags.Ping;
    constructor() {
      super('Nip46Request', 'Ping');
    }

    static new(): Ping_ {
      return new Ping_();
    }

    static instanceOf(obj: any): obj is Ping_ {
      return obj.tag === Nip46Request_Tags.Ping;
    }
  }

  function instanceOf(obj: any): obj is Nip46Request {
    return obj[uniffiTypeNameSymbol] === 'Nip46Request';
  }

  return Object.freeze({
    instanceOf,
    Connect: Connect_,
    GetPublicKey: GetPublicKey_,
    SignEvent: SignEvent_,
    GetRelays: GetRelays_,
    Nip04Encrypt: Nip04Encrypt_,
    Nip04Decrypt: Nip04Decrypt_,
    Nip44Encrypt: Nip44Encrypt_,
    Nip44Decrypt: Nip44Decrypt_,
    Ping: Ping_,
  });
})();

/**
 * Request (NIP46)
 */

export type Nip46Request = InstanceType<
  (typeof Nip46Request)[keyof Omit<typeof Nip46Request, 'instanceOf'>]
>;

// FfiConverter for enum Nip46Request
const FfiConverterTypeNip46Request = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Nip46Request;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Nip46Request.Connect({
            publicKey: FfiConverterTypePublicKey.read(from),
            secret: FfiConverterOptionalString.read(from),
          });
        case 2:
          return new Nip46Request.GetPublicKey();
        case 3:
          return new Nip46Request.SignEvent({
            unsignedEvent: FfiConverterTypeUnsignedEvent.read(from),
          });
        case 4:
          return new Nip46Request.GetRelays();
        case 5:
          return new Nip46Request.Nip04Encrypt({
            publicKey: FfiConverterTypePublicKey.read(from),
            text: FfiConverterString.read(from),
          });
        case 6:
          return new Nip46Request.Nip04Decrypt({
            publicKey: FfiConverterTypePublicKey.read(from),
            ciphertext: FfiConverterString.read(from),
          });
        case 7:
          return new Nip46Request.Nip44Encrypt({
            publicKey: FfiConverterTypePublicKey.read(from),
            text: FfiConverterString.read(from),
          });
        case 8:
          return new Nip46Request.Nip44Decrypt({
            publicKey: FfiConverterTypePublicKey.read(from),
            ciphertext: FfiConverterString.read(from),
          });
        case 9:
          return new Nip46Request.Ping();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Nip46Request_Tags.Connect: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypePublicKey.write(inner.publicKey, into);
          FfiConverterOptionalString.write(inner.secret, into);
          return;
        }
        case Nip46Request_Tags.GetPublicKey: {
          ordinalConverter.write(2, into);
          return;
        }
        case Nip46Request_Tags.SignEvent: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeUnsignedEvent.write(inner.unsignedEvent, into);
          return;
        }
        case Nip46Request_Tags.GetRelays: {
          ordinalConverter.write(4, into);
          return;
        }
        case Nip46Request_Tags.Nip04Encrypt: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterTypePublicKey.write(inner.publicKey, into);
          FfiConverterString.write(inner.text, into);
          return;
        }
        case Nip46Request_Tags.Nip04Decrypt: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterTypePublicKey.write(inner.publicKey, into);
          FfiConverterString.write(inner.ciphertext, into);
          return;
        }
        case Nip46Request_Tags.Nip44Encrypt: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterTypePublicKey.write(inner.publicKey, into);
          FfiConverterString.write(inner.text, into);
          return;
        }
        case Nip46Request_Tags.Nip44Decrypt: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterTypePublicKey.write(inner.publicKey, into);
          FfiConverterString.write(inner.ciphertext, into);
          return;
        }
        case Nip46Request_Tags.Ping: {
          ordinalConverter.write(9, into);
          return;
        }
        default:
          // Throwing from here means that Nip46Request_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Nip46Request_Tags.Connect: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypePublicKey.allocationSize(inner.publicKey);
          size += FfiConverterOptionalString.allocationSize(inner.secret);
          return size;
        }
        case Nip46Request_Tags.GetPublicKey: {
          return ordinalConverter.allocationSize(2);
        }
        case Nip46Request_Tags.SignEvent: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeUnsignedEvent.allocationSize(
            inner.unsignedEvent
          );
          return size;
        }
        case Nip46Request_Tags.GetRelays: {
          return ordinalConverter.allocationSize(4);
        }
        case Nip46Request_Tags.Nip04Encrypt: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterTypePublicKey.allocationSize(inner.publicKey);
          size += FfiConverterString.allocationSize(inner.text);
          return size;
        }
        case Nip46Request_Tags.Nip04Decrypt: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterTypePublicKey.allocationSize(inner.publicKey);
          size += FfiConverterString.allocationSize(inner.ciphertext);
          return size;
        }
        case Nip46Request_Tags.Nip44Encrypt: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterTypePublicKey.allocationSize(inner.publicKey);
          size += FfiConverterString.allocationSize(inner.text);
          return size;
        }
        case Nip46Request_Tags.Nip44Decrypt: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterTypePublicKey.allocationSize(inner.publicKey);
          size += FfiConverterString.allocationSize(inner.ciphertext);
          return size;
        }
        case Nip46Request_Tags.Ping: {
          return ordinalConverter.allocationSize(9);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: NostrConnectMessage
export enum NostrConnectMessage_Tags {
  Request = 'Request',
  Response = 'Response',
}
export const NostrConnectMessage = (() => {
  type Request__interface = {
    tag: NostrConnectMessage_Tags.Request;
    inner: Readonly<{ id: string; method: string; params: Array<string> }>;
  };

  class Request_ extends UniffiEnum implements Request__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NostrConnectMessage';
    readonly tag = NostrConnectMessage_Tags.Request;
    readonly inner: Readonly<{
      id: string;
      method: string;
      params: Array<string>;
    }>;
    constructor(inner: { id: string; method: string; params: Array<string> }) {
      super('NostrConnectMessage', 'Request');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      id: string;
      method: string;
      params: Array<string>;
    }): Request_ {
      return new Request_(inner);
    }

    static instanceOf(obj: any): obj is Request_ {
      return obj.tag === NostrConnectMessage_Tags.Request;
    }
  }

  type Response__interface = {
    tag: NostrConnectMessage_Tags.Response;
    inner: Readonly<{
      id: string;
      result: string | undefined;
      error: string | undefined;
    }>;
  };

  class Response_ extends UniffiEnum implements Response__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'NostrConnectMessage';
    readonly tag = NostrConnectMessage_Tags.Response;
    readonly inner: Readonly<{
      id: string;
      result: string | undefined;
      error: string | undefined;
    }>;
    constructor(inner: {
      id: string;
      result: string | undefined;
      error: string | undefined;
    }) {
      super('NostrConnectMessage', 'Response');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      id: string;
      result: string | undefined;
      error: string | undefined;
    }): Response_ {
      return new Response_(inner);
    }

    static instanceOf(obj: any): obj is Response_ {
      return obj.tag === NostrConnectMessage_Tags.Response;
    }
  }

  function instanceOf(obj: any): obj is NostrConnectMessage {
    return obj[uniffiTypeNameSymbol] === 'NostrConnectMessage';
  }

  return Object.freeze({
    instanceOf,
    Request: Request_,
    Response: Response_,
  });
})();

export type NostrConnectMessage = InstanceType<
  (typeof NostrConnectMessage)[keyof Omit<
    typeof NostrConnectMessage,
    'instanceOf'
  >]
>;

// FfiConverter for enum NostrConnectMessage
const FfiConverterTypeNostrConnectMessage = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = NostrConnectMessage;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new NostrConnectMessage.Request({
            id: FfiConverterString.read(from),
            method: FfiConverterString.read(from),
            params: FfiConverterArrayString.read(from),
          });
        case 2:
          return new NostrConnectMessage.Response({
            id: FfiConverterString.read(from),
            result: FfiConverterOptionalString.read(from),
            error: FfiConverterOptionalString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case NostrConnectMessage_Tags.Request: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.id, into);
          FfiConverterString.write(inner.method, into);
          FfiConverterArrayString.write(inner.params, into);
          return;
        }
        case NostrConnectMessage_Tags.Response: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.id, into);
          FfiConverterOptionalString.write(inner.result, into);
          FfiConverterOptionalString.write(inner.error, into);
          return;
        }
        default:
          // Throwing from here means that NostrConnectMessage_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case NostrConnectMessage_Tags.Request: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.id);
          size += FfiConverterString.allocationSize(inner.method);
          size += FfiConverterArrayString.allocationSize(inner.params);
          return size;
        }
        case NostrConnectMessage_Tags.Response: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.id);
          size += FfiConverterOptionalString.allocationSize(inner.result);
          size += FfiConverterOptionalString.allocationSize(inner.error);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Flat error type: NostrSdkError
export enum NostrSdkError_Tags {
  Generic = 'Generic',
}
export const NostrSdkError = (() => {
  class Generic extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'NostrSdkError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = NostrSdkError_Tags.Generic;

    constructor(message: string) {
      super('NostrSdkError', 'Generic', message);
    }

    static instanceOf(e: any): e is Generic {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is NostrSdkError {
    return (e as any)[uniffiTypeNameSymbol] === 'NostrSdkError';
  }
  return {
    Generic,
    instanceOf,
  };
})();

// Union type for NostrSdkError error type.

export type NostrSdkError = InstanceType<
  (typeof NostrSdkError)[keyof Omit<typeof NostrSdkError, 'instanceOf'>]
>;

const FfiConverterTypeNostrSdkError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = NostrSdkError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new NostrSdkError.Generic(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Enum: Protocol
export enum Protocol_Tags {
  ActivityPub = 'ActivityPub',
  AtProto = 'ATProto',
  Rss = 'Rss',
  Web = 'Web',
  Custom = 'Custom',
}
/**
 * NIP48 Proxy Protocol
 */
export const Protocol = (() => {
  type ActivityPub__interface = {
    tag: Protocol_Tags.ActivityPub;
  };

  /**
   * ActivityPub
   */
  class ActivityPub_ extends UniffiEnum implements ActivityPub__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Protocol';
    readonly tag = Protocol_Tags.ActivityPub;
    constructor() {
      super('Protocol', 'ActivityPub');
    }

    static new(): ActivityPub_ {
      return new ActivityPub_();
    }

    static instanceOf(obj: any): obj is ActivityPub_ {
      return obj.tag === Protocol_Tags.ActivityPub;
    }
  }

  type AtProto__interface = {
    tag: Protocol_Tags.AtProto;
  };

  /**
   * AT Protocol
   */
  class AtProto_ extends UniffiEnum implements AtProto__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Protocol';
    readonly tag = Protocol_Tags.AtProto;
    constructor() {
      super('Protocol', 'AtProto');
    }

    static new(): AtProto_ {
      return new AtProto_();
    }

    static instanceOf(obj: any): obj is AtProto_ {
      return obj.tag === Protocol_Tags.AtProto;
    }
  }

  type Rss__interface = {
    tag: Protocol_Tags.Rss;
  };

  /**
   * Rss
   */
  class Rss_ extends UniffiEnum implements Rss__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Protocol';
    readonly tag = Protocol_Tags.Rss;
    constructor() {
      super('Protocol', 'Rss');
    }

    static new(): Rss_ {
      return new Rss_();
    }

    static instanceOf(obj: any): obj is Rss_ {
      return obj.tag === Protocol_Tags.Rss;
    }
  }

  type Web__interface = {
    tag: Protocol_Tags.Web;
  };

  /**
   * Web
   */
  class Web_ extends UniffiEnum implements Web__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Protocol';
    readonly tag = Protocol_Tags.Web;
    constructor() {
      super('Protocol', 'Web');
    }

    static new(): Web_ {
      return new Web_();
    }

    static instanceOf(obj: any): obj is Web_ {
      return obj.tag === Protocol_Tags.Web;
    }
  }

  type Custom__interface = {
    tag: Protocol_Tags.Custom;
    inner: Readonly<{ custom: string }>;
  };

  /**
   * Custom
   */
  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Protocol';
    readonly tag = Protocol_Tags.Custom;
    readonly inner: Readonly<{ custom: string }>;
    constructor(inner: { custom: string }) {
      super('Protocol', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { custom: string }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === Protocol_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is Protocol {
    return obj[uniffiTypeNameSymbol] === 'Protocol';
  }

  return Object.freeze({
    instanceOf,
    ActivityPub: ActivityPub_,
    AtProto: AtProto_,
    Rss: Rss_,
    Web: Web_,
    Custom: Custom_,
  });
})();

/**
 * NIP48 Proxy Protocol
 */

export type Protocol = InstanceType<
  (typeof Protocol)[keyof Omit<typeof Protocol, 'instanceOf'>]
>;

// FfiConverter for enum Protocol
const FfiConverterTypeProtocol = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Protocol;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Protocol.ActivityPub();
        case 2:
          return new Protocol.AtProto();
        case 3:
          return new Protocol.Rss();
        case 4:
          return new Protocol.Web();
        case 5:
          return new Protocol.Custom({ custom: FfiConverterString.read(from) });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Protocol_Tags.ActivityPub: {
          ordinalConverter.write(1, into);
          return;
        }
        case Protocol_Tags.AtProto: {
          ordinalConverter.write(2, into);
          return;
        }
        case Protocol_Tags.Rss: {
          ordinalConverter.write(3, into);
          return;
        }
        case Protocol_Tags.Web: {
          ordinalConverter.write(4, into);
          return;
        }
        case Protocol_Tags.Custom: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.custom, into);
          return;
        }
        default:
          // Throwing from here means that Protocol_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Protocol_Tags.ActivityPub: {
          return ordinalConverter.allocationSize(1);
        }
        case Protocol_Tags.AtProto: {
          return ordinalConverter.allocationSize(2);
        }
        case Protocol_Tags.Rss: {
          return ordinalConverter.allocationSize(3);
        }
        case Protocol_Tags.Web: {
          return ordinalConverter.allocationSize(4);
        }
        case Protocol_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.custom);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * Reason why event wasn't stored into the database
 */
export enum RejectedReason {
  /**
   * Ephemeral events aren't expected to be stored
   */
  Ephemeral,
  /**
   * The event already exists
   */
  Duplicate,
  /**
   * The event was deleted
   */
  Deleted,
  /**
   * The event is expired
   */
  Expired,
  /**
   * The event was replaced
   */
  Replaced,
  /**
   * Attempt to delete a non-owned event
   */
  InvalidDelete,
  /**
   * Other reason
   */
  Other,
}

const FfiConverterTypeRejectedReason = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RejectedReason;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RejectedReason.Ephemeral;
        case 2:
          return RejectedReason.Duplicate;
        case 3:
          return RejectedReason.Deleted;
        case 4:
          return RejectedReason.Expired;
        case 5:
          return RejectedReason.Replaced;
        case 6:
          return RejectedReason.InvalidDelete;
        case 7:
          return RejectedReason.Other;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RejectedReason.Ephemeral:
          return ordinalConverter.write(1, into);
        case RejectedReason.Duplicate:
          return ordinalConverter.write(2, into);
        case RejectedReason.Deleted:
          return ordinalConverter.write(3, into);
        case RejectedReason.Expired:
          return ordinalConverter.write(4, into);
        case RejectedReason.Replaced:
          return ordinalConverter.write(5, into);
        case RejectedReason.InvalidDelete:
          return ordinalConverter.write(6, into);
        case RejectedReason.Other:
          return ordinalConverter.write(7, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: RelayMessageEnum
export enum RelayMessageEnum_Tags {
  EventMsg = 'EventMsg',
  Ok = 'Ok',
  EndOfStoredEvents = 'EndOfStoredEvents',
  Notice = 'Notice',
  Closed = 'Closed',
  Auth = 'Auth',
  Count = 'Count',
  NegMsg = 'NegMsg',
  NegErr = 'NegErr',
}
export const RelayMessageEnum = (() => {
  type EventMsg__interface = {
    tag: RelayMessageEnum_Tags.EventMsg;
    inner: Readonly<{ subscriptionId: string; event: EventInterface }>;
  };

  class EventMsg_ extends UniffiEnum implements EventMsg__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RelayMessageEnum';
    readonly tag = RelayMessageEnum_Tags.EventMsg;
    readonly inner: Readonly<{ subscriptionId: string; event: EventInterface }>;
    constructor(inner: { subscriptionId: string; event: EventInterface }) {
      super('RelayMessageEnum', 'EventMsg');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      subscriptionId: string;
      event: EventInterface;
    }): EventMsg_ {
      return new EventMsg_(inner);
    }

    static instanceOf(obj: any): obj is EventMsg_ {
      return obj.tag === RelayMessageEnum_Tags.EventMsg;
    }
  }

  type Ok__interface = {
    tag: RelayMessageEnum_Tags.Ok;
    inner: Readonly<{
      eventId: EventIdInterface;
      status: boolean;
      message: string;
    }>;
  };

  class Ok_ extends UniffiEnum implements Ok__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RelayMessageEnum';
    readonly tag = RelayMessageEnum_Tags.Ok;
    readonly inner: Readonly<{
      eventId: EventIdInterface;
      status: boolean;
      message: string;
    }>;
    constructor(inner: {
      eventId: EventIdInterface;
      status: boolean;
      message: string;
    }) {
      super('RelayMessageEnum', 'Ok');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      eventId: EventIdInterface;
      status: boolean;
      message: string;
    }): Ok_ {
      return new Ok_(inner);
    }

    static instanceOf(obj: any): obj is Ok_ {
      return obj.tag === RelayMessageEnum_Tags.Ok;
    }
  }

  type EndOfStoredEvents__interface = {
    tag: RelayMessageEnum_Tags.EndOfStoredEvents;
    inner: Readonly<{ subscriptionId: string }>;
  };

  class EndOfStoredEvents_
    extends UniffiEnum
    implements EndOfStoredEvents__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RelayMessageEnum';
    readonly tag = RelayMessageEnum_Tags.EndOfStoredEvents;
    readonly inner: Readonly<{ subscriptionId: string }>;
    constructor(inner: { subscriptionId: string }) {
      super('RelayMessageEnum', 'EndOfStoredEvents');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { subscriptionId: string }): EndOfStoredEvents_ {
      return new EndOfStoredEvents_(inner);
    }

    static instanceOf(obj: any): obj is EndOfStoredEvents_ {
      return obj.tag === RelayMessageEnum_Tags.EndOfStoredEvents;
    }
  }

  type Notice__interface = {
    tag: RelayMessageEnum_Tags.Notice;
    inner: Readonly<{ message: string }>;
  };

  class Notice_ extends UniffiEnum implements Notice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RelayMessageEnum';
    readonly tag = RelayMessageEnum_Tags.Notice;
    readonly inner: Readonly<{ message: string }>;
    constructor(inner: { message: string }) {
      super('RelayMessageEnum', 'Notice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { message: string }): Notice_ {
      return new Notice_(inner);
    }

    static instanceOf(obj: any): obj is Notice_ {
      return obj.tag === RelayMessageEnum_Tags.Notice;
    }
  }

  type Closed__interface = {
    tag: RelayMessageEnum_Tags.Closed;
    inner: Readonly<{ subscriptionId: string; message: string }>;
  };

  class Closed_ extends UniffiEnum implements Closed__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RelayMessageEnum';
    readonly tag = RelayMessageEnum_Tags.Closed;
    readonly inner: Readonly<{ subscriptionId: string; message: string }>;
    constructor(inner: { subscriptionId: string; message: string }) {
      super('RelayMessageEnum', 'Closed');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { subscriptionId: string; message: string }): Closed_ {
      return new Closed_(inner);
    }

    static instanceOf(obj: any): obj is Closed_ {
      return obj.tag === RelayMessageEnum_Tags.Closed;
    }
  }

  type Auth__interface = {
    tag: RelayMessageEnum_Tags.Auth;
    inner: Readonly<{ challenge: string }>;
  };

  class Auth_ extends UniffiEnum implements Auth__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RelayMessageEnum';
    readonly tag = RelayMessageEnum_Tags.Auth;
    readonly inner: Readonly<{ challenge: string }>;
    constructor(inner: { challenge: string }) {
      super('RelayMessageEnum', 'Auth');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { challenge: string }): Auth_ {
      return new Auth_(inner);
    }

    static instanceOf(obj: any): obj is Auth_ {
      return obj.tag === RelayMessageEnum_Tags.Auth;
    }
  }

  type Count__interface = {
    tag: RelayMessageEnum_Tags.Count;
    inner: Readonly<{ subscriptionId: string; count: /*u64*/ bigint }>;
  };

  class Count_ extends UniffiEnum implements Count__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RelayMessageEnum';
    readonly tag = RelayMessageEnum_Tags.Count;
    readonly inner: Readonly<{ subscriptionId: string; count: /*u64*/ bigint }>;
    constructor(inner: { subscriptionId: string; count: /*u64*/ bigint }) {
      super('RelayMessageEnum', 'Count');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      subscriptionId: string;
      count: /*u64*/ bigint;
    }): Count_ {
      return new Count_(inner);
    }

    static instanceOf(obj: any): obj is Count_ {
      return obj.tag === RelayMessageEnum_Tags.Count;
    }
  }

  type NegMsg__interface = {
    tag: RelayMessageEnum_Tags.NegMsg;
    inner: Readonly<{ subscriptionId: string; message: string }>;
  };

  class NegMsg_ extends UniffiEnum implements NegMsg__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RelayMessageEnum';
    readonly tag = RelayMessageEnum_Tags.NegMsg;
    readonly inner: Readonly<{ subscriptionId: string; message: string }>;
    constructor(inner: { subscriptionId: string; message: string }) {
      super('RelayMessageEnum', 'NegMsg');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { subscriptionId: string; message: string }): NegMsg_ {
      return new NegMsg_(inner);
    }

    static instanceOf(obj: any): obj is NegMsg_ {
      return obj.tag === RelayMessageEnum_Tags.NegMsg;
    }
  }

  type NegErr__interface = {
    tag: RelayMessageEnum_Tags.NegErr;
    inner: Readonly<{ subscriptionId: string; message: string }>;
  };

  class NegErr_ extends UniffiEnum implements NegErr__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RelayMessageEnum';
    readonly tag = RelayMessageEnum_Tags.NegErr;
    readonly inner: Readonly<{ subscriptionId: string; message: string }>;
    constructor(inner: { subscriptionId: string; message: string }) {
      super('RelayMessageEnum', 'NegErr');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { subscriptionId: string; message: string }): NegErr_ {
      return new NegErr_(inner);
    }

    static instanceOf(obj: any): obj is NegErr_ {
      return obj.tag === RelayMessageEnum_Tags.NegErr;
    }
  }

  function instanceOf(obj: any): obj is RelayMessageEnum {
    return obj[uniffiTypeNameSymbol] === 'RelayMessageEnum';
  }

  return Object.freeze({
    instanceOf,
    EventMsg: EventMsg_,
    Ok: Ok_,
    EndOfStoredEvents: EndOfStoredEvents_,
    Notice: Notice_,
    Closed: Closed_,
    Auth: Auth_,
    Count: Count_,
    NegMsg: NegMsg_,
    NegErr: NegErr_,
  });
})();

export type RelayMessageEnum = InstanceType<
  (typeof RelayMessageEnum)[keyof Omit<typeof RelayMessageEnum, 'instanceOf'>]
>;

// FfiConverter for enum RelayMessageEnum
const FfiConverterTypeRelayMessageEnum = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RelayMessageEnum;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RelayMessageEnum.EventMsg({
            subscriptionId: FfiConverterString.read(from),
            event: FfiConverterTypeEvent.read(from),
          });
        case 2:
          return new RelayMessageEnum.Ok({
            eventId: FfiConverterTypeEventId.read(from),
            status: FfiConverterBool.read(from),
            message: FfiConverterString.read(from),
          });
        case 3:
          return new RelayMessageEnum.EndOfStoredEvents({
            subscriptionId: FfiConverterString.read(from),
          });
        case 4:
          return new RelayMessageEnum.Notice({
            message: FfiConverterString.read(from),
          });
        case 5:
          return new RelayMessageEnum.Closed({
            subscriptionId: FfiConverterString.read(from),
            message: FfiConverterString.read(from),
          });
        case 6:
          return new RelayMessageEnum.Auth({
            challenge: FfiConverterString.read(from),
          });
        case 7:
          return new RelayMessageEnum.Count({
            subscriptionId: FfiConverterString.read(from),
            count: FfiConverterUInt64.read(from),
          });
        case 8:
          return new RelayMessageEnum.NegMsg({
            subscriptionId: FfiConverterString.read(from),
            message: FfiConverterString.read(from),
          });
        case 9:
          return new RelayMessageEnum.NegErr({
            subscriptionId: FfiConverterString.read(from),
            message: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RelayMessageEnum_Tags.EventMsg: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.subscriptionId, into);
          FfiConverterTypeEvent.write(inner.event, into);
          return;
        }
        case RelayMessageEnum_Tags.Ok: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeEventId.write(inner.eventId, into);
          FfiConverterBool.write(inner.status, into);
          FfiConverterString.write(inner.message, into);
          return;
        }
        case RelayMessageEnum_Tags.EndOfStoredEvents: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.subscriptionId, into);
          return;
        }
        case RelayMessageEnum_Tags.Notice: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.message, into);
          return;
        }
        case RelayMessageEnum_Tags.Closed: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.subscriptionId, into);
          FfiConverterString.write(inner.message, into);
          return;
        }
        case RelayMessageEnum_Tags.Auth: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.challenge, into);
          return;
        }
        case RelayMessageEnum_Tags.Count: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterString.write(inner.subscriptionId, into);
          FfiConverterUInt64.write(inner.count, into);
          return;
        }
        case RelayMessageEnum_Tags.NegMsg: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterString.write(inner.subscriptionId, into);
          FfiConverterString.write(inner.message, into);
          return;
        }
        case RelayMessageEnum_Tags.NegErr: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterString.write(inner.subscriptionId, into);
          FfiConverterString.write(inner.message, into);
          return;
        }
        default:
          // Throwing from here means that RelayMessageEnum_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RelayMessageEnum_Tags.EventMsg: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.subscriptionId);
          size += FfiConverterTypeEvent.allocationSize(inner.event);
          return size;
        }
        case RelayMessageEnum_Tags.Ok: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeEventId.allocationSize(inner.eventId);
          size += FfiConverterBool.allocationSize(inner.status);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        case RelayMessageEnum_Tags.EndOfStoredEvents: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.subscriptionId);
          return size;
        }
        case RelayMessageEnum_Tags.Notice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        case RelayMessageEnum_Tags.Closed: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.subscriptionId);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        case RelayMessageEnum_Tags.Auth: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.challenge);
          return size;
        }
        case RelayMessageEnum_Tags.Count: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterString.allocationSize(inner.subscriptionId);
          size += FfiConverterUInt64.allocationSize(inner.count);
          return size;
        }
        case RelayMessageEnum_Tags.NegMsg: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterString.allocationSize(inner.subscriptionId);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        case RelayMessageEnum_Tags.NegErr: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterString.allocationSize(inner.subscriptionId);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum RelayMetadata {
  /**
   * Read
   */
  Read,
  /**
   * Write
   */
  Write,
}

const FfiConverterTypeRelayMetadata = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RelayMetadata;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RelayMetadata.Read;
        case 2:
          return RelayMetadata.Write;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RelayMetadata.Read:
          return ordinalConverter.write(1, into);
        case RelayMetadata.Write:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum RelayStatus {
  /**
   * Initialized
   */
  Initialized,
  /**
   * Pending
   */
  Pending,
  /**
   * Connecting
   */
  Connecting,
  /**
   * Connected
   */
  Connected,
  /**
   * Disconnected, will retry to connect again
   */
  Disconnected,
  /**
   * Completely disconnected
   */
  Terminated,
}

const FfiConverterTypeRelayStatus = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RelayStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return RelayStatus.Initialized;
        case 2:
          return RelayStatus.Pending;
        case 3:
          return RelayStatus.Connecting;
        case 4:
          return RelayStatus.Connected;
        case 5:
          return RelayStatus.Disconnected;
        case 6:
          return RelayStatus.Terminated;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case RelayStatus.Initialized:
          return ordinalConverter.write(1, into);
        case RelayStatus.Pending:
          return ordinalConverter.write(2, into);
        case RelayStatus.Connecting:
          return ordinalConverter.write(3, into);
        case RelayStatus.Connected:
          return ordinalConverter.write(4, into);
        case RelayStatus.Disconnected:
          return ordinalConverter.write(5, into);
        case RelayStatus.Terminated:
          return ordinalConverter.write(6, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Report
 *
 * <https://github.com/nostr-protocol/nips/blob/master/56.md>
 */
export enum Report {
  /**
   * Depictions of nudity, porn, etc
   */
  Nudity,
  /**
   * Virus, trojan horse, worm, robot, spyware, adware, back door, ransomware, rootkit, kidnapper, etc.
   */
  Malware,
  /**
   * Profanity, hateful speech, etc.
   */
  Profanity,
  /**
   * Something which may be illegal in some jurisdiction
   *
   * Remember: there is what is right and there is the law.
   */
  Illegal,
  /**
   * Spam
   */
  Spam,
  /**
   * Someone pretending to be someone else
   */
  Impersonation,
  /**
   * Reports that don't fit in the above categories
   */
  Other,
}

const FfiConverterTypeReport = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Report;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return Report.Nudity;
        case 2:
          return Report.Malware;
        case 3:
          return Report.Profanity;
        case 4:
          return Report.Illegal;
        case 5:
          return Report.Spam;
        case 6:
          return Report.Impersonation;
        case 7:
          return Report.Other;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case Report.Nudity:
          return ordinalConverter.write(1, into);
        case Report.Malware:
          return ordinalConverter.write(2, into);
        case Report.Profanity:
          return ordinalConverter.write(3, into);
        case Report.Illegal:
          return ordinalConverter.write(4, into);
        case Report.Spam:
          return ordinalConverter.write(5, into);
        case Report.Impersonation:
          return ordinalConverter.write(6, into);
        case Report.Other:
          return ordinalConverter.write(7, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: ReqExitPolicy
export enum ReqExitPolicy_Tags {
  ExitOnEose = 'ExitOnEOSE',
  WaitForEvents = 'WaitForEvents',
  WaitForEventsAfterEose = 'WaitForEventsAfterEOSE',
  WaitDurationAfterEose = 'WaitDurationAfterEOSE',
}
/**
 * Request (REQ) exit policy
 */
export const ReqExitPolicy = (() => {
  type ExitOnEose__interface = {
    tag: ReqExitPolicy_Tags.ExitOnEose;
  };

  /**
   * Exit on EOSE
   */
  class ExitOnEose_ extends UniffiEnum implements ExitOnEose__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ReqExitPolicy';
    readonly tag = ReqExitPolicy_Tags.ExitOnEose;
    constructor() {
      super('ReqExitPolicy', 'ExitOnEose');
    }

    static new(): ExitOnEose_ {
      return new ExitOnEose_();
    }

    static instanceOf(obj: any): obj is ExitOnEose_ {
      return obj.tag === ReqExitPolicy_Tags.ExitOnEose;
    }
  }

  type WaitForEvents__interface = {
    tag: ReqExitPolicy_Tags.WaitForEvents;
    inner: Readonly<{ num: /*u16*/ number }>;
  };

  /**
   * Wait to receive N events and then exit.
   */
  class WaitForEvents_ extends UniffiEnum implements WaitForEvents__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ReqExitPolicy';
    readonly tag = ReqExitPolicy_Tags.WaitForEvents;
    readonly inner: Readonly<{ num: /*u16*/ number }>;
    constructor(inner: { num: /*u16*/ number }) {
      super('ReqExitPolicy', 'WaitForEvents');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { num: /*u16*/ number }): WaitForEvents_ {
      return new WaitForEvents_(inner);
    }

    static instanceOf(obj: any): obj is WaitForEvents_ {
      return obj.tag === ReqExitPolicy_Tags.WaitForEvents;
    }
  }

  type WaitForEventsAfterEose__interface = {
    tag: ReqExitPolicy_Tags.WaitForEventsAfterEose;
    inner: Readonly<{ num: /*u16*/ number }>;
  };

  /**
   * After EOSE is received, keep listening for N more events that match the filter.
   */
  class WaitForEventsAfterEose_
    extends UniffiEnum
    implements WaitForEventsAfterEose__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ReqExitPolicy';
    readonly tag = ReqExitPolicy_Tags.WaitForEventsAfterEose;
    readonly inner: Readonly<{ num: /*u16*/ number }>;
    constructor(inner: { num: /*u16*/ number }) {
      super('ReqExitPolicy', 'WaitForEventsAfterEose');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { num: /*u16*/ number }): WaitForEventsAfterEose_ {
      return new WaitForEventsAfterEose_(inner);
    }

    static instanceOf(obj: any): obj is WaitForEventsAfterEose_ {
      return obj.tag === ReqExitPolicy_Tags.WaitForEventsAfterEose;
    }
  }

  type WaitDurationAfterEose__interface = {
    tag: ReqExitPolicy_Tags.WaitDurationAfterEose;
    inner: Readonly<{ duration: UniffiDuration }>;
  };

  /**
   * After EOSE is received, keep listening for matching events for `Duration` more time.
   */
  class WaitDurationAfterEose_
    extends UniffiEnum
    implements WaitDurationAfterEose__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ReqExitPolicy';
    readonly tag = ReqExitPolicy_Tags.WaitDurationAfterEose;
    readonly inner: Readonly<{ duration: UniffiDuration }>;
    constructor(inner: { duration: UniffiDuration }) {
      super('ReqExitPolicy', 'WaitDurationAfterEose');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { duration: UniffiDuration }): WaitDurationAfterEose_ {
      return new WaitDurationAfterEose_(inner);
    }

    static instanceOf(obj: any): obj is WaitDurationAfterEose_ {
      return obj.tag === ReqExitPolicy_Tags.WaitDurationAfterEose;
    }
  }

  function instanceOf(obj: any): obj is ReqExitPolicy {
    return obj[uniffiTypeNameSymbol] === 'ReqExitPolicy';
  }

  return Object.freeze({
    instanceOf,
    ExitOnEose: ExitOnEose_,
    WaitForEvents: WaitForEvents_,
    WaitForEventsAfterEose: WaitForEventsAfterEose_,
    WaitDurationAfterEose: WaitDurationAfterEose_,
  });
})();

/**
 * Request (REQ) exit policy
 */

export type ReqExitPolicy = InstanceType<
  (typeof ReqExitPolicy)[keyof Omit<typeof ReqExitPolicy, 'instanceOf'>]
>;

// FfiConverter for enum ReqExitPolicy
const FfiConverterTypeReqExitPolicy = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ReqExitPolicy;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ReqExitPolicy.ExitOnEose();
        case 2:
          return new ReqExitPolicy.WaitForEvents({
            num: FfiConverterUInt16.read(from),
          });
        case 3:
          return new ReqExitPolicy.WaitForEventsAfterEose({
            num: FfiConverterUInt16.read(from),
          });
        case 4:
          return new ReqExitPolicy.WaitDurationAfterEose({
            duration: FfiConverterDuration.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ReqExitPolicy_Tags.ExitOnEose: {
          ordinalConverter.write(1, into);
          return;
        }
        case ReqExitPolicy_Tags.WaitForEvents: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt16.write(inner.num, into);
          return;
        }
        case ReqExitPolicy_Tags.WaitForEventsAfterEose: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterUInt16.write(inner.num, into);
          return;
        }
        case ReqExitPolicy_Tags.WaitDurationAfterEose: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterDuration.write(inner.duration, into);
          return;
        }
        default:
          // Throwing from here means that ReqExitPolicy_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ReqExitPolicy_Tags.ExitOnEose: {
          return ordinalConverter.allocationSize(1);
        }
        case ReqExitPolicy_Tags.WaitForEvents: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt16.allocationSize(inner.num);
          return size;
        }
        case ReqExitPolicy_Tags.WaitForEventsAfterEose: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterUInt16.allocationSize(inner.num);
          return size;
        }
        case ReqExitPolicy_Tags.WaitDurationAfterEose: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterDuration.allocationSize(inner.duration);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: RequestParams
export enum RequestParams_Tags {
  PayInvoice = 'PayInvoice',
  MultiPayInvoice = 'MultiPayInvoice',
  PayKeysend = 'PayKeysend',
  MultiPayKeysend = 'MultiPayKeysend',
  MakeInvoice = 'MakeInvoice',
  LookupInvoice = 'LookupInvoice',
  ListTransactions = 'ListTransactions',
  GetBalance = 'GetBalance',
  GetInfo = 'GetInfo',
}
/**
 * Nostr Wallet Connect Request Params
 */
export const RequestParams = (() => {
  type PayInvoice__interface = {
    tag: RequestParams_Tags.PayInvoice;
    inner: Readonly<{ payInvoice: PayInvoiceRequest }>;
  };

  /**
   * Pay Invoice
   */
  class PayInvoice_ extends UniffiEnum implements PayInvoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RequestParams';
    readonly tag = RequestParams_Tags.PayInvoice;
    readonly inner: Readonly<{ payInvoice: PayInvoiceRequest }>;
    constructor(inner: { payInvoice: PayInvoiceRequest }) {
      super('RequestParams', 'PayInvoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { payInvoice: PayInvoiceRequest }): PayInvoice_ {
      return new PayInvoice_(inner);
    }

    static instanceOf(obj: any): obj is PayInvoice_ {
      return obj.tag === RequestParams_Tags.PayInvoice;
    }
  }

  type MultiPayInvoice__interface = {
    tag: RequestParams_Tags.MultiPayInvoice;
    inner: Readonly<{ multiPayInvoice: MultiPayInvoiceRequest }>;
  };

  /**
   * Multi Pay Invoice
   */
  class MultiPayInvoice_
    extends UniffiEnum
    implements MultiPayInvoice__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RequestParams';
    readonly tag = RequestParams_Tags.MultiPayInvoice;
    readonly inner: Readonly<{ multiPayInvoice: MultiPayInvoiceRequest }>;
    constructor(inner: { multiPayInvoice: MultiPayInvoiceRequest }) {
      super('RequestParams', 'MultiPayInvoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      multiPayInvoice: MultiPayInvoiceRequest;
    }): MultiPayInvoice_ {
      return new MultiPayInvoice_(inner);
    }

    static instanceOf(obj: any): obj is MultiPayInvoice_ {
      return obj.tag === RequestParams_Tags.MultiPayInvoice;
    }
  }

  type PayKeysend__interface = {
    tag: RequestParams_Tags.PayKeysend;
    inner: Readonly<{ payKeysend: PayKeysendRequest }>;
  };

  /**
   * Pay Keysend
   */
  class PayKeysend_ extends UniffiEnum implements PayKeysend__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RequestParams';
    readonly tag = RequestParams_Tags.PayKeysend;
    readonly inner: Readonly<{ payKeysend: PayKeysendRequest }>;
    constructor(inner: { payKeysend: PayKeysendRequest }) {
      super('RequestParams', 'PayKeysend');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { payKeysend: PayKeysendRequest }): PayKeysend_ {
      return new PayKeysend_(inner);
    }

    static instanceOf(obj: any): obj is PayKeysend_ {
      return obj.tag === RequestParams_Tags.PayKeysend;
    }
  }

  type MultiPayKeysend__interface = {
    tag: RequestParams_Tags.MultiPayKeysend;
    inner: Readonly<{ multiPayKeysend: MultiPayKeysendRequest }>;
  };

  /**
   * Multi Pay Keysend
   */
  class MultiPayKeysend_
    extends UniffiEnum
    implements MultiPayKeysend__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RequestParams';
    readonly tag = RequestParams_Tags.MultiPayKeysend;
    readonly inner: Readonly<{ multiPayKeysend: MultiPayKeysendRequest }>;
    constructor(inner: { multiPayKeysend: MultiPayKeysendRequest }) {
      super('RequestParams', 'MultiPayKeysend');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      multiPayKeysend: MultiPayKeysendRequest;
    }): MultiPayKeysend_ {
      return new MultiPayKeysend_(inner);
    }

    static instanceOf(obj: any): obj is MultiPayKeysend_ {
      return obj.tag === RequestParams_Tags.MultiPayKeysend;
    }
  }

  type MakeInvoice__interface = {
    tag: RequestParams_Tags.MakeInvoice;
    inner: Readonly<{ makeInvoice: MakeInvoiceRequest }>;
  };

  /**
   * Make Invoice
   */
  class MakeInvoice_ extends UniffiEnum implements MakeInvoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RequestParams';
    readonly tag = RequestParams_Tags.MakeInvoice;
    readonly inner: Readonly<{ makeInvoice: MakeInvoiceRequest }>;
    constructor(inner: { makeInvoice: MakeInvoiceRequest }) {
      super('RequestParams', 'MakeInvoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { makeInvoice: MakeInvoiceRequest }): MakeInvoice_ {
      return new MakeInvoice_(inner);
    }

    static instanceOf(obj: any): obj is MakeInvoice_ {
      return obj.tag === RequestParams_Tags.MakeInvoice;
    }
  }

  type LookupInvoice__interface = {
    tag: RequestParams_Tags.LookupInvoice;
    inner: Readonly<{ lookupInvoice: LookupInvoiceRequest }>;
  };

  /**
   * Lookup Invoice
   */
  class LookupInvoice_ extends UniffiEnum implements LookupInvoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RequestParams';
    readonly tag = RequestParams_Tags.LookupInvoice;
    readonly inner: Readonly<{ lookupInvoice: LookupInvoiceRequest }>;
    constructor(inner: { lookupInvoice: LookupInvoiceRequest }) {
      super('RequestParams', 'LookupInvoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { lookupInvoice: LookupInvoiceRequest }): LookupInvoice_ {
      return new LookupInvoice_(inner);
    }

    static instanceOf(obj: any): obj is LookupInvoice_ {
      return obj.tag === RequestParams_Tags.LookupInvoice;
    }
  }

  type ListTransactions__interface = {
    tag: RequestParams_Tags.ListTransactions;
    inner: Readonly<{ listTransactions: ListTransactionsRequest }>;
  };

  /**
   * List Transactions
   */
  class ListTransactions_
    extends UniffiEnum
    implements ListTransactions__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RequestParams';
    readonly tag = RequestParams_Tags.ListTransactions;
    readonly inner: Readonly<{ listTransactions: ListTransactionsRequest }>;
    constructor(inner: { listTransactions: ListTransactionsRequest }) {
      super('RequestParams', 'ListTransactions');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      listTransactions: ListTransactionsRequest;
    }): ListTransactions_ {
      return new ListTransactions_(inner);
    }

    static instanceOf(obj: any): obj is ListTransactions_ {
      return obj.tag === RequestParams_Tags.ListTransactions;
    }
  }

  type GetBalance__interface = {
    tag: RequestParams_Tags.GetBalance;
  };

  /**
   * Get Balance
   */
  class GetBalance_ extends UniffiEnum implements GetBalance__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RequestParams';
    readonly tag = RequestParams_Tags.GetBalance;
    constructor() {
      super('RequestParams', 'GetBalance');
    }

    static new(): GetBalance_ {
      return new GetBalance_();
    }

    static instanceOf(obj: any): obj is GetBalance_ {
      return obj.tag === RequestParams_Tags.GetBalance;
    }
  }

  type GetInfo__interface = {
    tag: RequestParams_Tags.GetInfo;
  };

  /**
   * Get Info
   */
  class GetInfo_ extends UniffiEnum implements GetInfo__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RequestParams';
    readonly tag = RequestParams_Tags.GetInfo;
    constructor() {
      super('RequestParams', 'GetInfo');
    }

    static new(): GetInfo_ {
      return new GetInfo_();
    }

    static instanceOf(obj: any): obj is GetInfo_ {
      return obj.tag === RequestParams_Tags.GetInfo;
    }
  }

  function instanceOf(obj: any): obj is RequestParams {
    return obj[uniffiTypeNameSymbol] === 'RequestParams';
  }

  return Object.freeze({
    instanceOf,
    PayInvoice: PayInvoice_,
    MultiPayInvoice: MultiPayInvoice_,
    PayKeysend: PayKeysend_,
    MultiPayKeysend: MultiPayKeysend_,
    MakeInvoice: MakeInvoice_,
    LookupInvoice: LookupInvoice_,
    ListTransactions: ListTransactions_,
    GetBalance: GetBalance_,
    GetInfo: GetInfo_,
  });
})();

/**
 * Nostr Wallet Connect Request Params
 */

export type RequestParams = InstanceType<
  (typeof RequestParams)[keyof Omit<typeof RequestParams, 'instanceOf'>]
>;

// FfiConverter for enum RequestParams
const FfiConverterTypeRequestParams = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RequestParams;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RequestParams.PayInvoice({
            payInvoice: FfiConverterTypePayInvoiceRequest.read(from),
          });
        case 2:
          return new RequestParams.MultiPayInvoice({
            multiPayInvoice: FfiConverterTypeMultiPayInvoiceRequest.read(from),
          });
        case 3:
          return new RequestParams.PayKeysend({
            payKeysend: FfiConverterTypePayKeysendRequest.read(from),
          });
        case 4:
          return new RequestParams.MultiPayKeysend({
            multiPayKeysend: FfiConverterTypeMultiPayKeysendRequest.read(from),
          });
        case 5:
          return new RequestParams.MakeInvoice({
            makeInvoice: FfiConverterTypeMakeInvoiceRequest.read(from),
          });
        case 6:
          return new RequestParams.LookupInvoice({
            lookupInvoice: FfiConverterTypeLookupInvoiceRequest.read(from),
          });
        case 7:
          return new RequestParams.ListTransactions({
            listTransactions:
              FfiConverterTypeListTransactionsRequest.read(from),
          });
        case 8:
          return new RequestParams.GetBalance();
        case 9:
          return new RequestParams.GetInfo();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RequestParams_Tags.PayInvoice: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypePayInvoiceRequest.write(inner.payInvoice, into);
          return;
        }
        case RequestParams_Tags.MultiPayInvoice: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeMultiPayInvoiceRequest.write(
            inner.multiPayInvoice,
            into
          );
          return;
        }
        case RequestParams_Tags.PayKeysend: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypePayKeysendRequest.write(inner.payKeysend, into);
          return;
        }
        case RequestParams_Tags.MultiPayKeysend: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeMultiPayKeysendRequest.write(
            inner.multiPayKeysend,
            into
          );
          return;
        }
        case RequestParams_Tags.MakeInvoice: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterTypeMakeInvoiceRequest.write(inner.makeInvoice, into);
          return;
        }
        case RequestParams_Tags.LookupInvoice: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterTypeLookupInvoiceRequest.write(inner.lookupInvoice, into);
          return;
        }
        case RequestParams_Tags.ListTransactions: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterTypeListTransactionsRequest.write(
            inner.listTransactions,
            into
          );
          return;
        }
        case RequestParams_Tags.GetBalance: {
          ordinalConverter.write(8, into);
          return;
        }
        case RequestParams_Tags.GetInfo: {
          ordinalConverter.write(9, into);
          return;
        }
        default:
          // Throwing from here means that RequestParams_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RequestParams_Tags.PayInvoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypePayInvoiceRequest.allocationSize(
            inner.payInvoice
          );
          return size;
        }
        case RequestParams_Tags.MultiPayInvoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeMultiPayInvoiceRequest.allocationSize(
            inner.multiPayInvoice
          );
          return size;
        }
        case RequestParams_Tags.PayKeysend: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypePayKeysendRequest.allocationSize(
            inner.payKeysend
          );
          return size;
        }
        case RequestParams_Tags.MultiPayKeysend: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeMultiPayKeysendRequest.allocationSize(
            inner.multiPayKeysend
          );
          return size;
        }
        case RequestParams_Tags.MakeInvoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterTypeMakeInvoiceRequest.allocationSize(
            inner.makeInvoice
          );
          return size;
        }
        case RequestParams_Tags.LookupInvoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterTypeLookupInvoiceRequest.allocationSize(
            inner.lookupInvoice
          );
          return size;
        }
        case RequestParams_Tags.ListTransactions: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterTypeListTransactionsRequest.allocationSize(
            inner.listTransactions
          );
          return size;
        }
        case RequestParams_Tags.GetBalance: {
          return ordinalConverter.allocationSize(8);
        }
        case RequestParams_Tags.GetInfo: {
          return ordinalConverter.allocationSize(9);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: ResponseResult
export enum ResponseResult_Tags {
  PayInvoice = 'PayInvoice',
  MultiPayInvoice = 'MultiPayInvoice',
  PayKeysend = 'PayKeysend',
  MultiPayKeysend = 'MultiPayKeysend',
  MakeInvoice = 'MakeInvoice',
  LookupInvoice = 'LookupInvoice',
  ListTransactions = 'ListTransactions',
  GetBalance = 'GetBalance',
  GetInfo = 'GetInfo',
}
/**
 * NIP47 Response Result
 */
export const ResponseResult = (() => {
  type PayInvoice__interface = {
    tag: ResponseResult_Tags.PayInvoice;
    inner: Readonly<{ payInvoice: PayInvoiceResponse }>;
  };

  /**
   * Pay Invoice
   */
  class PayInvoice_ extends UniffiEnum implements PayInvoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ResponseResult';
    readonly tag = ResponseResult_Tags.PayInvoice;
    readonly inner: Readonly<{ payInvoice: PayInvoiceResponse }>;
    constructor(inner: { payInvoice: PayInvoiceResponse }) {
      super('ResponseResult', 'PayInvoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { payInvoice: PayInvoiceResponse }): PayInvoice_ {
      return new PayInvoice_(inner);
    }

    static instanceOf(obj: any): obj is PayInvoice_ {
      return obj.tag === ResponseResult_Tags.PayInvoice;
    }
  }

  type MultiPayInvoice__interface = {
    tag: ResponseResult_Tags.MultiPayInvoice;
    inner: Readonly<{ payInvoice: PayInvoiceResponse }>;
  };

  /**
   * Multi Pay Invoice
   */
  class MultiPayInvoice_
    extends UniffiEnum
    implements MultiPayInvoice__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ResponseResult';
    readonly tag = ResponseResult_Tags.MultiPayInvoice;
    readonly inner: Readonly<{ payInvoice: PayInvoiceResponse }>;
    constructor(inner: { payInvoice: PayInvoiceResponse }) {
      super('ResponseResult', 'MultiPayInvoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { payInvoice: PayInvoiceResponse }): MultiPayInvoice_ {
      return new MultiPayInvoice_(inner);
    }

    static instanceOf(obj: any): obj is MultiPayInvoice_ {
      return obj.tag === ResponseResult_Tags.MultiPayInvoice;
    }
  }

  type PayKeysend__interface = {
    tag: ResponseResult_Tags.PayKeysend;
    inner: Readonly<{ payKeysend: PayKeysendResponse }>;
  };

  /**
   * Pay Keysend
   */
  class PayKeysend_ extends UniffiEnum implements PayKeysend__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ResponseResult';
    readonly tag = ResponseResult_Tags.PayKeysend;
    readonly inner: Readonly<{ payKeysend: PayKeysendResponse }>;
    constructor(inner: { payKeysend: PayKeysendResponse }) {
      super('ResponseResult', 'PayKeysend');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { payKeysend: PayKeysendResponse }): PayKeysend_ {
      return new PayKeysend_(inner);
    }

    static instanceOf(obj: any): obj is PayKeysend_ {
      return obj.tag === ResponseResult_Tags.PayKeysend;
    }
  }

  type MultiPayKeysend__interface = {
    tag: ResponseResult_Tags.MultiPayKeysend;
    inner: Readonly<{ payKeysend: PayKeysendResponse }>;
  };

  /**
   * Multi Pay Keysend
   */
  class MultiPayKeysend_
    extends UniffiEnum
    implements MultiPayKeysend__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ResponseResult';
    readonly tag = ResponseResult_Tags.MultiPayKeysend;
    readonly inner: Readonly<{ payKeysend: PayKeysendResponse }>;
    constructor(inner: { payKeysend: PayKeysendResponse }) {
      super('ResponseResult', 'MultiPayKeysend');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { payKeysend: PayKeysendResponse }): MultiPayKeysend_ {
      return new MultiPayKeysend_(inner);
    }

    static instanceOf(obj: any): obj is MultiPayKeysend_ {
      return obj.tag === ResponseResult_Tags.MultiPayKeysend;
    }
  }

  type MakeInvoice__interface = {
    tag: ResponseResult_Tags.MakeInvoice;
    inner: Readonly<{ makeInvoice: MakeInvoiceResponse }>;
  };

  /**
   * Make Invoice
   */
  class MakeInvoice_ extends UniffiEnum implements MakeInvoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ResponseResult';
    readonly tag = ResponseResult_Tags.MakeInvoice;
    readonly inner: Readonly<{ makeInvoice: MakeInvoiceResponse }>;
    constructor(inner: { makeInvoice: MakeInvoiceResponse }) {
      super('ResponseResult', 'MakeInvoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { makeInvoice: MakeInvoiceResponse }): MakeInvoice_ {
      return new MakeInvoice_(inner);
    }

    static instanceOf(obj: any): obj is MakeInvoice_ {
      return obj.tag === ResponseResult_Tags.MakeInvoice;
    }
  }

  type LookupInvoice__interface = {
    tag: ResponseResult_Tags.LookupInvoice;
    inner: Readonly<{ lookupInvoice: LookupInvoiceResponse }>;
  };

  /**
   * Lookup Invoice
   */
  class LookupInvoice_ extends UniffiEnum implements LookupInvoice__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ResponseResult';
    readonly tag = ResponseResult_Tags.LookupInvoice;
    readonly inner: Readonly<{ lookupInvoice: LookupInvoiceResponse }>;
    constructor(inner: { lookupInvoice: LookupInvoiceResponse }) {
      super('ResponseResult', 'LookupInvoice');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      lookupInvoice: LookupInvoiceResponse;
    }): LookupInvoice_ {
      return new LookupInvoice_(inner);
    }

    static instanceOf(obj: any): obj is LookupInvoice_ {
      return obj.tag === ResponseResult_Tags.LookupInvoice;
    }
  }

  type ListTransactions__interface = {
    tag: ResponseResult_Tags.ListTransactions;
    inner: Readonly<{ listTransactions: Array<LookupInvoiceResponse> }>;
  };

  /**
   * List Transactions
   */
  class ListTransactions_
    extends UniffiEnum
    implements ListTransactions__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ResponseResult';
    readonly tag = ResponseResult_Tags.ListTransactions;
    readonly inner: Readonly<{
      listTransactions: Array<LookupInvoiceResponse>;
    }>;
    constructor(inner: { listTransactions: Array<LookupInvoiceResponse> }) {
      super('ResponseResult', 'ListTransactions');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      listTransactions: Array<LookupInvoiceResponse>;
    }): ListTransactions_ {
      return new ListTransactions_(inner);
    }

    static instanceOf(obj: any): obj is ListTransactions_ {
      return obj.tag === ResponseResult_Tags.ListTransactions;
    }
  }

  type GetBalance__interface = {
    tag: ResponseResult_Tags.GetBalance;
    inner: Readonly<{ getBalance: GetBalanceResponse }>;
  };

  /**
   * Get Balance
   */
  class GetBalance_ extends UniffiEnum implements GetBalance__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ResponseResult';
    readonly tag = ResponseResult_Tags.GetBalance;
    readonly inner: Readonly<{ getBalance: GetBalanceResponse }>;
    constructor(inner: { getBalance: GetBalanceResponse }) {
      super('ResponseResult', 'GetBalance');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { getBalance: GetBalanceResponse }): GetBalance_ {
      return new GetBalance_(inner);
    }

    static instanceOf(obj: any): obj is GetBalance_ {
      return obj.tag === ResponseResult_Tags.GetBalance;
    }
  }

  type GetInfo__interface = {
    tag: ResponseResult_Tags.GetInfo;
    inner: Readonly<{ getInfo: GetInfoResponse }>;
  };

  /**
   * Get Info
   */
  class GetInfo_ extends UniffiEnum implements GetInfo__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ResponseResult';
    readonly tag = ResponseResult_Tags.GetInfo;
    readonly inner: Readonly<{ getInfo: GetInfoResponse }>;
    constructor(inner: { getInfo: GetInfoResponse }) {
      super('ResponseResult', 'GetInfo');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { getInfo: GetInfoResponse }): GetInfo_ {
      return new GetInfo_(inner);
    }

    static instanceOf(obj: any): obj is GetInfo_ {
      return obj.tag === ResponseResult_Tags.GetInfo;
    }
  }

  function instanceOf(obj: any): obj is ResponseResult {
    return obj[uniffiTypeNameSymbol] === 'ResponseResult';
  }

  return Object.freeze({
    instanceOf,
    PayInvoice: PayInvoice_,
    MultiPayInvoice: MultiPayInvoice_,
    PayKeysend: PayKeysend_,
    MultiPayKeysend: MultiPayKeysend_,
    MakeInvoice: MakeInvoice_,
    LookupInvoice: LookupInvoice_,
    ListTransactions: ListTransactions_,
    GetBalance: GetBalance_,
    GetInfo: GetInfo_,
  });
})();

/**
 * NIP47 Response Result
 */

export type ResponseResult = InstanceType<
  (typeof ResponseResult)[keyof Omit<typeof ResponseResult, 'instanceOf'>]
>;

// FfiConverter for enum ResponseResult
const FfiConverterTypeResponseResult = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ResponseResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ResponseResult.PayInvoice({
            payInvoice: FfiConverterTypePayInvoiceResponse.read(from),
          });
        case 2:
          return new ResponseResult.MultiPayInvoice({
            payInvoice: FfiConverterTypePayInvoiceResponse.read(from),
          });
        case 3:
          return new ResponseResult.PayKeysend({
            payKeysend: FfiConverterTypePayKeysendResponse.read(from),
          });
        case 4:
          return new ResponseResult.MultiPayKeysend({
            payKeysend: FfiConverterTypePayKeysendResponse.read(from),
          });
        case 5:
          return new ResponseResult.MakeInvoice({
            makeInvoice: FfiConverterTypeMakeInvoiceResponse.read(from),
          });
        case 6:
          return new ResponseResult.LookupInvoice({
            lookupInvoice: FfiConverterTypeLookupInvoiceResponse.read(from),
          });
        case 7:
          return new ResponseResult.ListTransactions({
            listTransactions:
              FfiConverterArrayTypeLookupInvoiceResponse.read(from),
          });
        case 8:
          return new ResponseResult.GetBalance({
            getBalance: FfiConverterTypeGetBalanceResponse.read(from),
          });
        case 9:
          return new ResponseResult.GetInfo({
            getInfo: FfiConverterTypeGetInfoResponse.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ResponseResult_Tags.PayInvoice: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypePayInvoiceResponse.write(inner.payInvoice, into);
          return;
        }
        case ResponseResult_Tags.MultiPayInvoice: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypePayInvoiceResponse.write(inner.payInvoice, into);
          return;
        }
        case ResponseResult_Tags.PayKeysend: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypePayKeysendResponse.write(inner.payKeysend, into);
          return;
        }
        case ResponseResult_Tags.MultiPayKeysend: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypePayKeysendResponse.write(inner.payKeysend, into);
          return;
        }
        case ResponseResult_Tags.MakeInvoice: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterTypeMakeInvoiceResponse.write(inner.makeInvoice, into);
          return;
        }
        case ResponseResult_Tags.LookupInvoice: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterTypeLookupInvoiceResponse.write(
            inner.lookupInvoice,
            into
          );
          return;
        }
        case ResponseResult_Tags.ListTransactions: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterArrayTypeLookupInvoiceResponse.write(
            inner.listTransactions,
            into
          );
          return;
        }
        case ResponseResult_Tags.GetBalance: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterTypeGetBalanceResponse.write(inner.getBalance, into);
          return;
        }
        case ResponseResult_Tags.GetInfo: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterTypeGetInfoResponse.write(inner.getInfo, into);
          return;
        }
        default:
          // Throwing from here means that ResponseResult_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ResponseResult_Tags.PayInvoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypePayInvoiceResponse.allocationSize(
            inner.payInvoice
          );
          return size;
        }
        case ResponseResult_Tags.MultiPayInvoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypePayInvoiceResponse.allocationSize(
            inner.payInvoice
          );
          return size;
        }
        case ResponseResult_Tags.PayKeysend: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypePayKeysendResponse.allocationSize(
            inner.payKeysend
          );
          return size;
        }
        case ResponseResult_Tags.MultiPayKeysend: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypePayKeysendResponse.allocationSize(
            inner.payKeysend
          );
          return size;
        }
        case ResponseResult_Tags.MakeInvoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterTypeMakeInvoiceResponse.allocationSize(
            inner.makeInvoice
          );
          return size;
        }
        case ResponseResult_Tags.LookupInvoice: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterTypeLookupInvoiceResponse.allocationSize(
            inner.lookupInvoice
          );
          return size;
        }
        case ResponseResult_Tags.ListTransactions: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterArrayTypeLookupInvoiceResponse.allocationSize(
            inner.listTransactions
          );
          return size;
        }
        case ResponseResult_Tags.GetBalance: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterTypeGetBalanceResponse.allocationSize(
            inner.getBalance
          );
          return size;
        }
        case ResponseResult_Tags.GetInfo: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterTypeGetInfoResponse.allocationSize(inner.getInfo);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: RetentionKind
export enum RetentionKind_Tags {
  Single = 'Single',
  Range = 'Range',
}
export const RetentionKind = (() => {
  type Single__interface = {
    tag: RetentionKind_Tags.Single;
    inner: Readonly<{ single: /*u64*/ bigint }>;
  };

  class Single_ extends UniffiEnum implements Single__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RetentionKind';
    readonly tag = RetentionKind_Tags.Single;
    readonly inner: Readonly<{ single: /*u64*/ bigint }>;
    constructor(inner: { single: /*u64*/ bigint }) {
      super('RetentionKind', 'Single');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { single: /*u64*/ bigint }): Single_ {
      return new Single_(inner);
    }

    static instanceOf(obj: any): obj is Single_ {
      return obj.tag === RetentionKind_Tags.Single;
    }
  }

  type Range__interface = {
    tag: RetentionKind_Tags.Range;
    inner: Readonly<{ start: /*u64*/ bigint; end: /*u64*/ bigint }>;
  };

  class Range_ extends UniffiEnum implements Range__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RetentionKind';
    readonly tag = RetentionKind_Tags.Range;
    readonly inner: Readonly<{ start: /*u64*/ bigint; end: /*u64*/ bigint }>;
    constructor(inner: { start: /*u64*/ bigint; end: /*u64*/ bigint }) {
      super('RetentionKind', 'Range');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { start: /*u64*/ bigint; end: /*u64*/ bigint }): Range_ {
      return new Range_(inner);
    }

    static instanceOf(obj: any): obj is Range_ {
      return obj.tag === RetentionKind_Tags.Range;
    }
  }

  function instanceOf(obj: any): obj is RetentionKind {
    return obj[uniffiTypeNameSymbol] === 'RetentionKind';
  }

  return Object.freeze({
    instanceOf,
    Single: Single_,
    Range: Range_,
  });
})();

export type RetentionKind = InstanceType<
  (typeof RetentionKind)[keyof Omit<typeof RetentionKind, 'instanceOf'>]
>;

// FfiConverter for enum RetentionKind
const FfiConverterTypeRetentionKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RetentionKind;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RetentionKind.Single({
            single: FfiConverterUInt64.read(from),
          });
        case 2:
          return new RetentionKind.Range({
            start: FfiConverterUInt64.read(from),
            end: FfiConverterUInt64.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RetentionKind_Tags.Single: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.single, into);
          return;
        }
        case RetentionKind_Tags.Range: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.start, into);
          FfiConverterUInt64.write(inner.end, into);
          return;
        }
        default:
          // Throwing from here means that RetentionKind_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RetentionKind_Tags.Single: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterUInt64.allocationSize(inner.single);
          return size;
        }
        case RetentionKind_Tags.Range: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt64.allocationSize(inner.start);
          size += FfiConverterUInt64.allocationSize(inner.end);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SaveEventStatus
export enum SaveEventStatus_Tags {
  Success = 'Success',
  Rejected = 'Rejected',
}
/**
 * Save event status
 */
export const SaveEventStatus = (() => {
  type Success__interface = {
    tag: SaveEventStatus_Tags.Success;
  };

  /**
   * The event has been successfully saved
   */
  class Success_ extends UniffiEnum implements Success__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SaveEventStatus';
    readonly tag = SaveEventStatus_Tags.Success;
    constructor() {
      super('SaveEventStatus', 'Success');
    }

    static new(): Success_ {
      return new Success_();
    }

    static instanceOf(obj: any): obj is Success_ {
      return obj.tag === SaveEventStatus_Tags.Success;
    }
  }

  type Rejected__interface = {
    tag: SaveEventStatus_Tags.Rejected;
    inner: Readonly<[RejectedReason]>;
  };

  /**
   * The event has been rejected
   */
  class Rejected_ extends UniffiEnum implements Rejected__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SaveEventStatus';
    readonly tag = SaveEventStatus_Tags.Rejected;
    readonly inner: Readonly<[RejectedReason]>;
    constructor(v0: RejectedReason) {
      super('SaveEventStatus', 'Rejected');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: RejectedReason): Rejected_ {
      return new Rejected_(v0);
    }

    static instanceOf(obj: any): obj is Rejected_ {
      return obj.tag === SaveEventStatus_Tags.Rejected;
    }
  }

  function instanceOf(obj: any): obj is SaveEventStatus {
    return obj[uniffiTypeNameSymbol] === 'SaveEventStatus';
  }

  return Object.freeze({
    instanceOf,
    Success: Success_,
    Rejected: Rejected_,
  });
})();

/**
 * Save event status
 */

export type SaveEventStatus = InstanceType<
  (typeof SaveEventStatus)[keyof Omit<typeof SaveEventStatus, 'instanceOf'>]
>;

// FfiConverter for enum SaveEventStatus
const FfiConverterTypeSaveEventStatus = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SaveEventStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SaveEventStatus.Success();
        case 2:
          return new SaveEventStatus.Rejected(
            FfiConverterTypeRejectedReason.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SaveEventStatus_Tags.Success: {
          ordinalConverter.write(1, into);
          return;
        }
        case SaveEventStatus_Tags.Rejected: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeRejectedReason.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that SaveEventStatus_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SaveEventStatus_Tags.Success: {
          return ordinalConverter.allocationSize(1);
        }
        case SaveEventStatus_Tags.Rejected: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeRejectedReason.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SignerBackend
export enum SignerBackend_Tags {
  Keys = 'Keys',
  BrowserExtension = 'BrowserExtension',
  NostrConnect = 'NostrConnect',
  Custom = 'Custom',
}
export const SignerBackend = (() => {
  type Keys__interface = {
    tag: SignerBackend_Tags.Keys;
  };

  /**
   * Secret key
   */
  class Keys_ extends UniffiEnum implements Keys__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SignerBackend';
    readonly tag = SignerBackend_Tags.Keys;
    constructor() {
      super('SignerBackend', 'Keys');
    }

    static new(): Keys_ {
      return new Keys_();
    }

    static instanceOf(obj: any): obj is Keys_ {
      return obj.tag === SignerBackend_Tags.Keys;
    }
  }

  type BrowserExtension__interface = {
    tag: SignerBackend_Tags.BrowserExtension;
  };

  /**
   * Browser extension (NIP07)
   *
   * <https://github.com/nostr-protocol/nips/blob/master/07.md>
   */
  class BrowserExtension_
    extends UniffiEnum
    implements BrowserExtension__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SignerBackend';
    readonly tag = SignerBackend_Tags.BrowserExtension;
    constructor() {
      super('SignerBackend', 'BrowserExtension');
    }

    static new(): BrowserExtension_ {
      return new BrowserExtension_();
    }

    static instanceOf(obj: any): obj is BrowserExtension_ {
      return obj.tag === SignerBackend_Tags.BrowserExtension;
    }
  }

  type NostrConnect__interface = {
    tag: SignerBackend_Tags.NostrConnect;
  };

  /**
   * Nostr Connect (NIP46)
   *
   * <https://github.com/nostr-protocol/nips/blob/master/46.md>
   */
  class NostrConnect_ extends UniffiEnum implements NostrConnect__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SignerBackend';
    readonly tag = SignerBackend_Tags.NostrConnect;
    constructor() {
      super('SignerBackend', 'NostrConnect');
    }

    static new(): NostrConnect_ {
      return new NostrConnect_();
    }

    static instanceOf(obj: any): obj is NostrConnect_ {
      return obj.tag === SignerBackend_Tags.NostrConnect;
    }
  }

  type Custom__interface = {
    tag: SignerBackend_Tags.Custom;
    inner: Readonly<{ backend: string }>;
  };

  /**
   * Custom
   */
  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SignerBackend';
    readonly tag = SignerBackend_Tags.Custom;
    readonly inner: Readonly<{ backend: string }>;
    constructor(inner: { backend: string }) {
      super('SignerBackend', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { backend: string }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === SignerBackend_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is SignerBackend {
    return obj[uniffiTypeNameSymbol] === 'SignerBackend';
  }

  return Object.freeze({
    instanceOf,
    Keys: Keys_,
    BrowserExtension: BrowserExtension_,
    NostrConnect: NostrConnect_,
    Custom: Custom_,
  });
})();

export type SignerBackend = InstanceType<
  (typeof SignerBackend)[keyof Omit<typeof SignerBackend, 'instanceOf'>]
>;

// FfiConverter for enum SignerBackend
const FfiConverterTypeSignerBackend = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SignerBackend;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SignerBackend.Keys();
        case 2:
          return new SignerBackend.BrowserExtension();
        case 3:
          return new SignerBackend.NostrConnect();
        case 4:
          return new SignerBackend.Custom({
            backend: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SignerBackend_Tags.Keys: {
          ordinalConverter.write(1, into);
          return;
        }
        case SignerBackend_Tags.BrowserExtension: {
          ordinalConverter.write(2, into);
          return;
        }
        case SignerBackend_Tags.NostrConnect: {
          ordinalConverter.write(3, into);
          return;
        }
        case SignerBackend_Tags.Custom: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.backend, into);
          return;
        }
        default:
          // Throwing from here means that SignerBackend_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SignerBackend_Tags.Keys: {
          return ordinalConverter.allocationSize(1);
        }
        case SignerBackend_Tags.BrowserExtension: {
          return ordinalConverter.allocationSize(2);
        }
        case SignerBackend_Tags.NostrConnect: {
          return ordinalConverter.allocationSize(3);
        }
        case SignerBackend_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.backend);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum SyncDirection {
  Up,
  Down,
  Both,
}

const FfiConverterTypeSyncDirection = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SyncDirection;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return SyncDirection.Up;
        case 2:
          return SyncDirection.Down;
        case 3:
          return SyncDirection.Both;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case SyncDirection.Up:
          return ordinalConverter.write(1, into);
        case SyncDirection.Down:
          return ordinalConverter.write(2, into);
        case SyncDirection.Both:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: TagKind
export enum TagKind_Tags {
  Alt = 'Alt',
  Client = 'Client',
  Clone = 'Clone',
  Commit = 'Commit',
  Maintainers = 'Maintainers',
  Protected = 'Protected',
  RelayUrl = 'RelayUrl',
  Nonce = 'Nonce',
  Delegation = 'Delegation',
  ContentWarning = 'ContentWarning',
  Expiration = 'Expiration',
  Subject = 'Subject',
  Challenge = 'Challenge',
  Title = 'Title',
  Image = 'Image',
  Thumb = 'Thumb',
  Summary = 'Summary',
  PublishedAt = 'PublishedAt',
  Description = 'Description',
  Bolt11 = 'Bolt11',
  Preimage = 'Preimage',
  Relays = 'Relays',
  Amount = 'Amount',
  Lnurl = 'Lnurl',
  MlsProtocolVersion = 'MlsProtocolVersion',
  MlsCiphersuite = 'MlsCiphersuite',
  MlsExtensions = 'MlsExtensions',
  Name = 'Name',
  Url = 'Url',
  Aes256Gcm = 'Aes256Gcm',
  Size = 'Size',
  Dim = 'Dim',
  File = 'File',
  Magnet = 'Magnet',
  Blurhash = 'Blurhash',
  Streaming = 'Streaming',
  Recording = 'Recording',
  Starts = 'Starts',
  Ends = 'Ends',
  Status = 'Status',
  CurrentParticipants = 'CurrentParticipants',
  TotalParticipants = 'TotalParticipants',
  Tracker = 'Tracker',
  Method = 'Method',
  Payload = 'Payload',
  Anon = 'Anon',
  Proxy = 'Proxy',
  Emoji = 'Emoji',
  Encrypted = 'Encrypted',
  Request = 'Request',
  Web = 'Web',
  Word = 'Word',
  SingleLetter = 'SingleLetter',
  Unknown = 'Unknown',
}
export const TagKind = (() => {
  type Alt__interface = {
    tag: TagKind_Tags.Alt;
  };

  /**
   * Human-readable plaintext summary of what that event is about
   *
   * <https://github.com/nostr-protocol/nips/blob/master/31.md>
   */
  class Alt_ extends UniffiEnum implements Alt__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Alt;
    constructor() {
      super('TagKind', 'Alt');
    }

    static new(): Alt_ {
      return new Alt_();
    }

    static instanceOf(obj: any): obj is Alt_ {
      return obj.tag === TagKind_Tags.Alt;
    }
  }

  type Client__interface = {
    tag: TagKind_Tags.Client;
  };

  /**
   * Client
   *
   * <https://github.com/nostr-protocol/nips/blob/master/89.md>
   */
  class Client_ extends UniffiEnum implements Client__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Client;
    constructor() {
      super('TagKind', 'Client');
    }

    static new(): Client_ {
      return new Client_();
    }

    static instanceOf(obj: any): obj is Client_ {
      return obj.tag === TagKind_Tags.Client;
    }
  }

  type Clone__interface = {
    tag: TagKind_Tags.Clone;
  };

  class Clone_ extends UniffiEnum implements Clone__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Clone;
    constructor() {
      super('TagKind', 'Clone');
    }

    static new(): Clone_ {
      return new Clone_();
    }

    static instanceOf(obj: any): obj is Clone_ {
      return obj.tag === TagKind_Tags.Clone;
    }
  }

  type Commit__interface = {
    tag: TagKind_Tags.Commit;
  };

  /**
   * Commit
   *
   * <https://github.com/nostr-protocol/nips/blob/master/34.md>
   */
  class Commit_ extends UniffiEnum implements Commit__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Commit;
    constructor() {
      super('TagKind', 'Commit');
    }

    static new(): Commit_ {
      return new Commit_();
    }

    static instanceOf(obj: any): obj is Commit_ {
      return obj.tag === TagKind_Tags.Commit;
    }
  }

  type Maintainers__interface = {
    tag: TagKind_Tags.Maintainers;
  };

  /**
   * Maintainers
   */
  class Maintainers_ extends UniffiEnum implements Maintainers__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Maintainers;
    constructor() {
      super('TagKind', 'Maintainers');
    }

    static new(): Maintainers_ {
      return new Maintainers_();
    }

    static instanceOf(obj: any): obj is Maintainers_ {
      return obj.tag === TagKind_Tags.Maintainers;
    }
  }

  type Protected__interface = {
    tag: TagKind_Tags.Protected;
  };

  /**
   * Protected event
   *
   * <https://github.com/nostr-protocol/nips/blob/master/70.md>
   */
  class Protected_ extends UniffiEnum implements Protected__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Protected;
    constructor() {
      super('TagKind', 'Protected');
    }

    static new(): Protected_ {
      return new Protected_();
    }

    static instanceOf(obj: any): obj is Protected_ {
      return obj.tag === TagKind_Tags.Protected;
    }
  }

  type RelayUrl__interface = {
    tag: TagKind_Tags.RelayUrl;
  };

  /**
   * Relay
   */
  class RelayUrl_ extends UniffiEnum implements RelayUrl__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.RelayUrl;
    constructor() {
      super('TagKind', 'RelayUrl');
    }

    static new(): RelayUrl_ {
      return new RelayUrl_();
    }

    static instanceOf(obj: any): obj is RelayUrl_ {
      return obj.tag === TagKind_Tags.RelayUrl;
    }
  }

  type Nonce__interface = {
    tag: TagKind_Tags.Nonce;
  };

  /**
   * Nonce
   */
  class Nonce_ extends UniffiEnum implements Nonce__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Nonce;
    constructor() {
      super('TagKind', 'Nonce');
    }

    static new(): Nonce_ {
      return new Nonce_();
    }

    static instanceOf(obj: any): obj is Nonce_ {
      return obj.tag === TagKind_Tags.Nonce;
    }
  }

  type Delegation__interface = {
    tag: TagKind_Tags.Delegation;
  };

  /**
   * Delegation
   */
  class Delegation_ extends UniffiEnum implements Delegation__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Delegation;
    constructor() {
      super('TagKind', 'Delegation');
    }

    static new(): Delegation_ {
      return new Delegation_();
    }

    static instanceOf(obj: any): obj is Delegation_ {
      return obj.tag === TagKind_Tags.Delegation;
    }
  }

  type ContentWarning__interface = {
    tag: TagKind_Tags.ContentWarning;
  };

  /**
   * Content warning
   */
  class ContentWarning_
    extends UniffiEnum
    implements ContentWarning__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.ContentWarning;
    constructor() {
      super('TagKind', 'ContentWarning');
    }

    static new(): ContentWarning_ {
      return new ContentWarning_();
    }

    static instanceOf(obj: any): obj is ContentWarning_ {
      return obj.tag === TagKind_Tags.ContentWarning;
    }
  }

  type Expiration__interface = {
    tag: TagKind_Tags.Expiration;
  };

  /**
   * Expiration
   */
  class Expiration_ extends UniffiEnum implements Expiration__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Expiration;
    constructor() {
      super('TagKind', 'Expiration');
    }

    static new(): Expiration_ {
      return new Expiration_();
    }

    static instanceOf(obj: any): obj is Expiration_ {
      return obj.tag === TagKind_Tags.Expiration;
    }
  }

  type Subject__interface = {
    tag: TagKind_Tags.Subject;
  };

  /**
   * Subject
   */
  class Subject_ extends UniffiEnum implements Subject__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Subject;
    constructor() {
      super('TagKind', 'Subject');
    }

    static new(): Subject_ {
      return new Subject_();
    }

    static instanceOf(obj: any): obj is Subject_ {
      return obj.tag === TagKind_Tags.Subject;
    }
  }

  type Challenge__interface = {
    tag: TagKind_Tags.Challenge;
  };

  /**
   * Auth challenge
   */
  class Challenge_ extends UniffiEnum implements Challenge__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Challenge;
    constructor() {
      super('TagKind', 'Challenge');
    }

    static new(): Challenge_ {
      return new Challenge_();
    }

    static instanceOf(obj: any): obj is Challenge_ {
      return obj.tag === TagKind_Tags.Challenge;
    }
  }

  type Title__interface = {
    tag: TagKind_Tags.Title;
  };

  /**
   * Title (NIP23)
   */
  class Title_ extends UniffiEnum implements Title__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Title;
    constructor() {
      super('TagKind', 'Title');
    }

    static new(): Title_ {
      return new Title_();
    }

    static instanceOf(obj: any): obj is Title_ {
      return obj.tag === TagKind_Tags.Title;
    }
  }

  type Image__interface = {
    tag: TagKind_Tags.Image;
  };

  /**
   * Image (NIP23)
   */
  class Image_ extends UniffiEnum implements Image__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Image;
    constructor() {
      super('TagKind', 'Image');
    }

    static new(): Image_ {
      return new Image_();
    }

    static instanceOf(obj: any): obj is Image_ {
      return obj.tag === TagKind_Tags.Image;
    }
  }

  type Thumb__interface = {
    tag: TagKind_Tags.Thumb;
  };

  /**
   * Thumbnail
   */
  class Thumb_ extends UniffiEnum implements Thumb__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Thumb;
    constructor() {
      super('TagKind', 'Thumb');
    }

    static new(): Thumb_ {
      return new Thumb_();
    }

    static instanceOf(obj: any): obj is Thumb_ {
      return obj.tag === TagKind_Tags.Thumb;
    }
  }

  type Summary__interface = {
    tag: TagKind_Tags.Summary;
  };

  /**
   * Summary (NIP23)
   */
  class Summary_ extends UniffiEnum implements Summary__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Summary;
    constructor() {
      super('TagKind', 'Summary');
    }

    static new(): Summary_ {
      return new Summary_();
    }

    static instanceOf(obj: any): obj is Summary_ {
      return obj.tag === TagKind_Tags.Summary;
    }
  }

  type PublishedAt__interface = {
    tag: TagKind_Tags.PublishedAt;
  };

  /**
   * PublishedAt (NIP23)
   */
  class PublishedAt_ extends UniffiEnum implements PublishedAt__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.PublishedAt;
    constructor() {
      super('TagKind', 'PublishedAt');
    }

    static new(): PublishedAt_ {
      return new PublishedAt_();
    }

    static instanceOf(obj: any): obj is PublishedAt_ {
      return obj.tag === TagKind_Tags.PublishedAt;
    }
  }

  type Description__interface = {
    tag: TagKind_Tags.Description;
  };

  /**
   * Description (NIP57)
   */
  class Description_ extends UniffiEnum implements Description__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Description;
    constructor() {
      super('TagKind', 'Description');
    }

    static new(): Description_ {
      return new Description_();
    }

    static instanceOf(obj: any): obj is Description_ {
      return obj.tag === TagKind_Tags.Description;
    }
  }

  type Bolt11__interface = {
    tag: TagKind_Tags.Bolt11;
  };

  /**
   * Bolt11 Invoice (NIP57)
   */
  class Bolt11_ extends UniffiEnum implements Bolt11__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Bolt11;
    constructor() {
      super('TagKind', 'Bolt11');
    }

    static new(): Bolt11_ {
      return new Bolt11_();
    }

    static instanceOf(obj: any): obj is Bolt11_ {
      return obj.tag === TagKind_Tags.Bolt11;
    }
  }

  type Preimage__interface = {
    tag: TagKind_Tags.Preimage;
  };

  /**
   * Preimage (NIP57)
   */
  class Preimage_ extends UniffiEnum implements Preimage__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Preimage;
    constructor() {
      super('TagKind', 'Preimage');
    }

    static new(): Preimage_ {
      return new Preimage_();
    }

    static instanceOf(obj: any): obj is Preimage_ {
      return obj.tag === TagKind_Tags.Preimage;
    }
  }

  type Relays__interface = {
    tag: TagKind_Tags.Relays;
  };

  /**
   * Relays (NIP57)
   */
  class Relays_ extends UniffiEnum implements Relays__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Relays;
    constructor() {
      super('TagKind', 'Relays');
    }

    static new(): Relays_ {
      return new Relays_();
    }

    static instanceOf(obj: any): obj is Relays_ {
      return obj.tag === TagKind_Tags.Relays;
    }
  }

  type Amount__interface = {
    tag: TagKind_Tags.Amount;
  };

  /**
   * Amount (NIP57)
   */
  class Amount_ extends UniffiEnum implements Amount__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Amount;
    constructor() {
      super('TagKind', 'Amount');
    }

    static new(): Amount_ {
      return new Amount_();
    }

    static instanceOf(obj: any): obj is Amount_ {
      return obj.tag === TagKind_Tags.Amount;
    }
  }

  type Lnurl__interface = {
    tag: TagKind_Tags.Lnurl;
  };

  /**
   * Lnurl (NIP57)
   */
  class Lnurl_ extends UniffiEnum implements Lnurl__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Lnurl;
    constructor() {
      super('TagKind', 'Lnurl');
    }

    static new(): Lnurl_ {
      return new Lnurl_();
    }

    static instanceOf(obj: any): obj is Lnurl_ {
      return obj.tag === TagKind_Tags.Lnurl;
    }
  }

  type MlsProtocolVersion__interface = {
    tag: TagKind_Tags.MlsProtocolVersion;
  };

  /**
   * MLS Protocol Version (NIP104)
   */
  class MlsProtocolVersion_
    extends UniffiEnum
    implements MlsProtocolVersion__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.MlsProtocolVersion;
    constructor() {
      super('TagKind', 'MlsProtocolVersion');
    }

    static new(): MlsProtocolVersion_ {
      return new MlsProtocolVersion_();
    }

    static instanceOf(obj: any): obj is MlsProtocolVersion_ {
      return obj.tag === TagKind_Tags.MlsProtocolVersion;
    }
  }

  type MlsCiphersuite__interface = {
    tag: TagKind_Tags.MlsCiphersuite;
  };

  /**
   * MLS Cipher Suite (NIP104)
   */
  class MlsCiphersuite_
    extends UniffiEnum
    implements MlsCiphersuite__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.MlsCiphersuite;
    constructor() {
      super('TagKind', 'MlsCiphersuite');
    }

    static new(): MlsCiphersuite_ {
      return new MlsCiphersuite_();
    }

    static instanceOf(obj: any): obj is MlsCiphersuite_ {
      return obj.tag === TagKind_Tags.MlsCiphersuite;
    }
  }

  type MlsExtensions__interface = {
    tag: TagKind_Tags.MlsExtensions;
  };

  /**
   * MLS Extensions (NIP104)
   */
  class MlsExtensions_ extends UniffiEnum implements MlsExtensions__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.MlsExtensions;
    constructor() {
      super('TagKind', 'MlsExtensions');
    }

    static new(): MlsExtensions_ {
      return new MlsExtensions_();
    }

    static instanceOf(obj: any): obj is MlsExtensions_ {
      return obj.tag === TagKind_Tags.MlsExtensions;
    }
  }

  type Name__interface = {
    tag: TagKind_Tags.Name;
  };

  /**
   * Name tag
   */
  class Name_ extends UniffiEnum implements Name__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Name;
    constructor() {
      super('TagKind', 'Name');
    }

    static new(): Name_ {
      return new Name_();
    }

    static instanceOf(obj: any): obj is Name_ {
      return obj.tag === TagKind_Tags.Name;
    }
  }

  type Url__interface = {
    tag: TagKind_Tags.Url;
  };

  /**
   * Url
   */
  class Url_ extends UniffiEnum implements Url__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Url;
    constructor() {
      super('TagKind', 'Url');
    }

    static new(): Url_ {
      return new Url_();
    }

    static instanceOf(obj: any): obj is Url_ {
      return obj.tag === TagKind_Tags.Url;
    }
  }

  type Aes256Gcm__interface = {
    tag: TagKind_Tags.Aes256Gcm;
  };

  /**
   * AES 256 GCM
   */
  class Aes256Gcm_ extends UniffiEnum implements Aes256Gcm__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Aes256Gcm;
    constructor() {
      super('TagKind', 'Aes256Gcm');
    }

    static new(): Aes256Gcm_ {
      return new Aes256Gcm_();
    }

    static instanceOf(obj: any): obj is Aes256Gcm_ {
      return obj.tag === TagKind_Tags.Aes256Gcm;
    }
  }

  type Size__interface = {
    tag: TagKind_Tags.Size;
  };

  /**
   * Size of file in bytes
   */
  class Size_ extends UniffiEnum implements Size__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Size;
    constructor() {
      super('TagKind', 'Size');
    }

    static new(): Size_ {
      return new Size_();
    }

    static instanceOf(obj: any): obj is Size_ {
      return obj.tag === TagKind_Tags.Size;
    }
  }

  type Dim__interface = {
    tag: TagKind_Tags.Dim;
  };

  /**
   * Size of file in pixels
   */
  class Dim_ extends UniffiEnum implements Dim__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Dim;
    constructor() {
      super('TagKind', 'Dim');
    }

    static new(): Dim_ {
      return new Dim_();
    }

    static instanceOf(obj: any): obj is Dim_ {
      return obj.tag === TagKind_Tags.Dim;
    }
  }

  type File__interface = {
    tag: TagKind_Tags.File;
  };

  class File_ extends UniffiEnum implements File__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.File;
    constructor() {
      super('TagKind', 'File');
    }

    static new(): File_ {
      return new File_();
    }

    static instanceOf(obj: any): obj is File_ {
      return obj.tag === TagKind_Tags.File;
    }
  }

  type Magnet__interface = {
    tag: TagKind_Tags.Magnet;
  };

  /**
   * Magnet
   */
  class Magnet_ extends UniffiEnum implements Magnet__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Magnet;
    constructor() {
      super('TagKind', 'Magnet');
    }

    static new(): Magnet_ {
      return new Magnet_();
    }

    static instanceOf(obj: any): obj is Magnet_ {
      return obj.tag === TagKind_Tags.Magnet;
    }
  }

  type Blurhash__interface = {
    tag: TagKind_Tags.Blurhash;
  };

  /**
   * Blurhash
   */
  class Blurhash_ extends UniffiEnum implements Blurhash__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Blurhash;
    constructor() {
      super('TagKind', 'Blurhash');
    }

    static new(): Blurhash_ {
      return new Blurhash_();
    }

    static instanceOf(obj: any): obj is Blurhash_ {
      return obj.tag === TagKind_Tags.Blurhash;
    }
  }

  type Streaming__interface = {
    tag: TagKind_Tags.Streaming;
  };

  /**
   * Streaming
   */
  class Streaming_ extends UniffiEnum implements Streaming__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Streaming;
    constructor() {
      super('TagKind', 'Streaming');
    }

    static new(): Streaming_ {
      return new Streaming_();
    }

    static instanceOf(obj: any): obj is Streaming_ {
      return obj.tag === TagKind_Tags.Streaming;
    }
  }

  type Recording__interface = {
    tag: TagKind_Tags.Recording;
  };

  /**
   * Recording
   */
  class Recording_ extends UniffiEnum implements Recording__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Recording;
    constructor() {
      super('TagKind', 'Recording');
    }

    static new(): Recording_ {
      return new Recording_();
    }

    static instanceOf(obj: any): obj is Recording_ {
      return obj.tag === TagKind_Tags.Recording;
    }
  }

  type Starts__interface = {
    tag: TagKind_Tags.Starts;
  };

  /**
   * Starts
   */
  class Starts_ extends UniffiEnum implements Starts__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Starts;
    constructor() {
      super('TagKind', 'Starts');
    }

    static new(): Starts_ {
      return new Starts_();
    }

    static instanceOf(obj: any): obj is Starts_ {
      return obj.tag === TagKind_Tags.Starts;
    }
  }

  type Ends__interface = {
    tag: TagKind_Tags.Ends;
  };

  /**
   * Ends
   */
  class Ends_ extends UniffiEnum implements Ends__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Ends;
    constructor() {
      super('TagKind', 'Ends');
    }

    static new(): Ends_ {
      return new Ends_();
    }

    static instanceOf(obj: any): obj is Ends_ {
      return obj.tag === TagKind_Tags.Ends;
    }
  }

  type Status__interface = {
    tag: TagKind_Tags.Status;
  };

  /**
   * Status
   */
  class Status_ extends UniffiEnum implements Status__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Status;
    constructor() {
      super('TagKind', 'Status');
    }

    static new(): Status_ {
      return new Status_();
    }

    static instanceOf(obj: any): obj is Status_ {
      return obj.tag === TagKind_Tags.Status;
    }
  }

  type CurrentParticipants__interface = {
    tag: TagKind_Tags.CurrentParticipants;
  };

  /**
   * Current participants
   */
  class CurrentParticipants_
    extends UniffiEnum
    implements CurrentParticipants__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.CurrentParticipants;
    constructor() {
      super('TagKind', 'CurrentParticipants');
    }

    static new(): CurrentParticipants_ {
      return new CurrentParticipants_();
    }

    static instanceOf(obj: any): obj is CurrentParticipants_ {
      return obj.tag === TagKind_Tags.CurrentParticipants;
    }
  }

  type TotalParticipants__interface = {
    tag: TagKind_Tags.TotalParticipants;
  };

  /**
   * Total participants
   */
  class TotalParticipants_
    extends UniffiEnum
    implements TotalParticipants__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.TotalParticipants;
    constructor() {
      super('TagKind', 'TotalParticipants');
    }

    static new(): TotalParticipants_ {
      return new TotalParticipants_();
    }

    static instanceOf(obj: any): obj is TotalParticipants_ {
      return obj.tag === TagKind_Tags.TotalParticipants;
    }
  }

  type Tracker__interface = {
    tag: TagKind_Tags.Tracker;
  };

  class Tracker_ extends UniffiEnum implements Tracker__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Tracker;
    constructor() {
      super('TagKind', 'Tracker');
    }

    static new(): Tracker_ {
      return new Tracker_();
    }

    static instanceOf(obj: any): obj is Tracker_ {
      return obj.tag === TagKind_Tags.Tracker;
    }
  }

  type Method__interface = {
    tag: TagKind_Tags.Method;
  };

  /**
   * HTTP Method Request
   */
  class Method_ extends UniffiEnum implements Method__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Method;
    constructor() {
      super('TagKind', 'Method');
    }

    static new(): Method_ {
      return new Method_();
    }

    static instanceOf(obj: any): obj is Method_ {
      return obj.tag === TagKind_Tags.Method;
    }
  }

  type Payload__interface = {
    tag: TagKind_Tags.Payload;
  };

  /**
   * Payload HASH
   */
  class Payload_ extends UniffiEnum implements Payload__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Payload;
    constructor() {
      super('TagKind', 'Payload');
    }

    static new(): Payload_ {
      return new Payload_();
    }

    static instanceOf(obj: any): obj is Payload_ {
      return obj.tag === TagKind_Tags.Payload;
    }
  }

  type Anon__interface = {
    tag: TagKind_Tags.Anon;
  };

  class Anon_ extends UniffiEnum implements Anon__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Anon;
    constructor() {
      super('TagKind', 'Anon');
    }

    static new(): Anon_ {
      return new Anon_();
    }

    static instanceOf(obj: any): obj is Anon_ {
      return obj.tag === TagKind_Tags.Anon;
    }
  }

  type Proxy__interface = {
    tag: TagKind_Tags.Proxy;
  };

  class Proxy_ extends UniffiEnum implements Proxy__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Proxy;
    constructor() {
      super('TagKind', 'Proxy');
    }

    static new(): Proxy_ {
      return new Proxy_();
    }

    static instanceOf(obj: any): obj is Proxy_ {
      return obj.tag === TagKind_Tags.Proxy;
    }
  }

  type Emoji__interface = {
    tag: TagKind_Tags.Emoji;
  };

  class Emoji_ extends UniffiEnum implements Emoji__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Emoji;
    constructor() {
      super('TagKind', 'Emoji');
    }

    static new(): Emoji_ {
      return new Emoji_();
    }

    static instanceOf(obj: any): obj is Emoji_ {
      return obj.tag === TagKind_Tags.Emoji;
    }
  }

  type Encrypted__interface = {
    tag: TagKind_Tags.Encrypted;
  };

  /**
   * Encrypted
   */
  class Encrypted_ extends UniffiEnum implements Encrypted__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Encrypted;
    constructor() {
      super('TagKind', 'Encrypted');
    }

    static new(): Encrypted_ {
      return new Encrypted_();
    }

    static instanceOf(obj: any): obj is Encrypted_ {
      return obj.tag === TagKind_Tags.Encrypted;
    }
  }

  type Request__interface = {
    tag: TagKind_Tags.Request;
  };

  class Request_ extends UniffiEnum implements Request__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Request;
    constructor() {
      super('TagKind', 'Request');
    }

    static new(): Request_ {
      return new Request_();
    }

    static instanceOf(obj: any): obj is Request_ {
      return obj.tag === TagKind_Tags.Request;
    }
  }

  type Web__interface = {
    tag: TagKind_Tags.Web;
  };

  class Web_ extends UniffiEnum implements Web__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Web;
    constructor() {
      super('TagKind', 'Web');
    }

    static new(): Web_ {
      return new Web_();
    }

    static instanceOf(obj: any): obj is Web_ {
      return obj.tag === TagKind_Tags.Web;
    }
  }

  type Word__interface = {
    tag: TagKind_Tags.Word;
  };

  class Word_ extends UniffiEnum implements Word__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Word;
    constructor() {
      super('TagKind', 'Word');
    }

    static new(): Word_ {
      return new Word_();
    }

    static instanceOf(obj: any): obj is Word_ {
      return obj.tag === TagKind_Tags.Word;
    }
  }

  type SingleLetter__interface = {
    tag: TagKind_Tags.SingleLetter;
    inner: Readonly<{ singleLetter: SingleLetterTagInterface }>;
  };

  class SingleLetter_ extends UniffiEnum implements SingleLetter__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.SingleLetter;
    readonly inner: Readonly<{ singleLetter: SingleLetterTagInterface }>;
    constructor(inner: { singleLetter: SingleLetterTagInterface }) {
      super('TagKind', 'SingleLetter');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      singleLetter: SingleLetterTagInterface;
    }): SingleLetter_ {
      return new SingleLetter_(inner);
    }

    static instanceOf(obj: any): obj is SingleLetter_ {
      return obj.tag === TagKind_Tags.SingleLetter;
    }
  }

  type Unknown__interface = {
    tag: TagKind_Tags.Unknown;
    inner: Readonly<{ unknown: string }>;
  };

  class Unknown_ extends UniffiEnum implements Unknown__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagKind';
    readonly tag = TagKind_Tags.Unknown;
    readonly inner: Readonly<{ unknown: string }>;
    constructor(inner: { unknown: string }) {
      super('TagKind', 'Unknown');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { unknown: string }): Unknown_ {
      return new Unknown_(inner);
    }

    static instanceOf(obj: any): obj is Unknown_ {
      return obj.tag === TagKind_Tags.Unknown;
    }
  }

  function instanceOf(obj: any): obj is TagKind {
    return obj[uniffiTypeNameSymbol] === 'TagKind';
  }

  return Object.freeze({
    instanceOf,
    Alt: Alt_,
    Client: Client_,
    Clone: Clone_,
    Commit: Commit_,
    Maintainers: Maintainers_,
    Protected: Protected_,
    RelayUrl: RelayUrl_,
    Nonce: Nonce_,
    Delegation: Delegation_,
    ContentWarning: ContentWarning_,
    Expiration: Expiration_,
    Subject: Subject_,
    Challenge: Challenge_,
    Title: Title_,
    Image: Image_,
    Thumb: Thumb_,
    Summary: Summary_,
    PublishedAt: PublishedAt_,
    Description: Description_,
    Bolt11: Bolt11_,
    Preimage: Preimage_,
    Relays: Relays_,
    Amount: Amount_,
    Lnurl: Lnurl_,
    MlsProtocolVersion: MlsProtocolVersion_,
    MlsCiphersuite: MlsCiphersuite_,
    MlsExtensions: MlsExtensions_,
    Name: Name_,
    Url: Url_,
    Aes256Gcm: Aes256Gcm_,
    Size: Size_,
    Dim: Dim_,
    File: File_,
    Magnet: Magnet_,
    Blurhash: Blurhash_,
    Streaming: Streaming_,
    Recording: Recording_,
    Starts: Starts_,
    Ends: Ends_,
    Status: Status_,
    CurrentParticipants: CurrentParticipants_,
    TotalParticipants: TotalParticipants_,
    Tracker: Tracker_,
    Method: Method_,
    Payload: Payload_,
    Anon: Anon_,
    Proxy: Proxy_,
    Emoji: Emoji_,
    Encrypted: Encrypted_,
    Request: Request_,
    Web: Web_,
    Word: Word_,
    SingleLetter: SingleLetter_,
    Unknown: Unknown_,
  });
})();

export type TagKind = InstanceType<
  (typeof TagKind)[keyof Omit<typeof TagKind, 'instanceOf'>]
>;

// FfiConverter for enum TagKind
const FfiConverterTypeTagKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TagKind;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new TagKind.Alt();
        case 2:
          return new TagKind.Client();
        case 3:
          return new TagKind.Clone();
        case 4:
          return new TagKind.Commit();
        case 5:
          return new TagKind.Maintainers();
        case 6:
          return new TagKind.Protected();
        case 7:
          return new TagKind.RelayUrl();
        case 8:
          return new TagKind.Nonce();
        case 9:
          return new TagKind.Delegation();
        case 10:
          return new TagKind.ContentWarning();
        case 11:
          return new TagKind.Expiration();
        case 12:
          return new TagKind.Subject();
        case 13:
          return new TagKind.Challenge();
        case 14:
          return new TagKind.Title();
        case 15:
          return new TagKind.Image();
        case 16:
          return new TagKind.Thumb();
        case 17:
          return new TagKind.Summary();
        case 18:
          return new TagKind.PublishedAt();
        case 19:
          return new TagKind.Description();
        case 20:
          return new TagKind.Bolt11();
        case 21:
          return new TagKind.Preimage();
        case 22:
          return new TagKind.Relays();
        case 23:
          return new TagKind.Amount();
        case 24:
          return new TagKind.Lnurl();
        case 25:
          return new TagKind.MlsProtocolVersion();
        case 26:
          return new TagKind.MlsCiphersuite();
        case 27:
          return new TagKind.MlsExtensions();
        case 28:
          return new TagKind.Name();
        case 29:
          return new TagKind.Url();
        case 30:
          return new TagKind.Aes256Gcm();
        case 31:
          return new TagKind.Size();
        case 32:
          return new TagKind.Dim();
        case 33:
          return new TagKind.File();
        case 34:
          return new TagKind.Magnet();
        case 35:
          return new TagKind.Blurhash();
        case 36:
          return new TagKind.Streaming();
        case 37:
          return new TagKind.Recording();
        case 38:
          return new TagKind.Starts();
        case 39:
          return new TagKind.Ends();
        case 40:
          return new TagKind.Status();
        case 41:
          return new TagKind.CurrentParticipants();
        case 42:
          return new TagKind.TotalParticipants();
        case 43:
          return new TagKind.Tracker();
        case 44:
          return new TagKind.Method();
        case 45:
          return new TagKind.Payload();
        case 46:
          return new TagKind.Anon();
        case 47:
          return new TagKind.Proxy();
        case 48:
          return new TagKind.Emoji();
        case 49:
          return new TagKind.Encrypted();
        case 50:
          return new TagKind.Request();
        case 51:
          return new TagKind.Web();
        case 52:
          return new TagKind.Word();
        case 53:
          return new TagKind.SingleLetter({
            singleLetter: FfiConverterTypeSingleLetterTag.read(from),
          });
        case 54:
          return new TagKind.Unknown({
            unknown: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case TagKind_Tags.Alt: {
          ordinalConverter.write(1, into);
          return;
        }
        case TagKind_Tags.Client: {
          ordinalConverter.write(2, into);
          return;
        }
        case TagKind_Tags.Clone: {
          ordinalConverter.write(3, into);
          return;
        }
        case TagKind_Tags.Commit: {
          ordinalConverter.write(4, into);
          return;
        }
        case TagKind_Tags.Maintainers: {
          ordinalConverter.write(5, into);
          return;
        }
        case TagKind_Tags.Protected: {
          ordinalConverter.write(6, into);
          return;
        }
        case TagKind_Tags.RelayUrl: {
          ordinalConverter.write(7, into);
          return;
        }
        case TagKind_Tags.Nonce: {
          ordinalConverter.write(8, into);
          return;
        }
        case TagKind_Tags.Delegation: {
          ordinalConverter.write(9, into);
          return;
        }
        case TagKind_Tags.ContentWarning: {
          ordinalConverter.write(10, into);
          return;
        }
        case TagKind_Tags.Expiration: {
          ordinalConverter.write(11, into);
          return;
        }
        case TagKind_Tags.Subject: {
          ordinalConverter.write(12, into);
          return;
        }
        case TagKind_Tags.Challenge: {
          ordinalConverter.write(13, into);
          return;
        }
        case TagKind_Tags.Title: {
          ordinalConverter.write(14, into);
          return;
        }
        case TagKind_Tags.Image: {
          ordinalConverter.write(15, into);
          return;
        }
        case TagKind_Tags.Thumb: {
          ordinalConverter.write(16, into);
          return;
        }
        case TagKind_Tags.Summary: {
          ordinalConverter.write(17, into);
          return;
        }
        case TagKind_Tags.PublishedAt: {
          ordinalConverter.write(18, into);
          return;
        }
        case TagKind_Tags.Description: {
          ordinalConverter.write(19, into);
          return;
        }
        case TagKind_Tags.Bolt11: {
          ordinalConverter.write(20, into);
          return;
        }
        case TagKind_Tags.Preimage: {
          ordinalConverter.write(21, into);
          return;
        }
        case TagKind_Tags.Relays: {
          ordinalConverter.write(22, into);
          return;
        }
        case TagKind_Tags.Amount: {
          ordinalConverter.write(23, into);
          return;
        }
        case TagKind_Tags.Lnurl: {
          ordinalConverter.write(24, into);
          return;
        }
        case TagKind_Tags.MlsProtocolVersion: {
          ordinalConverter.write(25, into);
          return;
        }
        case TagKind_Tags.MlsCiphersuite: {
          ordinalConverter.write(26, into);
          return;
        }
        case TagKind_Tags.MlsExtensions: {
          ordinalConverter.write(27, into);
          return;
        }
        case TagKind_Tags.Name: {
          ordinalConverter.write(28, into);
          return;
        }
        case TagKind_Tags.Url: {
          ordinalConverter.write(29, into);
          return;
        }
        case TagKind_Tags.Aes256Gcm: {
          ordinalConverter.write(30, into);
          return;
        }
        case TagKind_Tags.Size: {
          ordinalConverter.write(31, into);
          return;
        }
        case TagKind_Tags.Dim: {
          ordinalConverter.write(32, into);
          return;
        }
        case TagKind_Tags.File: {
          ordinalConverter.write(33, into);
          return;
        }
        case TagKind_Tags.Magnet: {
          ordinalConverter.write(34, into);
          return;
        }
        case TagKind_Tags.Blurhash: {
          ordinalConverter.write(35, into);
          return;
        }
        case TagKind_Tags.Streaming: {
          ordinalConverter.write(36, into);
          return;
        }
        case TagKind_Tags.Recording: {
          ordinalConverter.write(37, into);
          return;
        }
        case TagKind_Tags.Starts: {
          ordinalConverter.write(38, into);
          return;
        }
        case TagKind_Tags.Ends: {
          ordinalConverter.write(39, into);
          return;
        }
        case TagKind_Tags.Status: {
          ordinalConverter.write(40, into);
          return;
        }
        case TagKind_Tags.CurrentParticipants: {
          ordinalConverter.write(41, into);
          return;
        }
        case TagKind_Tags.TotalParticipants: {
          ordinalConverter.write(42, into);
          return;
        }
        case TagKind_Tags.Tracker: {
          ordinalConverter.write(43, into);
          return;
        }
        case TagKind_Tags.Method: {
          ordinalConverter.write(44, into);
          return;
        }
        case TagKind_Tags.Payload: {
          ordinalConverter.write(45, into);
          return;
        }
        case TagKind_Tags.Anon: {
          ordinalConverter.write(46, into);
          return;
        }
        case TagKind_Tags.Proxy: {
          ordinalConverter.write(47, into);
          return;
        }
        case TagKind_Tags.Emoji: {
          ordinalConverter.write(48, into);
          return;
        }
        case TagKind_Tags.Encrypted: {
          ordinalConverter.write(49, into);
          return;
        }
        case TagKind_Tags.Request: {
          ordinalConverter.write(50, into);
          return;
        }
        case TagKind_Tags.Web: {
          ordinalConverter.write(51, into);
          return;
        }
        case TagKind_Tags.Word: {
          ordinalConverter.write(52, into);
          return;
        }
        case TagKind_Tags.SingleLetter: {
          ordinalConverter.write(53, into);
          const inner = value.inner;
          FfiConverterTypeSingleLetterTag.write(inner.singleLetter, into);
          return;
        }
        case TagKind_Tags.Unknown: {
          ordinalConverter.write(54, into);
          const inner = value.inner;
          FfiConverterString.write(inner.unknown, into);
          return;
        }
        default:
          // Throwing from here means that TagKind_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case TagKind_Tags.Alt: {
          return ordinalConverter.allocationSize(1);
        }
        case TagKind_Tags.Client: {
          return ordinalConverter.allocationSize(2);
        }
        case TagKind_Tags.Clone: {
          return ordinalConverter.allocationSize(3);
        }
        case TagKind_Tags.Commit: {
          return ordinalConverter.allocationSize(4);
        }
        case TagKind_Tags.Maintainers: {
          return ordinalConverter.allocationSize(5);
        }
        case TagKind_Tags.Protected: {
          return ordinalConverter.allocationSize(6);
        }
        case TagKind_Tags.RelayUrl: {
          return ordinalConverter.allocationSize(7);
        }
        case TagKind_Tags.Nonce: {
          return ordinalConverter.allocationSize(8);
        }
        case TagKind_Tags.Delegation: {
          return ordinalConverter.allocationSize(9);
        }
        case TagKind_Tags.ContentWarning: {
          return ordinalConverter.allocationSize(10);
        }
        case TagKind_Tags.Expiration: {
          return ordinalConverter.allocationSize(11);
        }
        case TagKind_Tags.Subject: {
          return ordinalConverter.allocationSize(12);
        }
        case TagKind_Tags.Challenge: {
          return ordinalConverter.allocationSize(13);
        }
        case TagKind_Tags.Title: {
          return ordinalConverter.allocationSize(14);
        }
        case TagKind_Tags.Image: {
          return ordinalConverter.allocationSize(15);
        }
        case TagKind_Tags.Thumb: {
          return ordinalConverter.allocationSize(16);
        }
        case TagKind_Tags.Summary: {
          return ordinalConverter.allocationSize(17);
        }
        case TagKind_Tags.PublishedAt: {
          return ordinalConverter.allocationSize(18);
        }
        case TagKind_Tags.Description: {
          return ordinalConverter.allocationSize(19);
        }
        case TagKind_Tags.Bolt11: {
          return ordinalConverter.allocationSize(20);
        }
        case TagKind_Tags.Preimage: {
          return ordinalConverter.allocationSize(21);
        }
        case TagKind_Tags.Relays: {
          return ordinalConverter.allocationSize(22);
        }
        case TagKind_Tags.Amount: {
          return ordinalConverter.allocationSize(23);
        }
        case TagKind_Tags.Lnurl: {
          return ordinalConverter.allocationSize(24);
        }
        case TagKind_Tags.MlsProtocolVersion: {
          return ordinalConverter.allocationSize(25);
        }
        case TagKind_Tags.MlsCiphersuite: {
          return ordinalConverter.allocationSize(26);
        }
        case TagKind_Tags.MlsExtensions: {
          return ordinalConverter.allocationSize(27);
        }
        case TagKind_Tags.Name: {
          return ordinalConverter.allocationSize(28);
        }
        case TagKind_Tags.Url: {
          return ordinalConverter.allocationSize(29);
        }
        case TagKind_Tags.Aes256Gcm: {
          return ordinalConverter.allocationSize(30);
        }
        case TagKind_Tags.Size: {
          return ordinalConverter.allocationSize(31);
        }
        case TagKind_Tags.Dim: {
          return ordinalConverter.allocationSize(32);
        }
        case TagKind_Tags.File: {
          return ordinalConverter.allocationSize(33);
        }
        case TagKind_Tags.Magnet: {
          return ordinalConverter.allocationSize(34);
        }
        case TagKind_Tags.Blurhash: {
          return ordinalConverter.allocationSize(35);
        }
        case TagKind_Tags.Streaming: {
          return ordinalConverter.allocationSize(36);
        }
        case TagKind_Tags.Recording: {
          return ordinalConverter.allocationSize(37);
        }
        case TagKind_Tags.Starts: {
          return ordinalConverter.allocationSize(38);
        }
        case TagKind_Tags.Ends: {
          return ordinalConverter.allocationSize(39);
        }
        case TagKind_Tags.Status: {
          return ordinalConverter.allocationSize(40);
        }
        case TagKind_Tags.CurrentParticipants: {
          return ordinalConverter.allocationSize(41);
        }
        case TagKind_Tags.TotalParticipants: {
          return ordinalConverter.allocationSize(42);
        }
        case TagKind_Tags.Tracker: {
          return ordinalConverter.allocationSize(43);
        }
        case TagKind_Tags.Method: {
          return ordinalConverter.allocationSize(44);
        }
        case TagKind_Tags.Payload: {
          return ordinalConverter.allocationSize(45);
        }
        case TagKind_Tags.Anon: {
          return ordinalConverter.allocationSize(46);
        }
        case TagKind_Tags.Proxy: {
          return ordinalConverter.allocationSize(47);
        }
        case TagKind_Tags.Emoji: {
          return ordinalConverter.allocationSize(48);
        }
        case TagKind_Tags.Encrypted: {
          return ordinalConverter.allocationSize(49);
        }
        case TagKind_Tags.Request: {
          return ordinalConverter.allocationSize(50);
        }
        case TagKind_Tags.Web: {
          return ordinalConverter.allocationSize(51);
        }
        case TagKind_Tags.Word: {
          return ordinalConverter.allocationSize(52);
        }
        case TagKind_Tags.SingleLetter: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(53);
          size += FfiConverterTypeSingleLetterTag.allocationSize(
            inner.singleLetter
          );
          return size;
        }
        case TagKind_Tags.Unknown: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(54);
          size += FfiConverterString.allocationSize(inner.unknown);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: TagStandard
export enum TagStandard_Tags {
  EventTag = 'EventTag',
  Quote = 'Quote',
  GitClone = 'GitClone',
  GitCommit = 'GitCommit',
  GitEarliestUniqueCommitId = 'GitEarliestUniqueCommitId',
  GitMaintainers = 'GitMaintainers',
  PublicKeyTag = 'PublicKeyTag',
  EventReport = 'EventReport',
  PubKeyReport = 'PubKeyReport',
  PublicKeyLiveEvent = 'PublicKeyLiveEvent',
  Reference = 'Reference',
  RelayMetadataTag = 'RelayMetadataTag',
  Hashtag = 'Hashtag',
  Geohash = 'Geohash',
  Identifier = 'Identifier',
  ExternalContent = 'ExternalContent',
  ExternalIdentity = 'ExternalIdentity',
  CoordinateTag = 'CoordinateTag',
  KindTag = 'KindTag',
  RelayUrl = 'RelayUrl',
  AllRelays = 'AllRelays',
  Pow = 'POW',
  Client = 'Client',
  Delegation = 'Delegation',
  ContentWarning = 'ContentWarning',
  Expiration = 'Expiration',
  Subject = 'Subject',
  Challenge = 'Challenge',
  Title = 'Title',
  Image = 'Image',
  Thumb = 'Thumb',
  Summary = 'Summary',
  Description = 'Description',
  Bolt11 = 'Bolt11',
  Preimage = 'Preimage',
  Relays = 'Relays',
  Amount = 'Amount',
  Lnurl = 'Lnurl',
  Name = 'Name',
  PublishedAt = 'PublishedAt',
  UrlTag = 'UrlTag',
  MimeType = 'MimeType',
  Aes256Gcm = 'Aes256Gcm',
  Sha256 = 'Sha256',
  Size = 'Size',
  Dim = 'Dim',
  Magnet = 'Magnet',
  Blurhash = 'Blurhash',
  Streaming = 'Streaming',
  Recording = 'Recording',
  Starts = 'Starts',
  Ends = 'Ends',
  LiveEventStatusTag = 'LiveEventStatusTag',
  CurrentParticipants = 'CurrentParticipants',
  TotalParticipants = 'TotalParticipants',
  AbsoluteUrl = 'AbsoluteURL',
  Method = 'Method',
  Payload = 'Payload',
  Anon = 'Anon',
  Proxy = 'Proxy',
  Emoji = 'Emoji',
  Encrypted = 'Encrypted',
  Request = 'Request',
  DataVendingMachineStatusTag = 'DataVendingMachineStatusTag',
  LabelNamespace = 'LabelNamespace',
  Label = 'Label',
  Protected = 'Protected',
  Alt = 'Alt',
  Word = 'Word',
  Web = 'Web',
}
/**
 * Standardized tag
 */
export const TagStandard = (() => {
  type EventTag__interface = {
    tag: TagStandard_Tags.EventTag;
    inner: Readonly<{
      eventId: EventIdInterface;
      relayUrl: string | undefined;
      marker: Marker | undefined;
      publicKey: PublicKeyInterface | undefined;
      uppercase: boolean;
    }>;
  };

  class EventTag_ extends UniffiEnum implements EventTag__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.EventTag;
    readonly inner: Readonly<{
      eventId: EventIdInterface;
      relayUrl: string | undefined;
      marker: Marker | undefined;
      publicKey: PublicKeyInterface | undefined;
      uppercase: boolean;
    }>;
    constructor(inner: {
      eventId: EventIdInterface;
      relayUrl: string | undefined;
      marker: Marker | undefined;
      /**
       * Should be the public key of the author of the referenced event
       */ publicKey: PublicKeyInterface | undefined;
      /**
       * Whether the e tag is an uppercase E or not
       */ uppercase: boolean;
    }) {
      super('TagStandard', 'EventTag');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      eventId: EventIdInterface;
      relayUrl: string | undefined;
      marker: Marker | undefined;
      /**
       * Should be the public key of the author of the referenced event
       */ publicKey: PublicKeyInterface | undefined;
      /**
       * Whether the e tag is an uppercase E or not
       */ uppercase: boolean;
    }): EventTag_ {
      return new EventTag_(inner);
    }

    static instanceOf(obj: any): obj is EventTag_ {
      return obj.tag === TagStandard_Tags.EventTag;
    }
  }

  type Quote__interface = {
    tag: TagStandard_Tags.Quote;
    inner: Readonly<{
      eventId: EventIdInterface;
      relayUrl: string | undefined;
      publicKey: PublicKeyInterface | undefined;
    }>;
  };

  class Quote_ extends UniffiEnum implements Quote__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Quote;
    readonly inner: Readonly<{
      eventId: EventIdInterface;
      relayUrl: string | undefined;
      publicKey: PublicKeyInterface | undefined;
    }>;
    constructor(inner: {
      eventId: EventIdInterface;
      relayUrl: string | undefined;
      /**
       * Should be the public key of the author of the referenced event
       */ publicKey: PublicKeyInterface | undefined;
    }) {
      super('TagStandard', 'Quote');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      eventId: EventIdInterface;
      relayUrl: string | undefined;
      /**
       * Should be the public key of the author of the referenced event
       */ publicKey: PublicKeyInterface | undefined;
    }): Quote_ {
      return new Quote_(inner);
    }

    static instanceOf(obj: any): obj is Quote_ {
      return obj.tag === TagStandard_Tags.Quote;
    }
  }

  type GitClone__interface = {
    tag: TagStandard_Tags.GitClone;
    inner: Readonly<{ urls: Array<string> }>;
  };

  /**
   * Git clone (`clone` tag)
   *
   * <https://github.com/nostr-protocol/nips/blob/master/34.md>
   */
  class GitClone_ extends UniffiEnum implements GitClone__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.GitClone;
    readonly inner: Readonly<{ urls: Array<string> }>;
    constructor(inner: { urls: Array<string> }) {
      super('TagStandard', 'GitClone');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { urls: Array<string> }): GitClone_ {
      return new GitClone_(inner);
    }

    static instanceOf(obj: any): obj is GitClone_ {
      return obj.tag === TagStandard_Tags.GitClone;
    }
  }

  type GitCommit__interface = {
    tag: TagStandard_Tags.GitCommit;
    inner: Readonly<{ hash: string }>;
  };

  /**
   * Git commit
   *
   * <https://github.com/nostr-protocol/nips/blob/master/34.md>
   */
  class GitCommit_ extends UniffiEnum implements GitCommit__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.GitCommit;
    readonly inner: Readonly<{ hash: string }>;
    constructor(inner: { hash: string }) {
      super('TagStandard', 'GitCommit');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { hash: string }): GitCommit_ {
      return new GitCommit_(inner);
    }

    static instanceOf(obj: any): obj is GitCommit_ {
      return obj.tag === TagStandard_Tags.GitCommit;
    }
  }

  type GitEarliestUniqueCommitId__interface = {
    tag: TagStandard_Tags.GitEarliestUniqueCommitId;
    inner: Readonly<{ commit: string }>;
  };

  /**
   * Git earliest unique commit ID
   *
   * <https://github.com/nostr-protocol/nips/blob/master/34.md>
   */
  class GitEarliestUniqueCommitId_
    extends UniffiEnum
    implements GitEarliestUniqueCommitId__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.GitEarliestUniqueCommitId;
    readonly inner: Readonly<{ commit: string }>;
    constructor(inner: { commit: string }) {
      super('TagStandard', 'GitEarliestUniqueCommitId');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { commit: string }): GitEarliestUniqueCommitId_ {
      return new GitEarliestUniqueCommitId_(inner);
    }

    static instanceOf(obj: any): obj is GitEarliestUniqueCommitId_ {
      return obj.tag === TagStandard_Tags.GitEarliestUniqueCommitId;
    }
  }

  type GitMaintainers__interface = {
    tag: TagStandard_Tags.GitMaintainers;
    inner: Readonly<{ publicKeys: Array<PublicKeyInterface> }>;
  };

  /**
   * Git repo maintainers
   *
   * <https://github.com/nostr-protocol/nips/blob/master/34.md>
   */
  class GitMaintainers_
    extends UniffiEnum
    implements GitMaintainers__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.GitMaintainers;
    readonly inner: Readonly<{ publicKeys: Array<PublicKeyInterface> }>;
    constructor(inner: { publicKeys: Array<PublicKeyInterface> }) {
      super('TagStandard', 'GitMaintainers');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      publicKeys: Array<PublicKeyInterface>;
    }): GitMaintainers_ {
      return new GitMaintainers_(inner);
    }

    static instanceOf(obj: any): obj is GitMaintainers_ {
      return obj.tag === TagStandard_Tags.GitMaintainers;
    }
  }

  type PublicKeyTag__interface = {
    tag: TagStandard_Tags.PublicKeyTag;
    inner: Readonly<{
      publicKey: PublicKeyInterface;
      relayUrl: string | undefined;
      alias: string | undefined;
      uppercase: boolean;
    }>;
  };

  class PublicKeyTag_ extends UniffiEnum implements PublicKeyTag__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.PublicKeyTag;
    readonly inner: Readonly<{
      publicKey: PublicKeyInterface;
      relayUrl: string | undefined;
      alias: string | undefined;
      uppercase: boolean;
    }>;
    constructor(inner: {
      publicKey: PublicKeyInterface;
      relayUrl: string | undefined;
      alias: string | undefined;
      /**
       * Whether the p tag is an uppercase P or not
       */ uppercase: boolean;
    }) {
      super('TagStandard', 'PublicKeyTag');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      publicKey: PublicKeyInterface;
      relayUrl: string | undefined;
      alias: string | undefined;
      /**
       * Whether the p tag is an uppercase P or not
       */ uppercase: boolean;
    }): PublicKeyTag_ {
      return new PublicKeyTag_(inner);
    }

    static instanceOf(obj: any): obj is PublicKeyTag_ {
      return obj.tag === TagStandard_Tags.PublicKeyTag;
    }
  }

  type EventReport__interface = {
    tag: TagStandard_Tags.EventReport;
    inner: Readonly<{ eventId: EventIdInterface; report: Report }>;
  };

  class EventReport_ extends UniffiEnum implements EventReport__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.EventReport;
    readonly inner: Readonly<{ eventId: EventIdInterface; report: Report }>;
    constructor(inner: { eventId: EventIdInterface; report: Report }) {
      super('TagStandard', 'EventReport');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      eventId: EventIdInterface;
      report: Report;
    }): EventReport_ {
      return new EventReport_(inner);
    }

    static instanceOf(obj: any): obj is EventReport_ {
      return obj.tag === TagStandard_Tags.EventReport;
    }
  }

  type PubKeyReport__interface = {
    tag: TagStandard_Tags.PubKeyReport;
    inner: Readonly<{ publicKey: PublicKeyInterface; report: Report }>;
  };

  class PubKeyReport_ extends UniffiEnum implements PubKeyReport__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.PubKeyReport;
    readonly inner: Readonly<{ publicKey: PublicKeyInterface; report: Report }>;
    constructor(inner: { publicKey: PublicKeyInterface; report: Report }) {
      super('TagStandard', 'PubKeyReport');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      publicKey: PublicKeyInterface;
      report: Report;
    }): PubKeyReport_ {
      return new PubKeyReport_(inner);
    }

    static instanceOf(obj: any): obj is PubKeyReport_ {
      return obj.tag === TagStandard_Tags.PubKeyReport;
    }
  }

  type PublicKeyLiveEvent__interface = {
    tag: TagStandard_Tags.PublicKeyLiveEvent;
    inner: Readonly<{
      publicKey: PublicKeyInterface;
      relayUrl: string | undefined;
      marker: LiveEventMarker;
      proof: string | undefined;
    }>;
  };

  class PublicKeyLiveEvent_
    extends UniffiEnum
    implements PublicKeyLiveEvent__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.PublicKeyLiveEvent;
    readonly inner: Readonly<{
      publicKey: PublicKeyInterface;
      relayUrl: string | undefined;
      marker: LiveEventMarker;
      proof: string | undefined;
    }>;
    constructor(inner: {
      publicKey: PublicKeyInterface;
      relayUrl: string | undefined;
      marker: LiveEventMarker;
      proof: string | undefined;
    }) {
      super('TagStandard', 'PublicKeyLiveEvent');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      publicKey: PublicKeyInterface;
      relayUrl: string | undefined;
      marker: LiveEventMarker;
      proof: string | undefined;
    }): PublicKeyLiveEvent_ {
      return new PublicKeyLiveEvent_(inner);
    }

    static instanceOf(obj: any): obj is PublicKeyLiveEvent_ {
      return obj.tag === TagStandard_Tags.PublicKeyLiveEvent;
    }
  }

  type Reference__interface = {
    tag: TagStandard_Tags.Reference;
    inner: Readonly<{ reference: string }>;
  };

  class Reference_ extends UniffiEnum implements Reference__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Reference;
    readonly inner: Readonly<{ reference: string }>;
    constructor(inner: { reference: string }) {
      super('TagStandard', 'Reference');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { reference: string }): Reference_ {
      return new Reference_(inner);
    }

    static instanceOf(obj: any): obj is Reference_ {
      return obj.tag === TagStandard_Tags.Reference;
    }
  }

  type RelayMetadataTag__interface = {
    tag: TagStandard_Tags.RelayMetadataTag;
    inner: Readonly<{ relayUrl: string; rw: RelayMetadata | undefined }>;
  };

  class RelayMetadataTag_
    extends UniffiEnum
    implements RelayMetadataTag__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.RelayMetadataTag;
    readonly inner: Readonly<{
      relayUrl: string;
      rw: RelayMetadata | undefined;
    }>;
    constructor(inner: { relayUrl: string; rw: RelayMetadata | undefined }) {
      super('TagStandard', 'RelayMetadataTag');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      relayUrl: string;
      rw: RelayMetadata | undefined;
    }): RelayMetadataTag_ {
      return new RelayMetadataTag_(inner);
    }

    static instanceOf(obj: any): obj is RelayMetadataTag_ {
      return obj.tag === TagStandard_Tags.RelayMetadataTag;
    }
  }

  type Hashtag__interface = {
    tag: TagStandard_Tags.Hashtag;
    inner: Readonly<{ hashtag: string }>;
  };

  class Hashtag_ extends UniffiEnum implements Hashtag__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Hashtag;
    readonly inner: Readonly<{ hashtag: string }>;
    constructor(inner: { hashtag: string }) {
      super('TagStandard', 'Hashtag');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { hashtag: string }): Hashtag_ {
      return new Hashtag_(inner);
    }

    static instanceOf(obj: any): obj is Hashtag_ {
      return obj.tag === TagStandard_Tags.Hashtag;
    }
  }

  type Geohash__interface = {
    tag: TagStandard_Tags.Geohash;
    inner: Readonly<{ geohash: string }>;
  };

  class Geohash_ extends UniffiEnum implements Geohash__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Geohash;
    readonly inner: Readonly<{ geohash: string }>;
    constructor(inner: { geohash: string }) {
      super('TagStandard', 'Geohash');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { geohash: string }): Geohash_ {
      return new Geohash_(inner);
    }

    static instanceOf(obj: any): obj is Geohash_ {
      return obj.tag === TagStandard_Tags.Geohash;
    }
  }

  type Identifier__interface = {
    tag: TagStandard_Tags.Identifier;
    inner: Readonly<{ identifier: string }>;
  };

  class Identifier_ extends UniffiEnum implements Identifier__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Identifier;
    readonly inner: Readonly<{ identifier: string }>;
    constructor(inner: { identifier: string }) {
      super('TagStandard', 'Identifier');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { identifier: string }): Identifier_ {
      return new Identifier_(inner);
    }

    static instanceOf(obj: any): obj is Identifier_ {
      return obj.tag === TagStandard_Tags.Identifier;
    }
  }

  type ExternalContent__interface = {
    tag: TagStandard_Tags.ExternalContent;
    inner: Readonly<{
      content: ExternalContentId;
      hint: string | undefined;
      uppercase: boolean;
    }>;
  };

  class ExternalContent_
    extends UniffiEnum
    implements ExternalContent__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.ExternalContent;
    readonly inner: Readonly<{
      content: ExternalContentId;
      hint: string | undefined;
      uppercase: boolean;
    }>;
    constructor(inner: {
      content: ExternalContentId;
      /**
       * Hint URL
       */ hint: string | undefined;
      uppercase: boolean;
    }) {
      super('TagStandard', 'ExternalContent');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      content: ExternalContentId;
      /**
       * Hint URL
       */ hint: string | undefined;
      uppercase: boolean;
    }): ExternalContent_ {
      return new ExternalContent_(inner);
    }

    static instanceOf(obj: any): obj is ExternalContent_ {
      return obj.tag === TagStandard_Tags.ExternalContent;
    }
  }

  type ExternalIdentity__interface = {
    tag: TagStandard_Tags.ExternalIdentity;
    inner: Readonly<{ identity: Identity }>;
  };

  class ExternalIdentity_
    extends UniffiEnum
    implements ExternalIdentity__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.ExternalIdentity;
    readonly inner: Readonly<{ identity: Identity }>;
    constructor(inner: { identity: Identity }) {
      super('TagStandard', 'ExternalIdentity');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { identity: Identity }): ExternalIdentity_ {
      return new ExternalIdentity_(inner);
    }

    static instanceOf(obj: any): obj is ExternalIdentity_ {
      return obj.tag === TagStandard_Tags.ExternalIdentity;
    }
  }

  type CoordinateTag__interface = {
    tag: TagStandard_Tags.CoordinateTag;
    inner: Readonly<{
      coordinate: CoordinateInterface;
      relayUrl: string | undefined;
      uppercase: boolean;
    }>;
  };

  class CoordinateTag_ extends UniffiEnum implements CoordinateTag__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.CoordinateTag;
    readonly inner: Readonly<{
      coordinate: CoordinateInterface;
      relayUrl: string | undefined;
      uppercase: boolean;
    }>;
    constructor(inner: {
      coordinate: CoordinateInterface;
      relayUrl: string | undefined;
      /**
       * Whether the a tag is an uppercase A or not
       */ uppercase: boolean;
    }) {
      super('TagStandard', 'CoordinateTag');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      coordinate: CoordinateInterface;
      relayUrl: string | undefined;
      /**
       * Whether the a tag is an uppercase A or not
       */ uppercase: boolean;
    }): CoordinateTag_ {
      return new CoordinateTag_(inner);
    }

    static instanceOf(obj: any): obj is CoordinateTag_ {
      return obj.tag === TagStandard_Tags.CoordinateTag;
    }
  }

  type KindTag__interface = {
    tag: TagStandard_Tags.KindTag;
    inner: Readonly<{ kind: KindInterface; uppercase: boolean }>;
  };

  class KindTag_ extends UniffiEnum implements KindTag__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.KindTag;
    readonly inner: Readonly<{ kind: KindInterface; uppercase: boolean }>;
    constructor(inner: {
      kind: KindInterface;
      /**
       * Whether the k tag is an uppercase K or not
       */ uppercase: boolean;
    }) {
      super('TagStandard', 'KindTag');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      kind: KindInterface;
      /**
       * Whether the k tag is an uppercase K or not
       */ uppercase: boolean;
    }): KindTag_ {
      return new KindTag_(inner);
    }

    static instanceOf(obj: any): obj is KindTag_ {
      return obj.tag === TagStandard_Tags.KindTag;
    }
  }

  type RelayUrl__interface = {
    tag: TagStandard_Tags.RelayUrl;
    inner: Readonly<{ relayUrl: string }>;
  };

  class RelayUrl_ extends UniffiEnum implements RelayUrl__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.RelayUrl;
    readonly inner: Readonly<{ relayUrl: string }>;
    constructor(inner: { relayUrl: string }) {
      super('TagStandard', 'RelayUrl');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { relayUrl: string }): RelayUrl_ {
      return new RelayUrl_(inner);
    }

    static instanceOf(obj: any): obj is RelayUrl_ {
      return obj.tag === TagStandard_Tags.RelayUrl;
    }
  }

  type AllRelays__interface = {
    tag: TagStandard_Tags.AllRelays;
  };

  /**
   * All relays tag
   *
   * <https://github.com/nostr-protocol/nips/blob/master/62.md>
   */
  class AllRelays_ extends UniffiEnum implements AllRelays__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.AllRelays;
    constructor() {
      super('TagStandard', 'AllRelays');
    }

    static new(): AllRelays_ {
      return new AllRelays_();
    }

    static instanceOf(obj: any): obj is AllRelays_ {
      return obj.tag === TagStandard_Tags.AllRelays;
    }
  }

  type Pow__interface = {
    tag: TagStandard_Tags.Pow;
    inner: Readonly<{ nonce: string; difficulty: /*u8*/ number }>;
  };

  class Pow_ extends UniffiEnum implements Pow__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Pow;
    readonly inner: Readonly<{ nonce: string; difficulty: /*u8*/ number }>;
    constructor(inner: { nonce: string; difficulty: /*u8*/ number }) {
      super('TagStandard', 'Pow');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { nonce: string; difficulty: /*u8*/ number }): Pow_ {
      return new Pow_(inner);
    }

    static instanceOf(obj: any): obj is Pow_ {
      return obj.tag === TagStandard_Tags.Pow;
    }
  }

  type Client__interface = {
    tag: TagStandard_Tags.Client;
    inner: Readonly<{ name: string; address: TagClientAddress | undefined }>;
  };

  class Client_ extends UniffiEnum implements Client__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Client;
    readonly inner: Readonly<{
      name: string;
      address: TagClientAddress | undefined;
    }>;
    constructor(inner: {
      name: string;
      address: TagClientAddress | undefined;
    }) {
      super('TagStandard', 'Client');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      name: string;
      address: TagClientAddress | undefined;
    }): Client_ {
      return new Client_(inner);
    }

    static instanceOf(obj: any): obj is Client_ {
      return obj.tag === TagStandard_Tags.Client;
    }
  }

  type Delegation__interface = {
    tag: TagStandard_Tags.Delegation;
    inner: Readonly<{
      delegator: PublicKeyInterface;
      conditions: string;
      sig: string;
    }>;
  };

  class Delegation_ extends UniffiEnum implements Delegation__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Delegation;
    readonly inner: Readonly<{
      delegator: PublicKeyInterface;
      conditions: string;
      sig: string;
    }>;
    constructor(inner: {
      delegator: PublicKeyInterface;
      conditions: string;
      sig: string;
    }) {
      super('TagStandard', 'Delegation');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      delegator: PublicKeyInterface;
      conditions: string;
      sig: string;
    }): Delegation_ {
      return new Delegation_(inner);
    }

    static instanceOf(obj: any): obj is Delegation_ {
      return obj.tag === TagStandard_Tags.Delegation;
    }
  }

  type ContentWarning__interface = {
    tag: TagStandard_Tags.ContentWarning;
    inner: Readonly<{ reason: string | undefined }>;
  };

  class ContentWarning_
    extends UniffiEnum
    implements ContentWarning__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.ContentWarning;
    readonly inner: Readonly<{ reason: string | undefined }>;
    constructor(inner: { reason: string | undefined }) {
      super('TagStandard', 'ContentWarning');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { reason: string | undefined }): ContentWarning_ {
      return new ContentWarning_(inner);
    }

    static instanceOf(obj: any): obj is ContentWarning_ {
      return obj.tag === TagStandard_Tags.ContentWarning;
    }
  }

  type Expiration__interface = {
    tag: TagStandard_Tags.Expiration;
    inner: Readonly<{ timestamp: TimestampInterface }>;
  };

  class Expiration_ extends UniffiEnum implements Expiration__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Expiration;
    readonly inner: Readonly<{ timestamp: TimestampInterface }>;
    constructor(inner: { timestamp: TimestampInterface }) {
      super('TagStandard', 'Expiration');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { timestamp: TimestampInterface }): Expiration_ {
      return new Expiration_(inner);
    }

    static instanceOf(obj: any): obj is Expiration_ {
      return obj.tag === TagStandard_Tags.Expiration;
    }
  }

  type Subject__interface = {
    tag: TagStandard_Tags.Subject;
    inner: Readonly<{ subject: string }>;
  };

  class Subject_ extends UniffiEnum implements Subject__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Subject;
    readonly inner: Readonly<{ subject: string }>;
    constructor(inner: { subject: string }) {
      super('TagStandard', 'Subject');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { subject: string }): Subject_ {
      return new Subject_(inner);
    }

    static instanceOf(obj: any): obj is Subject_ {
      return obj.tag === TagStandard_Tags.Subject;
    }
  }

  type Challenge__interface = {
    tag: TagStandard_Tags.Challenge;
    inner: Readonly<{ challenge: string }>;
  };

  class Challenge_ extends UniffiEnum implements Challenge__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Challenge;
    readonly inner: Readonly<{ challenge: string }>;
    constructor(inner: { challenge: string }) {
      super('TagStandard', 'Challenge');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { challenge: string }): Challenge_ {
      return new Challenge_(inner);
    }

    static instanceOf(obj: any): obj is Challenge_ {
      return obj.tag === TagStandard_Tags.Challenge;
    }
  }

  type Title__interface = {
    tag: TagStandard_Tags.Title;
    inner: Readonly<{ title: string }>;
  };

  class Title_ extends UniffiEnum implements Title__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Title;
    readonly inner: Readonly<{ title: string }>;
    constructor(inner: { title: string }) {
      super('TagStandard', 'Title');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { title: string }): Title_ {
      return new Title_(inner);
    }

    static instanceOf(obj: any): obj is Title_ {
      return obj.tag === TagStandard_Tags.Title;
    }
  }

  type Image__interface = {
    tag: TagStandard_Tags.Image;
    inner: Readonly<{ url: string; dimensions: ImageDimensions | undefined }>;
  };

  class Image_ extends UniffiEnum implements Image__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Image;
    readonly inner: Readonly<{
      url: string;
      dimensions: ImageDimensions | undefined;
    }>;
    constructor(inner: {
      url: string;
      dimensions: ImageDimensions | undefined;
    }) {
      super('TagStandard', 'Image');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      url: string;
      dimensions: ImageDimensions | undefined;
    }): Image_ {
      return new Image_(inner);
    }

    static instanceOf(obj: any): obj is Image_ {
      return obj.tag === TagStandard_Tags.Image;
    }
  }

  type Thumb__interface = {
    tag: TagStandard_Tags.Thumb;
    inner: Readonly<{ url: string; dimensions: ImageDimensions | undefined }>;
  };

  class Thumb_ extends UniffiEnum implements Thumb__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Thumb;
    readonly inner: Readonly<{
      url: string;
      dimensions: ImageDimensions | undefined;
    }>;
    constructor(inner: {
      url: string;
      dimensions: ImageDimensions | undefined;
    }) {
      super('TagStandard', 'Thumb');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      url: string;
      dimensions: ImageDimensions | undefined;
    }): Thumb_ {
      return new Thumb_(inner);
    }

    static instanceOf(obj: any): obj is Thumb_ {
      return obj.tag === TagStandard_Tags.Thumb;
    }
  }

  type Summary__interface = {
    tag: TagStandard_Tags.Summary;
    inner: Readonly<{ summary: string }>;
  };

  class Summary_ extends UniffiEnum implements Summary__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Summary;
    readonly inner: Readonly<{ summary: string }>;
    constructor(inner: { summary: string }) {
      super('TagStandard', 'Summary');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { summary: string }): Summary_ {
      return new Summary_(inner);
    }

    static instanceOf(obj: any): obj is Summary_ {
      return obj.tag === TagStandard_Tags.Summary;
    }
  }

  type Description__interface = {
    tag: TagStandard_Tags.Description;
    inner: Readonly<{ desc: string }>;
  };

  class Description_ extends UniffiEnum implements Description__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Description;
    readonly inner: Readonly<{ desc: string }>;
    constructor(inner: { desc: string }) {
      super('TagStandard', 'Description');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { desc: string }): Description_ {
      return new Description_(inner);
    }

    static instanceOf(obj: any): obj is Description_ {
      return obj.tag === TagStandard_Tags.Description;
    }
  }

  type Bolt11__interface = {
    tag: TagStandard_Tags.Bolt11;
    inner: Readonly<{ bolt11: string }>;
  };

  class Bolt11_ extends UniffiEnum implements Bolt11__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Bolt11;
    readonly inner: Readonly<{ bolt11: string }>;
    constructor(inner: { bolt11: string }) {
      super('TagStandard', 'Bolt11');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { bolt11: string }): Bolt11_ {
      return new Bolt11_(inner);
    }

    static instanceOf(obj: any): obj is Bolt11_ {
      return obj.tag === TagStandard_Tags.Bolt11;
    }
  }

  type Preimage__interface = {
    tag: TagStandard_Tags.Preimage;
    inner: Readonly<{ preimage: string }>;
  };

  class Preimage_ extends UniffiEnum implements Preimage__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Preimage;
    readonly inner: Readonly<{ preimage: string }>;
    constructor(inner: { preimage: string }) {
      super('TagStandard', 'Preimage');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { preimage: string }): Preimage_ {
      return new Preimage_(inner);
    }

    static instanceOf(obj: any): obj is Preimage_ {
      return obj.tag === TagStandard_Tags.Preimage;
    }
  }

  type Relays__interface = {
    tag: TagStandard_Tags.Relays;
    inner: Readonly<{ urls: Array<string> }>;
  };

  class Relays_ extends UniffiEnum implements Relays__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Relays;
    readonly inner: Readonly<{ urls: Array<string> }>;
    constructor(inner: { urls: Array<string> }) {
      super('TagStandard', 'Relays');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { urls: Array<string> }): Relays_ {
      return new Relays_(inner);
    }

    static instanceOf(obj: any): obj is Relays_ {
      return obj.tag === TagStandard_Tags.Relays;
    }
  }

  type Amount__interface = {
    tag: TagStandard_Tags.Amount;
    inner: Readonly<{ millisats: /*u64*/ bigint; bolt11: string | undefined }>;
  };

  class Amount_ extends UniffiEnum implements Amount__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Amount;
    readonly inner: Readonly<{
      millisats: /*u64*/ bigint;
      bolt11: string | undefined;
    }>;
    constructor(inner: {
      millisats: /*u64*/ bigint;
      bolt11: string | undefined;
    }) {
      super('TagStandard', 'Amount');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      millisats: /*u64*/ bigint;
      bolt11: string | undefined;
    }): Amount_ {
      return new Amount_(inner);
    }

    static instanceOf(obj: any): obj is Amount_ {
      return obj.tag === TagStandard_Tags.Amount;
    }
  }

  type Lnurl__interface = {
    tag: TagStandard_Tags.Lnurl;
    inner: Readonly<{ lnurl: string }>;
  };

  class Lnurl_ extends UniffiEnum implements Lnurl__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Lnurl;
    readonly inner: Readonly<{ lnurl: string }>;
    constructor(inner: { lnurl: string }) {
      super('TagStandard', 'Lnurl');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { lnurl: string }): Lnurl_ {
      return new Lnurl_(inner);
    }

    static instanceOf(obj: any): obj is Lnurl_ {
      return obj.tag === TagStandard_Tags.Lnurl;
    }
  }

  type Name__interface = {
    tag: TagStandard_Tags.Name;
    inner: Readonly<{ name: string }>;
  };

  class Name_ extends UniffiEnum implements Name__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Name;
    readonly inner: Readonly<{ name: string }>;
    constructor(inner: { name: string }) {
      super('TagStandard', 'Name');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { name: string }): Name_ {
      return new Name_(inner);
    }

    static instanceOf(obj: any): obj is Name_ {
      return obj.tag === TagStandard_Tags.Name;
    }
  }

  type PublishedAt__interface = {
    tag: TagStandard_Tags.PublishedAt;
    inner: Readonly<{ timestamp: TimestampInterface }>;
  };

  class PublishedAt_ extends UniffiEnum implements PublishedAt__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.PublishedAt;
    readonly inner: Readonly<{ timestamp: TimestampInterface }>;
    constructor(inner: { timestamp: TimestampInterface }) {
      super('TagStandard', 'PublishedAt');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { timestamp: TimestampInterface }): PublishedAt_ {
      return new PublishedAt_(inner);
    }

    static instanceOf(obj: any): obj is PublishedAt_ {
      return obj.tag === TagStandard_Tags.PublishedAt;
    }
  }

  type UrlTag__interface = {
    tag: TagStandard_Tags.UrlTag;
    inner: Readonly<{ url: string }>;
  };

  class UrlTag_ extends UniffiEnum implements UrlTag__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.UrlTag;
    readonly inner: Readonly<{ url: string }>;
    constructor(inner: { url: string }) {
      super('TagStandard', 'UrlTag');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { url: string }): UrlTag_ {
      return new UrlTag_(inner);
    }

    static instanceOf(obj: any): obj is UrlTag_ {
      return obj.tag === TagStandard_Tags.UrlTag;
    }
  }

  type MimeType__interface = {
    tag: TagStandard_Tags.MimeType;
    inner: Readonly<{ mime: string }>;
  };

  class MimeType_ extends UniffiEnum implements MimeType__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.MimeType;
    readonly inner: Readonly<{ mime: string }>;
    constructor(inner: { mime: string }) {
      super('TagStandard', 'MimeType');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { mime: string }): MimeType_ {
      return new MimeType_(inner);
    }

    static instanceOf(obj: any): obj is MimeType_ {
      return obj.tag === TagStandard_Tags.MimeType;
    }
  }

  type Aes256Gcm__interface = {
    tag: TagStandard_Tags.Aes256Gcm;
    inner: Readonly<{ key: string; iv: string }>;
  };

  class Aes256Gcm_ extends UniffiEnum implements Aes256Gcm__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Aes256Gcm;
    readonly inner: Readonly<{ key: string; iv: string }>;
    constructor(inner: { key: string; iv: string }) {
      super('TagStandard', 'Aes256Gcm');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { key: string; iv: string }): Aes256Gcm_ {
      return new Aes256Gcm_(inner);
    }

    static instanceOf(obj: any): obj is Aes256Gcm_ {
      return obj.tag === TagStandard_Tags.Aes256Gcm;
    }
  }

  type Sha256__interface = {
    tag: TagStandard_Tags.Sha256;
    inner: Readonly<{ hash: string }>;
  };

  class Sha256_ extends UniffiEnum implements Sha256__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Sha256;
    readonly inner: Readonly<{ hash: string }>;
    constructor(inner: { hash: string }) {
      super('TagStandard', 'Sha256');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { hash: string }): Sha256_ {
      return new Sha256_(inner);
    }

    static instanceOf(obj: any): obj is Sha256_ {
      return obj.tag === TagStandard_Tags.Sha256;
    }
  }

  type Size__interface = {
    tag: TagStandard_Tags.Size;
    inner: Readonly<{ size: /*u64*/ bigint }>;
  };

  class Size_ extends UniffiEnum implements Size__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Size;
    readonly inner: Readonly<{ size: /*u64*/ bigint }>;
    constructor(inner: { size: /*u64*/ bigint }) {
      super('TagStandard', 'Size');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { size: /*u64*/ bigint }): Size_ {
      return new Size_(inner);
    }

    static instanceOf(obj: any): obj is Size_ {
      return obj.tag === TagStandard_Tags.Size;
    }
  }

  type Dim__interface = {
    tag: TagStandard_Tags.Dim;
    inner: Readonly<{ dimensions: ImageDimensions }>;
  };

  /**
   * Size of file in pixels
   */
  class Dim_ extends UniffiEnum implements Dim__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Dim;
    readonly inner: Readonly<{ dimensions: ImageDimensions }>;
    constructor(inner: { dimensions: ImageDimensions }) {
      super('TagStandard', 'Dim');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { dimensions: ImageDimensions }): Dim_ {
      return new Dim_(inner);
    }

    static instanceOf(obj: any): obj is Dim_ {
      return obj.tag === TagStandard_Tags.Dim;
    }
  }

  type Magnet__interface = {
    tag: TagStandard_Tags.Magnet;
    inner: Readonly<{ uri: string }>;
  };

  class Magnet_ extends UniffiEnum implements Magnet__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Magnet;
    readonly inner: Readonly<{ uri: string }>;
    constructor(inner: { uri: string }) {
      super('TagStandard', 'Magnet');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { uri: string }): Magnet_ {
      return new Magnet_(inner);
    }

    static instanceOf(obj: any): obj is Magnet_ {
      return obj.tag === TagStandard_Tags.Magnet;
    }
  }

  type Blurhash__interface = {
    tag: TagStandard_Tags.Blurhash;
    inner: Readonly<{ blurhash: string }>;
  };

  class Blurhash_ extends UniffiEnum implements Blurhash__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Blurhash;
    readonly inner: Readonly<{ blurhash: string }>;
    constructor(inner: { blurhash: string }) {
      super('TagStandard', 'Blurhash');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { blurhash: string }): Blurhash_ {
      return new Blurhash_(inner);
    }

    static instanceOf(obj: any): obj is Blurhash_ {
      return obj.tag === TagStandard_Tags.Blurhash;
    }
  }

  type Streaming__interface = {
    tag: TagStandard_Tags.Streaming;
    inner: Readonly<{ url: string }>;
  };

  class Streaming_ extends UniffiEnum implements Streaming__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Streaming;
    readonly inner: Readonly<{ url: string }>;
    constructor(inner: { url: string }) {
      super('TagStandard', 'Streaming');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { url: string }): Streaming_ {
      return new Streaming_(inner);
    }

    static instanceOf(obj: any): obj is Streaming_ {
      return obj.tag === TagStandard_Tags.Streaming;
    }
  }

  type Recording__interface = {
    tag: TagStandard_Tags.Recording;
    inner: Readonly<{ url: string }>;
  };

  class Recording_ extends UniffiEnum implements Recording__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Recording;
    readonly inner: Readonly<{ url: string }>;
    constructor(inner: { url: string }) {
      super('TagStandard', 'Recording');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { url: string }): Recording_ {
      return new Recording_(inner);
    }

    static instanceOf(obj: any): obj is Recording_ {
      return obj.tag === TagStandard_Tags.Recording;
    }
  }

  type Starts__interface = {
    tag: TagStandard_Tags.Starts;
    inner: Readonly<{ timestamp: TimestampInterface }>;
  };

  class Starts_ extends UniffiEnum implements Starts__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Starts;
    readonly inner: Readonly<{ timestamp: TimestampInterface }>;
    constructor(inner: { timestamp: TimestampInterface }) {
      super('TagStandard', 'Starts');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { timestamp: TimestampInterface }): Starts_ {
      return new Starts_(inner);
    }

    static instanceOf(obj: any): obj is Starts_ {
      return obj.tag === TagStandard_Tags.Starts;
    }
  }

  type Ends__interface = {
    tag: TagStandard_Tags.Ends;
    inner: Readonly<{ timestamp: TimestampInterface }>;
  };

  class Ends_ extends UniffiEnum implements Ends__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Ends;
    readonly inner: Readonly<{ timestamp: TimestampInterface }>;
    constructor(inner: { timestamp: TimestampInterface }) {
      super('TagStandard', 'Ends');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { timestamp: TimestampInterface }): Ends_ {
      return new Ends_(inner);
    }

    static instanceOf(obj: any): obj is Ends_ {
      return obj.tag === TagStandard_Tags.Ends;
    }
  }

  type LiveEventStatusTag__interface = {
    tag: TagStandard_Tags.LiveEventStatusTag;
    inner: Readonly<{ status: LiveEventStatus }>;
  };

  class LiveEventStatusTag_
    extends UniffiEnum
    implements LiveEventStatusTag__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.LiveEventStatusTag;
    readonly inner: Readonly<{ status: LiveEventStatus }>;
    constructor(inner: { status: LiveEventStatus }) {
      super('TagStandard', 'LiveEventStatusTag');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { status: LiveEventStatus }): LiveEventStatusTag_ {
      return new LiveEventStatusTag_(inner);
    }

    static instanceOf(obj: any): obj is LiveEventStatusTag_ {
      return obj.tag === TagStandard_Tags.LiveEventStatusTag;
    }
  }

  type CurrentParticipants__interface = {
    tag: TagStandard_Tags.CurrentParticipants;
    inner: Readonly<{ num: /*u64*/ bigint }>;
  };

  class CurrentParticipants_
    extends UniffiEnum
    implements CurrentParticipants__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.CurrentParticipants;
    readonly inner: Readonly<{ num: /*u64*/ bigint }>;
    constructor(inner: { num: /*u64*/ bigint }) {
      super('TagStandard', 'CurrentParticipants');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { num: /*u64*/ bigint }): CurrentParticipants_ {
      return new CurrentParticipants_(inner);
    }

    static instanceOf(obj: any): obj is CurrentParticipants_ {
      return obj.tag === TagStandard_Tags.CurrentParticipants;
    }
  }

  type TotalParticipants__interface = {
    tag: TagStandard_Tags.TotalParticipants;
    inner: Readonly<{ num: /*u64*/ bigint }>;
  };

  class TotalParticipants_
    extends UniffiEnum
    implements TotalParticipants__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.TotalParticipants;
    readonly inner: Readonly<{ num: /*u64*/ bigint }>;
    constructor(inner: { num: /*u64*/ bigint }) {
      super('TagStandard', 'TotalParticipants');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { num: /*u64*/ bigint }): TotalParticipants_ {
      return new TotalParticipants_(inner);
    }

    static instanceOf(obj: any): obj is TotalParticipants_ {
      return obj.tag === TagStandard_Tags.TotalParticipants;
    }
  }

  type AbsoluteUrl__interface = {
    tag: TagStandard_Tags.AbsoluteUrl;
    inner: Readonly<{ url: string }>;
  };

  class AbsoluteUrl_ extends UniffiEnum implements AbsoluteUrl__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.AbsoluteUrl;
    readonly inner: Readonly<{ url: string }>;
    constructor(inner: { url: string }) {
      super('TagStandard', 'AbsoluteUrl');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { url: string }): AbsoluteUrl_ {
      return new AbsoluteUrl_(inner);
    }

    static instanceOf(obj: any): obj is AbsoluteUrl_ {
      return obj.tag === TagStandard_Tags.AbsoluteUrl;
    }
  }

  type Method__interface = {
    tag: TagStandard_Tags.Method;
    inner: Readonly<{ method: HttpMethod }>;
  };

  class Method_ extends UniffiEnum implements Method__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Method;
    readonly inner: Readonly<{ method: HttpMethod }>;
    constructor(inner: { method: HttpMethod }) {
      super('TagStandard', 'Method');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { method: HttpMethod }): Method_ {
      return new Method_(inner);
    }

    static instanceOf(obj: any): obj is Method_ {
      return obj.tag === TagStandard_Tags.Method;
    }
  }

  type Payload__interface = {
    tag: TagStandard_Tags.Payload;
    inner: Readonly<{ hash: string }>;
  };

  class Payload_ extends UniffiEnum implements Payload__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Payload;
    readonly inner: Readonly<{ hash: string }>;
    constructor(inner: { hash: string }) {
      super('TagStandard', 'Payload');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { hash: string }): Payload_ {
      return new Payload_(inner);
    }

    static instanceOf(obj: any): obj is Payload_ {
      return obj.tag === TagStandard_Tags.Payload;
    }
  }

  type Anon__interface = {
    tag: TagStandard_Tags.Anon;
    inner: Readonly<{ msg: string | undefined }>;
  };

  class Anon_ extends UniffiEnum implements Anon__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Anon;
    readonly inner: Readonly<{ msg: string | undefined }>;
    constructor(inner: { msg: string | undefined }) {
      super('TagStandard', 'Anon');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { msg: string | undefined }): Anon_ {
      return new Anon_(inner);
    }

    static instanceOf(obj: any): obj is Anon_ {
      return obj.tag === TagStandard_Tags.Anon;
    }
  }

  type Proxy__interface = {
    tag: TagStandard_Tags.Proxy;
    inner: Readonly<{ id: string; protocol: Protocol }>;
  };

  class Proxy_ extends UniffiEnum implements Proxy__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Proxy;
    readonly inner: Readonly<{ id: string; protocol: Protocol }>;
    constructor(inner: { id: string; protocol: Protocol }) {
      super('TagStandard', 'Proxy');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { id: string; protocol: Protocol }): Proxy_ {
      return new Proxy_(inner);
    }

    static instanceOf(obj: any): obj is Proxy_ {
      return obj.tag === TagStandard_Tags.Proxy;
    }
  }

  type Emoji__interface = {
    tag: TagStandard_Tags.Emoji;
    inner: Readonly<{ shortcode: string; url: string }>;
  };

  class Emoji_ extends UniffiEnum implements Emoji__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Emoji;
    readonly inner: Readonly<{ shortcode: string; url: string }>;
    constructor(inner: { shortcode: string; url: string }) {
      super('TagStandard', 'Emoji');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { shortcode: string; url: string }): Emoji_ {
      return new Emoji_(inner);
    }

    static instanceOf(obj: any): obj is Emoji_ {
      return obj.tag === TagStandard_Tags.Emoji;
    }
  }

  type Encrypted__interface = {
    tag: TagStandard_Tags.Encrypted;
  };

  class Encrypted_ extends UniffiEnum implements Encrypted__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Encrypted;
    constructor() {
      super('TagStandard', 'Encrypted');
    }

    static new(): Encrypted_ {
      return new Encrypted_();
    }

    static instanceOf(obj: any): obj is Encrypted_ {
      return obj.tag === TagStandard_Tags.Encrypted;
    }
  }

  type Request__interface = {
    tag: TagStandard_Tags.Request;
    inner: Readonly<{ event: EventInterface }>;
  };

  class Request_ extends UniffiEnum implements Request__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Request;
    readonly inner: Readonly<{ event: EventInterface }>;
    constructor(inner: { event: EventInterface }) {
      super('TagStandard', 'Request');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { event: EventInterface }): Request_ {
      return new Request_(inner);
    }

    static instanceOf(obj: any): obj is Request_ {
      return obj.tag === TagStandard_Tags.Request;
    }
  }

  type DataVendingMachineStatusTag__interface = {
    tag: TagStandard_Tags.DataVendingMachineStatusTag;
    inner: Readonly<{
      status: DataVendingMachineStatus;
      extraInfo: string | undefined;
    }>;
  };

  class DataVendingMachineStatusTag_
    extends UniffiEnum
    implements DataVendingMachineStatusTag__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.DataVendingMachineStatusTag;
    readonly inner: Readonly<{
      status: DataVendingMachineStatus;
      extraInfo: string | undefined;
    }>;
    constructor(inner: {
      status: DataVendingMachineStatus;
      extraInfo: string | undefined;
    }) {
      super('TagStandard', 'DataVendingMachineStatusTag');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      status: DataVendingMachineStatus;
      extraInfo: string | undefined;
    }): DataVendingMachineStatusTag_ {
      return new DataVendingMachineStatusTag_(inner);
    }

    static instanceOf(obj: any): obj is DataVendingMachineStatusTag_ {
      return obj.tag === TagStandard_Tags.DataVendingMachineStatusTag;
    }
  }

  type LabelNamespace__interface = {
    tag: TagStandard_Tags.LabelNamespace;
    inner: Readonly<{ namespace: string }>;
  };

  class LabelNamespace_
    extends UniffiEnum
    implements LabelNamespace__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.LabelNamespace;
    readonly inner: Readonly<{ namespace: string }>;
    constructor(inner: { namespace: string }) {
      super('TagStandard', 'LabelNamespace');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { namespace: string }): LabelNamespace_ {
      return new LabelNamespace_(inner);
    }

    static instanceOf(obj: any): obj is LabelNamespace_ {
      return obj.tag === TagStandard_Tags.LabelNamespace;
    }
  }

  type Label__interface = {
    tag: TagStandard_Tags.Label;
    inner: Readonly<{ label: Array<string> }>;
  };

  class Label_ extends UniffiEnum implements Label__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Label;
    readonly inner: Readonly<{ label: Array<string> }>;
    constructor(inner: { label: Array<string> }) {
      super('TagStandard', 'Label');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { label: Array<string> }): Label_ {
      return new Label_(inner);
    }

    static instanceOf(obj: any): obj is Label_ {
      return obj.tag === TagStandard_Tags.Label;
    }
  }

  type Protected__interface = {
    tag: TagStandard_Tags.Protected;
  };

  /**
   * Protected event
   *
   * <https://github.com/nostr-protocol/nips/blob/master/70.md>
   */
  class Protected_ extends UniffiEnum implements Protected__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Protected;
    constructor() {
      super('TagStandard', 'Protected');
    }

    static new(): Protected_ {
      return new Protected_();
    }

    static instanceOf(obj: any): obj is Protected_ {
      return obj.tag === TagStandard_Tags.Protected;
    }
  }

  type Alt__interface = {
    tag: TagStandard_Tags.Alt;
    inner: Readonly<{ summary: string }>;
  };

  /**
   * A short human-readable plaintext summary of what that event is about
   *
   * <https://github.com/nostr-protocol/nips/blob/master/31.md>
   */
  class Alt_ extends UniffiEnum implements Alt__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Alt;
    readonly inner: Readonly<{ summary: string }>;
    constructor(inner: { summary: string }) {
      super('TagStandard', 'Alt');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { summary: string }): Alt_ {
      return new Alt_(inner);
    }

    static instanceOf(obj: any): obj is Alt_ {
      return obj.tag === TagStandard_Tags.Alt;
    }
  }

  type Word__interface = {
    tag: TagStandard_Tags.Word;
    inner: Readonly<{ word: string }>;
  };

  class Word_ extends UniffiEnum implements Word__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Word;
    readonly inner: Readonly<{ word: string }>;
    constructor(inner: { word: string }) {
      super('TagStandard', 'Word');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { word: string }): Word_ {
      return new Word_(inner);
    }

    static instanceOf(obj: any): obj is Word_ {
      return obj.tag === TagStandard_Tags.Word;
    }
  }

  type Web__interface = {
    tag: TagStandard_Tags.Web;
    inner: Readonly<{ urls: Array<string> }>;
  };

  class Web_ extends UniffiEnum implements Web__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TagStandard';
    readonly tag = TagStandard_Tags.Web;
    readonly inner: Readonly<{ urls: Array<string> }>;
    constructor(inner: { urls: Array<string> }) {
      super('TagStandard', 'Web');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { urls: Array<string> }): Web_ {
      return new Web_(inner);
    }

    static instanceOf(obj: any): obj is Web_ {
      return obj.tag === TagStandard_Tags.Web;
    }
  }

  function instanceOf(obj: any): obj is TagStandard {
    return obj[uniffiTypeNameSymbol] === 'TagStandard';
  }

  return Object.freeze({
    instanceOf,
    EventTag: EventTag_,
    Quote: Quote_,
    GitClone: GitClone_,
    GitCommit: GitCommit_,
    GitEarliestUniqueCommitId: GitEarliestUniqueCommitId_,
    GitMaintainers: GitMaintainers_,
    PublicKeyTag: PublicKeyTag_,
    EventReport: EventReport_,
    PubKeyReport: PubKeyReport_,
    PublicKeyLiveEvent: PublicKeyLiveEvent_,
    Reference: Reference_,
    RelayMetadataTag: RelayMetadataTag_,
    Hashtag: Hashtag_,
    Geohash: Geohash_,
    Identifier: Identifier_,
    ExternalContent: ExternalContent_,
    ExternalIdentity: ExternalIdentity_,
    CoordinateTag: CoordinateTag_,
    KindTag: KindTag_,
    RelayUrl: RelayUrl_,
    AllRelays: AllRelays_,
    Pow: Pow_,
    Client: Client_,
    Delegation: Delegation_,
    ContentWarning: ContentWarning_,
    Expiration: Expiration_,
    Subject: Subject_,
    Challenge: Challenge_,
    Title: Title_,
    Image: Image_,
    Thumb: Thumb_,
    Summary: Summary_,
    Description: Description_,
    Bolt11: Bolt11_,
    Preimage: Preimage_,
    Relays: Relays_,
    Amount: Amount_,
    Lnurl: Lnurl_,
    Name: Name_,
    PublishedAt: PublishedAt_,
    UrlTag: UrlTag_,
    MimeType: MimeType_,
    Aes256Gcm: Aes256Gcm_,
    Sha256: Sha256_,
    Size: Size_,
    Dim: Dim_,
    Magnet: Magnet_,
    Blurhash: Blurhash_,
    Streaming: Streaming_,
    Recording: Recording_,
    Starts: Starts_,
    Ends: Ends_,
    LiveEventStatusTag: LiveEventStatusTag_,
    CurrentParticipants: CurrentParticipants_,
    TotalParticipants: TotalParticipants_,
    AbsoluteUrl: AbsoluteUrl_,
    Method: Method_,
    Payload: Payload_,
    Anon: Anon_,
    Proxy: Proxy_,
    Emoji: Emoji_,
    Encrypted: Encrypted_,
    Request: Request_,
    DataVendingMachineStatusTag: DataVendingMachineStatusTag_,
    LabelNamespace: LabelNamespace_,
    Label: Label_,
    Protected: Protected_,
    Alt: Alt_,
    Word: Word_,
    Web: Web_,
  });
})();

/**
 * Standardized tag
 */

export type TagStandard = InstanceType<
  (typeof TagStandard)[keyof Omit<typeof TagStandard, 'instanceOf'>]
>;

// FfiConverter for enum TagStandard
const FfiConverterTypeTagStandard = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TagStandard;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new TagStandard.EventTag({
            eventId: FfiConverterTypeEventId.read(from),
            relayUrl: FfiConverterOptionalString.read(from),
            marker: FfiConverterOptionalTypeMarker.read(from),
            publicKey: FfiConverterOptionalTypePublicKey.read(from),
            uppercase: FfiConverterBool.read(from),
          });
        case 2:
          return new TagStandard.Quote({
            eventId: FfiConverterTypeEventId.read(from),
            relayUrl: FfiConverterOptionalString.read(from),
            publicKey: FfiConverterOptionalTypePublicKey.read(from),
          });
        case 3:
          return new TagStandard.GitClone({
            urls: FfiConverterArrayString.read(from),
          });
        case 4:
          return new TagStandard.GitCommit({
            hash: FfiConverterString.read(from),
          });
        case 5:
          return new TagStandard.GitEarliestUniqueCommitId({
            commit: FfiConverterString.read(from),
          });
        case 6:
          return new TagStandard.GitMaintainers({
            publicKeys: FfiConverterArrayTypePublicKey.read(from),
          });
        case 7:
          return new TagStandard.PublicKeyTag({
            publicKey: FfiConverterTypePublicKey.read(from),
            relayUrl: FfiConverterOptionalString.read(from),
            alias: FfiConverterOptionalString.read(from),
            uppercase: FfiConverterBool.read(from),
          });
        case 8:
          return new TagStandard.EventReport({
            eventId: FfiConverterTypeEventId.read(from),
            report: FfiConverterTypeReport.read(from),
          });
        case 9:
          return new TagStandard.PubKeyReport({
            publicKey: FfiConverterTypePublicKey.read(from),
            report: FfiConverterTypeReport.read(from),
          });
        case 10:
          return new TagStandard.PublicKeyLiveEvent({
            publicKey: FfiConverterTypePublicKey.read(from),
            relayUrl: FfiConverterOptionalString.read(from),
            marker: FfiConverterTypeLiveEventMarker.read(from),
            proof: FfiConverterOptionalString.read(from),
          });
        case 11:
          return new TagStandard.Reference({
            reference: FfiConverterString.read(from),
          });
        case 12:
          return new TagStandard.RelayMetadataTag({
            relayUrl: FfiConverterString.read(from),
            rw: FfiConverterOptionalTypeRelayMetadata.read(from),
          });
        case 13:
          return new TagStandard.Hashtag({
            hashtag: FfiConverterString.read(from),
          });
        case 14:
          return new TagStandard.Geohash({
            geohash: FfiConverterString.read(from),
          });
        case 15:
          return new TagStandard.Identifier({
            identifier: FfiConverterString.read(from),
          });
        case 16:
          return new TagStandard.ExternalContent({
            content: FfiConverterTypeExternalContentId.read(from),
            hint: FfiConverterOptionalString.read(from),
            uppercase: FfiConverterBool.read(from),
          });
        case 17:
          return new TagStandard.ExternalIdentity({
            identity: FfiConverterTypeIdentity.read(from),
          });
        case 18:
          return new TagStandard.CoordinateTag({
            coordinate: FfiConverterTypeCoordinate.read(from),
            relayUrl: FfiConverterOptionalString.read(from),
            uppercase: FfiConverterBool.read(from),
          });
        case 19:
          return new TagStandard.KindTag({
            kind: FfiConverterTypeKind.read(from),
            uppercase: FfiConverterBool.read(from),
          });
        case 20:
          return new TagStandard.RelayUrl({
            relayUrl: FfiConverterString.read(from),
          });
        case 21:
          return new TagStandard.AllRelays();
        case 22:
          return new TagStandard.Pow({
            nonce: FfiConverterString.read(from),
            difficulty: FfiConverterUInt8.read(from),
          });
        case 23:
          return new TagStandard.Client({
            name: FfiConverterString.read(from),
            address: FfiConverterOptionalTypeTagClientAddress.read(from),
          });
        case 24:
          return new TagStandard.Delegation({
            delegator: FfiConverterTypePublicKey.read(from),
            conditions: FfiConverterString.read(from),
            sig: FfiConverterString.read(from),
          });
        case 25:
          return new TagStandard.ContentWarning({
            reason: FfiConverterOptionalString.read(from),
          });
        case 26:
          return new TagStandard.Expiration({
            timestamp: FfiConverterTypeTimestamp.read(from),
          });
        case 27:
          return new TagStandard.Subject({
            subject: FfiConverterString.read(from),
          });
        case 28:
          return new TagStandard.Challenge({
            challenge: FfiConverterString.read(from),
          });
        case 29:
          return new TagStandard.Title({
            title: FfiConverterString.read(from),
          });
        case 30:
          return new TagStandard.Image({
            url: FfiConverterString.read(from),
            dimensions: FfiConverterOptionalTypeImageDimensions.read(from),
          });
        case 31:
          return new TagStandard.Thumb({
            url: FfiConverterString.read(from),
            dimensions: FfiConverterOptionalTypeImageDimensions.read(from),
          });
        case 32:
          return new TagStandard.Summary({
            summary: FfiConverterString.read(from),
          });
        case 33:
          return new TagStandard.Description({
            desc: FfiConverterString.read(from),
          });
        case 34:
          return new TagStandard.Bolt11({
            bolt11: FfiConverterString.read(from),
          });
        case 35:
          return new TagStandard.Preimage({
            preimage: FfiConverterString.read(from),
          });
        case 36:
          return new TagStandard.Relays({
            urls: FfiConverterArrayString.read(from),
          });
        case 37:
          return new TagStandard.Amount({
            millisats: FfiConverterUInt64.read(from),
            bolt11: FfiConverterOptionalString.read(from),
          });
        case 38:
          return new TagStandard.Lnurl({
            lnurl: FfiConverterString.read(from),
          });
        case 39:
          return new TagStandard.Name({ name: FfiConverterString.read(from) });
        case 40:
          return new TagStandard.PublishedAt({
            timestamp: FfiConverterTypeTimestamp.read(from),
          });
        case 41:
          return new TagStandard.UrlTag({ url: FfiConverterString.read(from) });
        case 42:
          return new TagStandard.MimeType({
            mime: FfiConverterString.read(from),
          });
        case 43:
          return new TagStandard.Aes256Gcm({
            key: FfiConverterString.read(from),
            iv: FfiConverterString.read(from),
          });
        case 44:
          return new TagStandard.Sha256({
            hash: FfiConverterString.read(from),
          });
        case 45:
          return new TagStandard.Size({ size: FfiConverterUInt64.read(from) });
        case 46:
          return new TagStandard.Dim({
            dimensions: FfiConverterTypeImageDimensions.read(from),
          });
        case 47:
          return new TagStandard.Magnet({ uri: FfiConverterString.read(from) });
        case 48:
          return new TagStandard.Blurhash({
            blurhash: FfiConverterString.read(from),
          });
        case 49:
          return new TagStandard.Streaming({
            url: FfiConverterString.read(from),
          });
        case 50:
          return new TagStandard.Recording({
            url: FfiConverterString.read(from),
          });
        case 51:
          return new TagStandard.Starts({
            timestamp: FfiConverterTypeTimestamp.read(from),
          });
        case 52:
          return new TagStandard.Ends({
            timestamp: FfiConverterTypeTimestamp.read(from),
          });
        case 53:
          return new TagStandard.LiveEventStatusTag({
            status: FfiConverterTypeLiveEventStatus.read(from),
          });
        case 54:
          return new TagStandard.CurrentParticipants({
            num: FfiConverterUInt64.read(from),
          });
        case 55:
          return new TagStandard.TotalParticipants({
            num: FfiConverterUInt64.read(from),
          });
        case 56:
          return new TagStandard.AbsoluteUrl({
            url: FfiConverterString.read(from),
          });
        case 57:
          return new TagStandard.Method({
            method: FfiConverterTypeHttpMethod.read(from),
          });
        case 58:
          return new TagStandard.Payload({
            hash: FfiConverterString.read(from),
          });
        case 59:
          return new TagStandard.Anon({
            msg: FfiConverterOptionalString.read(from),
          });
        case 60:
          return new TagStandard.Proxy({
            id: FfiConverterString.read(from),
            protocol: FfiConverterTypeProtocol.read(from),
          });
        case 61:
          return new TagStandard.Emoji({
            shortcode: FfiConverterString.read(from),
            url: FfiConverterString.read(from),
          });
        case 62:
          return new TagStandard.Encrypted();
        case 63:
          return new TagStandard.Request({
            event: FfiConverterTypeEvent.read(from),
          });
        case 64:
          return new TagStandard.DataVendingMachineStatusTag({
            status: FfiConverterTypeDataVendingMachineStatus.read(from),
            extraInfo: FfiConverterOptionalString.read(from),
          });
        case 65:
          return new TagStandard.LabelNamespace({
            namespace: FfiConverterString.read(from),
          });
        case 66:
          return new TagStandard.Label({
            label: FfiConverterArrayString.read(from),
          });
        case 67:
          return new TagStandard.Protected();
        case 68:
          return new TagStandard.Alt({
            summary: FfiConverterString.read(from),
          });
        case 69:
          return new TagStandard.Word({ word: FfiConverterString.read(from) });
        case 70:
          return new TagStandard.Web({
            urls: FfiConverterArrayString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case TagStandard_Tags.EventTag: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeEventId.write(inner.eventId, into);
          FfiConverterOptionalString.write(inner.relayUrl, into);
          FfiConverterOptionalTypeMarker.write(inner.marker, into);
          FfiConverterOptionalTypePublicKey.write(inner.publicKey, into);
          FfiConverterBool.write(inner.uppercase, into);
          return;
        }
        case TagStandard_Tags.Quote: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeEventId.write(inner.eventId, into);
          FfiConverterOptionalString.write(inner.relayUrl, into);
          FfiConverterOptionalTypePublicKey.write(inner.publicKey, into);
          return;
        }
        case TagStandard_Tags.GitClone: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterArrayString.write(inner.urls, into);
          return;
        }
        case TagStandard_Tags.GitCommit: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.hash, into);
          return;
        }
        case TagStandard_Tags.GitEarliestUniqueCommitId: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner.commit, into);
          return;
        }
        case TagStandard_Tags.GitMaintainers: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterArrayTypePublicKey.write(inner.publicKeys, into);
          return;
        }
        case TagStandard_Tags.PublicKeyTag: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterTypePublicKey.write(inner.publicKey, into);
          FfiConverterOptionalString.write(inner.relayUrl, into);
          FfiConverterOptionalString.write(inner.alias, into);
          FfiConverterBool.write(inner.uppercase, into);
          return;
        }
        case TagStandard_Tags.EventReport: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterTypeEventId.write(inner.eventId, into);
          FfiConverterTypeReport.write(inner.report, into);
          return;
        }
        case TagStandard_Tags.PubKeyReport: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterTypePublicKey.write(inner.publicKey, into);
          FfiConverterTypeReport.write(inner.report, into);
          return;
        }
        case TagStandard_Tags.PublicKeyLiveEvent: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterTypePublicKey.write(inner.publicKey, into);
          FfiConverterOptionalString.write(inner.relayUrl, into);
          FfiConverterTypeLiveEventMarker.write(inner.marker, into);
          FfiConverterOptionalString.write(inner.proof, into);
          return;
        }
        case TagStandard_Tags.Reference: {
          ordinalConverter.write(11, into);
          const inner = value.inner;
          FfiConverterString.write(inner.reference, into);
          return;
        }
        case TagStandard_Tags.RelayMetadataTag: {
          ordinalConverter.write(12, into);
          const inner = value.inner;
          FfiConverterString.write(inner.relayUrl, into);
          FfiConverterOptionalTypeRelayMetadata.write(inner.rw, into);
          return;
        }
        case TagStandard_Tags.Hashtag: {
          ordinalConverter.write(13, into);
          const inner = value.inner;
          FfiConverterString.write(inner.hashtag, into);
          return;
        }
        case TagStandard_Tags.Geohash: {
          ordinalConverter.write(14, into);
          const inner = value.inner;
          FfiConverterString.write(inner.geohash, into);
          return;
        }
        case TagStandard_Tags.Identifier: {
          ordinalConverter.write(15, into);
          const inner = value.inner;
          FfiConverterString.write(inner.identifier, into);
          return;
        }
        case TagStandard_Tags.ExternalContent: {
          ordinalConverter.write(16, into);
          const inner = value.inner;
          FfiConverterTypeExternalContentId.write(inner.content, into);
          FfiConverterOptionalString.write(inner.hint, into);
          FfiConverterBool.write(inner.uppercase, into);
          return;
        }
        case TagStandard_Tags.ExternalIdentity: {
          ordinalConverter.write(17, into);
          const inner = value.inner;
          FfiConverterTypeIdentity.write(inner.identity, into);
          return;
        }
        case TagStandard_Tags.CoordinateTag: {
          ordinalConverter.write(18, into);
          const inner = value.inner;
          FfiConverterTypeCoordinate.write(inner.coordinate, into);
          FfiConverterOptionalString.write(inner.relayUrl, into);
          FfiConverterBool.write(inner.uppercase, into);
          return;
        }
        case TagStandard_Tags.KindTag: {
          ordinalConverter.write(19, into);
          const inner = value.inner;
          FfiConverterTypeKind.write(inner.kind, into);
          FfiConverterBool.write(inner.uppercase, into);
          return;
        }
        case TagStandard_Tags.RelayUrl: {
          ordinalConverter.write(20, into);
          const inner = value.inner;
          FfiConverterString.write(inner.relayUrl, into);
          return;
        }
        case TagStandard_Tags.AllRelays: {
          ordinalConverter.write(21, into);
          return;
        }
        case TagStandard_Tags.Pow: {
          ordinalConverter.write(22, into);
          const inner = value.inner;
          FfiConverterString.write(inner.nonce, into);
          FfiConverterUInt8.write(inner.difficulty, into);
          return;
        }
        case TagStandard_Tags.Client: {
          ordinalConverter.write(23, into);
          const inner = value.inner;
          FfiConverterString.write(inner.name, into);
          FfiConverterOptionalTypeTagClientAddress.write(inner.address, into);
          return;
        }
        case TagStandard_Tags.Delegation: {
          ordinalConverter.write(24, into);
          const inner = value.inner;
          FfiConverterTypePublicKey.write(inner.delegator, into);
          FfiConverterString.write(inner.conditions, into);
          FfiConverterString.write(inner.sig, into);
          return;
        }
        case TagStandard_Tags.ContentWarning: {
          ordinalConverter.write(25, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.reason, into);
          return;
        }
        case TagStandard_Tags.Expiration: {
          ordinalConverter.write(26, into);
          const inner = value.inner;
          FfiConverterTypeTimestamp.write(inner.timestamp, into);
          return;
        }
        case TagStandard_Tags.Subject: {
          ordinalConverter.write(27, into);
          const inner = value.inner;
          FfiConverterString.write(inner.subject, into);
          return;
        }
        case TagStandard_Tags.Challenge: {
          ordinalConverter.write(28, into);
          const inner = value.inner;
          FfiConverterString.write(inner.challenge, into);
          return;
        }
        case TagStandard_Tags.Title: {
          ordinalConverter.write(29, into);
          const inner = value.inner;
          FfiConverterString.write(inner.title, into);
          return;
        }
        case TagStandard_Tags.Image: {
          ordinalConverter.write(30, into);
          const inner = value.inner;
          FfiConverterString.write(inner.url, into);
          FfiConverterOptionalTypeImageDimensions.write(inner.dimensions, into);
          return;
        }
        case TagStandard_Tags.Thumb: {
          ordinalConverter.write(31, into);
          const inner = value.inner;
          FfiConverterString.write(inner.url, into);
          FfiConverterOptionalTypeImageDimensions.write(inner.dimensions, into);
          return;
        }
        case TagStandard_Tags.Summary: {
          ordinalConverter.write(32, into);
          const inner = value.inner;
          FfiConverterString.write(inner.summary, into);
          return;
        }
        case TagStandard_Tags.Description: {
          ordinalConverter.write(33, into);
          const inner = value.inner;
          FfiConverterString.write(inner.desc, into);
          return;
        }
        case TagStandard_Tags.Bolt11: {
          ordinalConverter.write(34, into);
          const inner = value.inner;
          FfiConverterString.write(inner.bolt11, into);
          return;
        }
        case TagStandard_Tags.Preimage: {
          ordinalConverter.write(35, into);
          const inner = value.inner;
          FfiConverterString.write(inner.preimage, into);
          return;
        }
        case TagStandard_Tags.Relays: {
          ordinalConverter.write(36, into);
          const inner = value.inner;
          FfiConverterArrayString.write(inner.urls, into);
          return;
        }
        case TagStandard_Tags.Amount: {
          ordinalConverter.write(37, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.millisats, into);
          FfiConverterOptionalString.write(inner.bolt11, into);
          return;
        }
        case TagStandard_Tags.Lnurl: {
          ordinalConverter.write(38, into);
          const inner = value.inner;
          FfiConverterString.write(inner.lnurl, into);
          return;
        }
        case TagStandard_Tags.Name: {
          ordinalConverter.write(39, into);
          const inner = value.inner;
          FfiConverterString.write(inner.name, into);
          return;
        }
        case TagStandard_Tags.PublishedAt: {
          ordinalConverter.write(40, into);
          const inner = value.inner;
          FfiConverterTypeTimestamp.write(inner.timestamp, into);
          return;
        }
        case TagStandard_Tags.UrlTag: {
          ordinalConverter.write(41, into);
          const inner = value.inner;
          FfiConverterString.write(inner.url, into);
          return;
        }
        case TagStandard_Tags.MimeType: {
          ordinalConverter.write(42, into);
          const inner = value.inner;
          FfiConverterString.write(inner.mime, into);
          return;
        }
        case TagStandard_Tags.Aes256Gcm: {
          ordinalConverter.write(43, into);
          const inner = value.inner;
          FfiConverterString.write(inner.key, into);
          FfiConverterString.write(inner.iv, into);
          return;
        }
        case TagStandard_Tags.Sha256: {
          ordinalConverter.write(44, into);
          const inner = value.inner;
          FfiConverterString.write(inner.hash, into);
          return;
        }
        case TagStandard_Tags.Size: {
          ordinalConverter.write(45, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.size, into);
          return;
        }
        case TagStandard_Tags.Dim: {
          ordinalConverter.write(46, into);
          const inner = value.inner;
          FfiConverterTypeImageDimensions.write(inner.dimensions, into);
          return;
        }
        case TagStandard_Tags.Magnet: {
          ordinalConverter.write(47, into);
          const inner = value.inner;
          FfiConverterString.write(inner.uri, into);
          return;
        }
        case TagStandard_Tags.Blurhash: {
          ordinalConverter.write(48, into);
          const inner = value.inner;
          FfiConverterString.write(inner.blurhash, into);
          return;
        }
        case TagStandard_Tags.Streaming: {
          ordinalConverter.write(49, into);
          const inner = value.inner;
          FfiConverterString.write(inner.url, into);
          return;
        }
        case TagStandard_Tags.Recording: {
          ordinalConverter.write(50, into);
          const inner = value.inner;
          FfiConverterString.write(inner.url, into);
          return;
        }
        case TagStandard_Tags.Starts: {
          ordinalConverter.write(51, into);
          const inner = value.inner;
          FfiConverterTypeTimestamp.write(inner.timestamp, into);
          return;
        }
        case TagStandard_Tags.Ends: {
          ordinalConverter.write(52, into);
          const inner = value.inner;
          FfiConverterTypeTimestamp.write(inner.timestamp, into);
          return;
        }
        case TagStandard_Tags.LiveEventStatusTag: {
          ordinalConverter.write(53, into);
          const inner = value.inner;
          FfiConverterTypeLiveEventStatus.write(inner.status, into);
          return;
        }
        case TagStandard_Tags.CurrentParticipants: {
          ordinalConverter.write(54, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.num, into);
          return;
        }
        case TagStandard_Tags.TotalParticipants: {
          ordinalConverter.write(55, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.num, into);
          return;
        }
        case TagStandard_Tags.AbsoluteUrl: {
          ordinalConverter.write(56, into);
          const inner = value.inner;
          FfiConverterString.write(inner.url, into);
          return;
        }
        case TagStandard_Tags.Method: {
          ordinalConverter.write(57, into);
          const inner = value.inner;
          FfiConverterTypeHttpMethod.write(inner.method, into);
          return;
        }
        case TagStandard_Tags.Payload: {
          ordinalConverter.write(58, into);
          const inner = value.inner;
          FfiConverterString.write(inner.hash, into);
          return;
        }
        case TagStandard_Tags.Anon: {
          ordinalConverter.write(59, into);
          const inner = value.inner;
          FfiConverterOptionalString.write(inner.msg, into);
          return;
        }
        case TagStandard_Tags.Proxy: {
          ordinalConverter.write(60, into);
          const inner = value.inner;
          FfiConverterString.write(inner.id, into);
          FfiConverterTypeProtocol.write(inner.protocol, into);
          return;
        }
        case TagStandard_Tags.Emoji: {
          ordinalConverter.write(61, into);
          const inner = value.inner;
          FfiConverterString.write(inner.shortcode, into);
          FfiConverterString.write(inner.url, into);
          return;
        }
        case TagStandard_Tags.Encrypted: {
          ordinalConverter.write(62, into);
          return;
        }
        case TagStandard_Tags.Request: {
          ordinalConverter.write(63, into);
          const inner = value.inner;
          FfiConverterTypeEvent.write(inner.event, into);
          return;
        }
        case TagStandard_Tags.DataVendingMachineStatusTag: {
          ordinalConverter.write(64, into);
          const inner = value.inner;
          FfiConverterTypeDataVendingMachineStatus.write(inner.status, into);
          FfiConverterOptionalString.write(inner.extraInfo, into);
          return;
        }
        case TagStandard_Tags.LabelNamespace: {
          ordinalConverter.write(65, into);
          const inner = value.inner;
          FfiConverterString.write(inner.namespace, into);
          return;
        }
        case TagStandard_Tags.Label: {
          ordinalConverter.write(66, into);
          const inner = value.inner;
          FfiConverterArrayString.write(inner.label, into);
          return;
        }
        case TagStandard_Tags.Protected: {
          ordinalConverter.write(67, into);
          return;
        }
        case TagStandard_Tags.Alt: {
          ordinalConverter.write(68, into);
          const inner = value.inner;
          FfiConverterString.write(inner.summary, into);
          return;
        }
        case TagStandard_Tags.Word: {
          ordinalConverter.write(69, into);
          const inner = value.inner;
          FfiConverterString.write(inner.word, into);
          return;
        }
        case TagStandard_Tags.Web: {
          ordinalConverter.write(70, into);
          const inner = value.inner;
          FfiConverterArrayString.write(inner.urls, into);
          return;
        }
        default:
          // Throwing from here means that TagStandard_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case TagStandard_Tags.EventTag: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeEventId.allocationSize(inner.eventId);
          size += FfiConverterOptionalString.allocationSize(inner.relayUrl);
          size += FfiConverterOptionalTypeMarker.allocationSize(inner.marker);
          size += FfiConverterOptionalTypePublicKey.allocationSize(
            inner.publicKey
          );
          size += FfiConverterBool.allocationSize(inner.uppercase);
          return size;
        }
        case TagStandard_Tags.Quote: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeEventId.allocationSize(inner.eventId);
          size += FfiConverterOptionalString.allocationSize(inner.relayUrl);
          size += FfiConverterOptionalTypePublicKey.allocationSize(
            inner.publicKey
          );
          return size;
        }
        case TagStandard_Tags.GitClone: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterArrayString.allocationSize(inner.urls);
          return size;
        }
        case TagStandard_Tags.GitCommit: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.hash);
          return size;
        }
        case TagStandard_Tags.GitEarliestUniqueCommitId: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner.commit);
          return size;
        }
        case TagStandard_Tags.GitMaintainers: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterArrayTypePublicKey.allocationSize(
            inner.publicKeys
          );
          return size;
        }
        case TagStandard_Tags.PublicKeyTag: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterTypePublicKey.allocationSize(inner.publicKey);
          size += FfiConverterOptionalString.allocationSize(inner.relayUrl);
          size += FfiConverterOptionalString.allocationSize(inner.alias);
          size += FfiConverterBool.allocationSize(inner.uppercase);
          return size;
        }
        case TagStandard_Tags.EventReport: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterTypeEventId.allocationSize(inner.eventId);
          size += FfiConverterTypeReport.allocationSize(inner.report);
          return size;
        }
        case TagStandard_Tags.PubKeyReport: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterTypePublicKey.allocationSize(inner.publicKey);
          size += FfiConverterTypeReport.allocationSize(inner.report);
          return size;
        }
        case TagStandard_Tags.PublicKeyLiveEvent: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterTypePublicKey.allocationSize(inner.publicKey);
          size += FfiConverterOptionalString.allocationSize(inner.relayUrl);
          size += FfiConverterTypeLiveEventMarker.allocationSize(inner.marker);
          size += FfiConverterOptionalString.allocationSize(inner.proof);
          return size;
        }
        case TagStandard_Tags.Reference: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(11);
          size += FfiConverterString.allocationSize(inner.reference);
          return size;
        }
        case TagStandard_Tags.RelayMetadataTag: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(12);
          size += FfiConverterString.allocationSize(inner.relayUrl);
          size += FfiConverterOptionalTypeRelayMetadata.allocationSize(
            inner.rw
          );
          return size;
        }
        case TagStandard_Tags.Hashtag: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(13);
          size += FfiConverterString.allocationSize(inner.hashtag);
          return size;
        }
        case TagStandard_Tags.Geohash: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(14);
          size += FfiConverterString.allocationSize(inner.geohash);
          return size;
        }
        case TagStandard_Tags.Identifier: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(15);
          size += FfiConverterString.allocationSize(inner.identifier);
          return size;
        }
        case TagStandard_Tags.ExternalContent: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(16);
          size += FfiConverterTypeExternalContentId.allocationSize(
            inner.content
          );
          size += FfiConverterOptionalString.allocationSize(inner.hint);
          size += FfiConverterBool.allocationSize(inner.uppercase);
          return size;
        }
        case TagStandard_Tags.ExternalIdentity: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(17);
          size += FfiConverterTypeIdentity.allocationSize(inner.identity);
          return size;
        }
        case TagStandard_Tags.CoordinateTag: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(18);
          size += FfiConverterTypeCoordinate.allocationSize(inner.coordinate);
          size += FfiConverterOptionalString.allocationSize(inner.relayUrl);
          size += FfiConverterBool.allocationSize(inner.uppercase);
          return size;
        }
        case TagStandard_Tags.KindTag: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(19);
          size += FfiConverterTypeKind.allocationSize(inner.kind);
          size += FfiConverterBool.allocationSize(inner.uppercase);
          return size;
        }
        case TagStandard_Tags.RelayUrl: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(20);
          size += FfiConverterString.allocationSize(inner.relayUrl);
          return size;
        }
        case TagStandard_Tags.AllRelays: {
          return ordinalConverter.allocationSize(21);
        }
        case TagStandard_Tags.Pow: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(22);
          size += FfiConverterString.allocationSize(inner.nonce);
          size += FfiConverterUInt8.allocationSize(inner.difficulty);
          return size;
        }
        case TagStandard_Tags.Client: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(23);
          size += FfiConverterString.allocationSize(inner.name);
          size += FfiConverterOptionalTypeTagClientAddress.allocationSize(
            inner.address
          );
          return size;
        }
        case TagStandard_Tags.Delegation: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(24);
          size += FfiConverterTypePublicKey.allocationSize(inner.delegator);
          size += FfiConverterString.allocationSize(inner.conditions);
          size += FfiConverterString.allocationSize(inner.sig);
          return size;
        }
        case TagStandard_Tags.ContentWarning: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(25);
          size += FfiConverterOptionalString.allocationSize(inner.reason);
          return size;
        }
        case TagStandard_Tags.Expiration: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(26);
          size += FfiConverterTypeTimestamp.allocationSize(inner.timestamp);
          return size;
        }
        case TagStandard_Tags.Subject: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(27);
          size += FfiConverterString.allocationSize(inner.subject);
          return size;
        }
        case TagStandard_Tags.Challenge: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(28);
          size += FfiConverterString.allocationSize(inner.challenge);
          return size;
        }
        case TagStandard_Tags.Title: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(29);
          size += FfiConverterString.allocationSize(inner.title);
          return size;
        }
        case TagStandard_Tags.Image: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(30);
          size += FfiConverterString.allocationSize(inner.url);
          size += FfiConverterOptionalTypeImageDimensions.allocationSize(
            inner.dimensions
          );
          return size;
        }
        case TagStandard_Tags.Thumb: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(31);
          size += FfiConverterString.allocationSize(inner.url);
          size += FfiConverterOptionalTypeImageDimensions.allocationSize(
            inner.dimensions
          );
          return size;
        }
        case TagStandard_Tags.Summary: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(32);
          size += FfiConverterString.allocationSize(inner.summary);
          return size;
        }
        case TagStandard_Tags.Description: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(33);
          size += FfiConverterString.allocationSize(inner.desc);
          return size;
        }
        case TagStandard_Tags.Bolt11: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(34);
          size += FfiConverterString.allocationSize(inner.bolt11);
          return size;
        }
        case TagStandard_Tags.Preimage: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(35);
          size += FfiConverterString.allocationSize(inner.preimage);
          return size;
        }
        case TagStandard_Tags.Relays: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(36);
          size += FfiConverterArrayString.allocationSize(inner.urls);
          return size;
        }
        case TagStandard_Tags.Amount: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(37);
          size += FfiConverterUInt64.allocationSize(inner.millisats);
          size += FfiConverterOptionalString.allocationSize(inner.bolt11);
          return size;
        }
        case TagStandard_Tags.Lnurl: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(38);
          size += FfiConverterString.allocationSize(inner.lnurl);
          return size;
        }
        case TagStandard_Tags.Name: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(39);
          size += FfiConverterString.allocationSize(inner.name);
          return size;
        }
        case TagStandard_Tags.PublishedAt: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(40);
          size += FfiConverterTypeTimestamp.allocationSize(inner.timestamp);
          return size;
        }
        case TagStandard_Tags.UrlTag: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(41);
          size += FfiConverterString.allocationSize(inner.url);
          return size;
        }
        case TagStandard_Tags.MimeType: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(42);
          size += FfiConverterString.allocationSize(inner.mime);
          return size;
        }
        case TagStandard_Tags.Aes256Gcm: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(43);
          size += FfiConverterString.allocationSize(inner.key);
          size += FfiConverterString.allocationSize(inner.iv);
          return size;
        }
        case TagStandard_Tags.Sha256: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(44);
          size += FfiConverterString.allocationSize(inner.hash);
          return size;
        }
        case TagStandard_Tags.Size: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(45);
          size += FfiConverterUInt64.allocationSize(inner.size);
          return size;
        }
        case TagStandard_Tags.Dim: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(46);
          size += FfiConverterTypeImageDimensions.allocationSize(
            inner.dimensions
          );
          return size;
        }
        case TagStandard_Tags.Magnet: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(47);
          size += FfiConverterString.allocationSize(inner.uri);
          return size;
        }
        case TagStandard_Tags.Blurhash: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(48);
          size += FfiConverterString.allocationSize(inner.blurhash);
          return size;
        }
        case TagStandard_Tags.Streaming: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(49);
          size += FfiConverterString.allocationSize(inner.url);
          return size;
        }
        case TagStandard_Tags.Recording: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(50);
          size += FfiConverterString.allocationSize(inner.url);
          return size;
        }
        case TagStandard_Tags.Starts: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(51);
          size += FfiConverterTypeTimestamp.allocationSize(inner.timestamp);
          return size;
        }
        case TagStandard_Tags.Ends: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(52);
          size += FfiConverterTypeTimestamp.allocationSize(inner.timestamp);
          return size;
        }
        case TagStandard_Tags.LiveEventStatusTag: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(53);
          size += FfiConverterTypeLiveEventStatus.allocationSize(inner.status);
          return size;
        }
        case TagStandard_Tags.CurrentParticipants: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(54);
          size += FfiConverterUInt64.allocationSize(inner.num);
          return size;
        }
        case TagStandard_Tags.TotalParticipants: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(55);
          size += FfiConverterUInt64.allocationSize(inner.num);
          return size;
        }
        case TagStandard_Tags.AbsoluteUrl: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(56);
          size += FfiConverterString.allocationSize(inner.url);
          return size;
        }
        case TagStandard_Tags.Method: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(57);
          size += FfiConverterTypeHttpMethod.allocationSize(inner.method);
          return size;
        }
        case TagStandard_Tags.Payload: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(58);
          size += FfiConverterString.allocationSize(inner.hash);
          return size;
        }
        case TagStandard_Tags.Anon: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(59);
          size += FfiConverterOptionalString.allocationSize(inner.msg);
          return size;
        }
        case TagStandard_Tags.Proxy: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(60);
          size += FfiConverterString.allocationSize(inner.id);
          size += FfiConverterTypeProtocol.allocationSize(inner.protocol);
          return size;
        }
        case TagStandard_Tags.Emoji: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(61);
          size += FfiConverterString.allocationSize(inner.shortcode);
          size += FfiConverterString.allocationSize(inner.url);
          return size;
        }
        case TagStandard_Tags.Encrypted: {
          return ordinalConverter.allocationSize(62);
        }
        case TagStandard_Tags.Request: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(63);
          size += FfiConverterTypeEvent.allocationSize(inner.event);
          return size;
        }
        case TagStandard_Tags.DataVendingMachineStatusTag: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(64);
          size += FfiConverterTypeDataVendingMachineStatus.allocationSize(
            inner.status
          );
          size += FfiConverterOptionalString.allocationSize(inner.extraInfo);
          return size;
        }
        case TagStandard_Tags.LabelNamespace: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(65);
          size += FfiConverterString.allocationSize(inner.namespace);
          return size;
        }
        case TagStandard_Tags.Label: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(66);
          size += FfiConverterArrayString.allocationSize(inner.label);
          return size;
        }
        case TagStandard_Tags.Protected: {
          return ordinalConverter.allocationSize(67);
        }
        case TagStandard_Tags.Alt: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(68);
          size += FfiConverterString.allocationSize(inner.summary);
          return size;
        }
        case TagStandard_Tags.Word: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(69);
          size += FfiConverterString.allocationSize(inner.word);
          return size;
        }
        case TagStandard_Tags.Web: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(70);
          size += FfiConverterArrayString.allocationSize(inner.urls);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * Transaction Type
 */
export enum TransactionType {
  /**
   * Incoming payments
   */
  Incoming,
  /**
   * Outgoing payments
   */
  Outgoing,
}

const FfiConverterTypeTransactionType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TransactionType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return TransactionType.Incoming;
        case 2:
          return TransactionType.Outgoing;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case TransactionType.Incoming:
          return ordinalConverter.write(1, into);
        case TransactionType.Outgoing:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: WebSocketMessage
export enum WebSocketMessage_Tags {
  Text = 'Text',
  Binary = 'Binary',
  Ping = 'Ping',
  Pong = 'Pong',
  Close = 'Close',
}
export const WebSocketMessage = (() => {
  type Text__interface = {
    tag: WebSocketMessage_Tags.Text;
    inner: Readonly<[string]>;
  };

  class Text_ extends UniffiEnum implements Text__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'WebSocketMessage';
    readonly tag = WebSocketMessage_Tags.Text;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('WebSocketMessage', 'Text');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Text_ {
      return new Text_(v0);
    }

    static instanceOf(obj: any): obj is Text_ {
      return obj.tag === WebSocketMessage_Tags.Text;
    }
  }

  type Binary__interface = {
    tag: WebSocketMessage_Tags.Binary;
    inner: Readonly<[ArrayBuffer]>;
  };

  class Binary_ extends UniffiEnum implements Binary__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'WebSocketMessage';
    readonly tag = WebSocketMessage_Tags.Binary;
    readonly inner: Readonly<[ArrayBuffer]>;
    constructor(v0: ArrayBuffer) {
      super('WebSocketMessage', 'Binary');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: ArrayBuffer): Binary_ {
      return new Binary_(v0);
    }

    static instanceOf(obj: any): obj is Binary_ {
      return obj.tag === WebSocketMessage_Tags.Binary;
    }
  }

  type Ping__interface = {
    tag: WebSocketMessage_Tags.Ping;
    inner: Readonly<[ArrayBuffer]>;
  };

  class Ping_ extends UniffiEnum implements Ping__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'WebSocketMessage';
    readonly tag = WebSocketMessage_Tags.Ping;
    readonly inner: Readonly<[ArrayBuffer]>;
    constructor(v0: ArrayBuffer) {
      super('WebSocketMessage', 'Ping');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: ArrayBuffer): Ping_ {
      return new Ping_(v0);
    }

    static instanceOf(obj: any): obj is Ping_ {
      return obj.tag === WebSocketMessage_Tags.Ping;
    }
  }

  type Pong__interface = {
    tag: WebSocketMessage_Tags.Pong;
    inner: Readonly<[ArrayBuffer]>;
  };

  class Pong_ extends UniffiEnum implements Pong__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'WebSocketMessage';
    readonly tag = WebSocketMessage_Tags.Pong;
    readonly inner: Readonly<[ArrayBuffer]>;
    constructor(v0: ArrayBuffer) {
      super('WebSocketMessage', 'Pong');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: ArrayBuffer): Pong_ {
      return new Pong_(v0);
    }

    static instanceOf(obj: any): obj is Pong_ {
      return obj.tag === WebSocketMessage_Tags.Pong;
    }
  }

  type Close__interface = {
    tag: WebSocketMessage_Tags.Close;
    inner: Readonly<[WebSocketCloseFrame | undefined]>;
  };

  class Close_ extends UniffiEnum implements Close__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'WebSocketMessage';
    readonly tag = WebSocketMessage_Tags.Close;
    readonly inner: Readonly<[WebSocketCloseFrame | undefined]>;
    constructor(v0: WebSocketCloseFrame | undefined) {
      super('WebSocketMessage', 'Close');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: WebSocketCloseFrame | undefined): Close_ {
      return new Close_(v0);
    }

    static instanceOf(obj: any): obj is Close_ {
      return obj.tag === WebSocketMessage_Tags.Close;
    }
  }

  function instanceOf(obj: any): obj is WebSocketMessage {
    return obj[uniffiTypeNameSymbol] === 'WebSocketMessage';
  }

  return Object.freeze({
    instanceOf,
    Text: Text_,
    Binary: Binary_,
    Ping: Ping_,
    Pong: Pong_,
    Close: Close_,
  });
})();

export type WebSocketMessage = InstanceType<
  (typeof WebSocketMessage)[keyof Omit<typeof WebSocketMessage, 'instanceOf'>]
>;

// FfiConverter for enum WebSocketMessage
const FfiConverterTypeWebSocketMessage = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = WebSocketMessage;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new WebSocketMessage.Text(FfiConverterString.read(from));
        case 2:
          return new WebSocketMessage.Binary(
            FfiConverterArrayBuffer.read(from)
          );
        case 3:
          return new WebSocketMessage.Ping(FfiConverterArrayBuffer.read(from));
        case 4:
          return new WebSocketMessage.Pong(FfiConverterArrayBuffer.read(from));
        case 5:
          return new WebSocketMessage.Close(
            FfiConverterOptionalTypeWebSocketCloseFrame.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case WebSocketMessage_Tags.Text: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case WebSocketMessage_Tags.Binary: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterArrayBuffer.write(inner[0], into);
          return;
        }
        case WebSocketMessage_Tags.Ping: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterArrayBuffer.write(inner[0], into);
          return;
        }
        case WebSocketMessage_Tags.Pong: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterArrayBuffer.write(inner[0], into);
          return;
        }
        case WebSocketMessage_Tags.Close: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterOptionalTypeWebSocketCloseFrame.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that WebSocketMessage_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case WebSocketMessage_Tags.Text: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case WebSocketMessage_Tags.Binary: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterArrayBuffer.allocationSize(inner[0]);
          return size;
        }
        case WebSocketMessage_Tags.Ping: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterArrayBuffer.allocationSize(inner[0]);
          return size;
        }
        case WebSocketMessage_Tags.Pong: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterArrayBuffer.allocationSize(inner[0]);
          return size;
        }
        case WebSocketMessage_Tags.Close: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterOptionalTypeWebSocketCloseFrame.allocationSize(
            inner[0]
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum ZapType {
  /**
   * Public
   */
  Public,
  /**
   * Private
   */
  Private,
  /**
   * Anonymous
   */
  Anonymous,
}

const FfiConverterTypeZapType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ZapType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return ZapType.Public;
        case 2:
          return ZapType.Private;
        case 3:
          return ZapType.Anonymous;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case ZapType.Public:
          return ordinalConverter.write(1, into);
        case ZapType.Private:
          return ordinalConverter.write(2, into);
        case ZapType.Anonymous:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for Map<string, string>
const FfiConverterMapStringString = new FfiConverterMap(
  FfiConverterString,
  FfiConverterString
);

export interface AdmitPolicy {
  /**
   * Admit Event
   *
   * Returns `AdmitStatus::Success` if the event is admitted, otherwise `AdmitStatus::Rejected`.
   */
  admitEvent(
    relayUrl: string,
    subscriptionId: string,
    event: EventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<AdmitStatus>;
}

export class AdmitPolicyImpl
  extends UniffiAbstractObject
  implements AdmitPolicy
{
  readonly [uniffiTypeNameSymbol] = 'AdmitPolicyImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeAdmitPolicyImplObjectFactory.bless(pointer);
  }

  /**
   * Admit Event
   *
   * Returns `AdmitStatus::Success` if the event is admitted, otherwise `AdmitStatus::Rejected`.
   */
  public async admitEvent(
    relayUrl: string,
    subscriptionId: string,
    event: EventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<AdmitStatus> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_admitpolicy_admit_event(
            uniffiTypeAdmitPolicyImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(relayUrl),
            FfiConverterString.lower(subscriptionId),
            FfiConverterTypeEvent.lower(event)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeAdmitStatus.lift.bind(
          FfiConverterTypeAdmitStatus
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeAdmitPolicyImplObjectFactory.pointer(this);
      uniffiTypeAdmitPolicyImplObjectFactory.freePointer(pointer);
      uniffiTypeAdmitPolicyImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is AdmitPolicyImpl {
    return uniffiTypeAdmitPolicyImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeAdmitPolicyImplObjectFactory: UniffiObjectFactory<AdmitPolicy> =
  {
    create(pointer: UnsafeMutableRawPointer): AdmitPolicy {
      const instance = Object.create(AdmitPolicyImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'AdmitPolicyImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_admitpolicy_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: AdmitPolicy): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: AdmitPolicy): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_admitpolicy(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_admitpolicy(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is AdmitPolicy {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'AdmitPolicyImpl'
      );
    },
  };
// FfiConverter for AdmitPolicy
const FfiConverterTypeAdmitPolicy = new FfiConverterObjectWithCallbacks(
  uniffiTypeAdmitPolicyImplObjectFactory
);

// Add a vtavble for the callbacks that go in AdmitPolicy.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceAdmitPolicy: {
  vtable: UniffiVTableCallbackInterfaceAdmitPolicy;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    admitEvent: (
      uniffiHandle: bigint,
      relayUrl: Uint8Array,
      subscriptionId: Uint8Array,
      event: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<AdmitStatus> => {
        const jsCallback = FfiConverterTypeAdmitPolicy.lift(uniffiHandle);
        return await jsCallback.admitEvent(
          FfiConverterString.lift(relayUrl),
          FfiConverterString.lift(subscriptionId),
          FfiConverterTypeEvent.lift(event),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: AdmitStatus) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterTypeAdmitStatus.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ NostrSdkError.instanceOf,
        /*lowerError:*/ FfiConverterTypeNostrSdkError.lower.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // AdmitPolicy: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeAdmitPolicy.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_init_callback_vtable_admitpolicy(
      uniffiCallbackInterfaceAdmitPolicy.vtable
    );
  },
};

export interface ClientInterface {
  /**
   * Add discovery relay
   *
   * If relay already exists, this method automatically add the `DISCOVERY` flag to it and return `false`.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/65.md>
   */
  addDiscoveryRelay(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  /**
   * Add read relay
   *
   * If relay already exists, this method add the `READ` flag to it and return `false`.
   */
  addReadRelay(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  /**
   * Add new relay
   *
   * Relays added with this method will have both `READ` and `WRITE` flags enabled
   *
   * If the relay already exists, the flags will be updated and `false` returned.
   *
   * If are set pool subscriptions, the new added relay will inherit them. Use `subscribe_to` method instead of `subscribe`,
   * to avoid to set pool subscriptions.
   *
   * This method use previously set or default `Options` to configure the `Relay` (ex. set proxy, set min POW, set relay limits, ...).
   *
   * Connection is **NOT** automatically started with relay, remember to call `connect` method!
   */
  addRelay(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  /**
   * Add new relay with custom options
   */
  addRelayWithOpts(
    url: string,
    opts: RelayOptionsInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  /**
   * Add write relay
   *
   * If relay already exists, this method add the `WRITE` flag to it and return `false`.
   */
  addWriteRelay(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<boolean>;
  /**
   * Auto authenticate to relays (default: true)
   *
   * <https://github.com/nostr-protocol/nips/blob/master/42.md>
   */
  automaticAuthentication(enable: boolean): void;
  /**
   * Connect to all added relays
   *
   * Attempts to initiate a connection for every relay currently in
   * [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`].
   * A background connection task is spawned for each such relay, which then tries
   * to establish the connection.
   * Any relay not in one of these two statuses is skipped.
   *
   * For further details, see the documentation of [`Relay::connect`].
   */
  connect(asyncOpts_?: { signal: AbortSignal }): Promise<void>;
  /**
   * Connect to a previously added relay
   */
  connectRelay(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  database(): NostrDatabaseInterface;
  /**
   * Disconnect from all relays
   */
  disconnect(asyncOpts_?: { signal: AbortSignal }): Promise<void>;
  disconnectRelay(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Get events both from database and relays
   *
   * This is an auto-closing subscription and will be closed automatically on `EOSE`.
   *
   * You can obtain the same result by merging the `Events` from different type of sources.
   *
   * This method will be deprecated in the future!
   * This is a temporary solution for who still want to query events both from database and relays and merge the result.
   * The optimal solution is to execute a [`Client::sync`] to get all old events, [`Client::subscribe`] to get all
   * new future events, [`NostrDatabase::query`] to query events and [`Client::handle_notifications`] to listen-for/handle new events (i.e. to know when update the UI).
   * This will allow very fast queries, low bandwidth usage (depending on how many events the client have to sync) and a low load on relays.
   *
   * # Gossip
   *
   * If `gossip` is enabled (see [`Options::gossip`]) the events will be requested also to
   * NIP65 relays (automatically discovered) of public keys included in filters (if any).
   */
  fetchCombinedEvents(
    filter: FilterInterface,
    timeout: UniffiDuration,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<EventsInterface>;
  /**
   * Fetch events from relays
   *
   * This is an auto-closing subscription and will be closed automatically on `EOSE`.
   *
   * # Gossip
   *
   * If `gossip` is enabled (see `Options`) the events will be requested also to
   * NIP65 relays (automatically discovered) of public keys included in filters (if any).
   */
  fetchEvents(
    filter: FilterInterface,
    timeout: UniffiDuration,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<EventsInterface>;
  /**
   * Fetch events from specific relays
   *
   * This is an auto-closing subscription and will be closed automatically on `EOSE`.
   */
  fetchEventsFrom(
    urls: Array<string>,
    filter: FilterInterface,
    timeout: UniffiDuration,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<EventsInterface>;
  /**
   * Fetch the newest public key metadata from relays.
   *
   * Returns `None` if the `Metadata` of the `PublicKey` has not been found.
   *
   * Check `Client::fetch_events` for more details.
   *
   * If you only want to consult cached data,
   * consider `client.database().profile(PUBKEY)`.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  fetchMetadata(
    publicKey: PublicKeyInterface,
    timeout: UniffiDuration,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<MetadataInterface | undefined>;
  /**
   * Disconnect and force remove all relays
   */
  forceRemoveAllRelays(asyncOpts_?: { signal: AbortSignal }): Promise<void>;
  /**
   * Force remove and disconnect relay
   *
   * Note: this method will remove the relay, also if it's in use for the gossip model or other service!
   */
  forceRemoveRelay(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Construct Gift Wrap and send to relays
   *
   * Check `send_event` method to know how sending events works.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/59.md>
   */
  giftWrap(
    receiver: PublicKeyInterface,
    rumor: UnsignedEventInterface,
    extraTags: Array<TagInterface>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SendEventOutput>;
  /**
   * Construct Gift Wrap and send to specific relays
   *
   * <https://github.com/nostr-protocol/nips/blob/master/59.md>
   */
  giftWrapTo(
    urls: Array<string>,
    receiver: PublicKeyInterface,
    rumor: UnsignedEventInterface,
    extraTags: Array<TagInterface>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SendEventOutput>;
  /**
   * Handle notifications
   */
  handleNotifications(
    handler: HandleNotification,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  relay(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<RelayInterface>;
  /**
   * Get relays with `READ` or `WRITE` flags
   */
  relays(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Map<string, RelayInterface>>;
  /**
   * Disconnect and remove all relays
   *
   * Some relays used by some services could not be disconnected with this method
   * (like the ones used for gossip).
   * Use [`Client::force_remove_all_relays`] to remove every relay.
   */
  removeAllRelays(asyncOpts_?: { signal: AbortSignal }): Promise<void>;
  /**
   * Remove and disconnect relay
   *
   * If the relay has `GOSSIP` flag, it will not be removed from the pool and its
   * flags will be updated (remove `READ`, `WRITE` and `DISCOVERY` flags).
   */
  removeRelay(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Send event
   *
   * Send event to all relays with `WRITE` flag.
   * If `gossip` is enabled (see `Options`) the event will be sent also to NIP65 relays (automatically discovered).
   */
  sendEvent(
    event: EventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SendEventOutput>;
  /**
   * Take an `EventBuilder`, sign it by using the `NostrSigner` and broadcast to relays (check `send_event` method for more details)
   *
   * Rise an error if the `NostrSigner` is not set.
   */
  sendEventBuilder(
    builder: EventBuilderInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SendEventOutput>;
  /**
   * Take an `EventBuilder`, sign it by using the `NostrSigner` and broadcast to specific relays.
   *
   * Rise an error if the `NostrSigner` is not set.
   */
  sendEventBuilderTo(
    urls: Array<string>,
    builder: EventBuilderInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SendEventOutput>;
  /**
   * Send event to specific relays.
   */
  sendEventTo(
    urls: Array<string>,
    event: EventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SendEventOutput>;
  sendMsgTo(
    urls: Array<string>,
    msg: ClientMessageInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Output>;
  /**
   * Send a private direct message
   *
   * If gossip is enabled, the message will be sent to the NIP17 relays (automatically discovered).
   * If gossip is not enabled will be sent to all relays with WRITE` relay service flag.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/17.md>
   */
  sendPrivateMsg(
    receiver: PublicKeyInterface,
    message: string,
    rumorExtraTags: Array<TagInterface>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SendEventOutput>;
  /**
   * Send private direct message to specific relays
   *
   * <https://github.com/nostr-protocol/nips/blob/master/17.md>
   */
  sendPrivateMsgTo(
    urls: Array<string>,
    receiver: PublicKeyInterface,
    message: string,
    rumorExtraTags: Array<TagInterface>,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SendEventOutput>;
  setMetadata(
    metadata: MetadataInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SendEventOutput>;
  shutdown(asyncOpts_?: { signal: AbortSignal }): Promise<void>;
  /**
   * Signs the `EventBuilder` into an `Event` using the `NostrSigner`
   */
  signEventBuilder(
    builder: EventBuilderInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<EventInterface>;
  signer(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<NostrSignerInterface>;
  /**
   * Subscribe to filters
   *
   * If `gossip` is enabled (see `Options]) the events will be requested also to
   * NIP65 relays (automatically discovered) of public keys included in filters (if any).
   *
   * ### Auto-closing subscription
   *
   * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
   */
  subscribe(
    filter: FilterInterface,
    opts: SubscribeAutoCloseOptionsInterface | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SubscribeOutput>;
  /**
   * Subscribe to filters to specific relays
   *
   * ### Auto-closing subscription
   *
   * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
   */
  subscribeTo(
    urls: Array<string>,
    filter: FilterInterface,
    opts: SubscribeAutoCloseOptionsInterface | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SubscribeOutput>;
  /**
   * Subscribe to filters with custom subscription ID
   *
   * If `gossip` is enabled (see `Options]) the events will be requested also to
   * NIP65 relays (automatically discovered) of public keys included in filters (if any).
   *
   * ### Auto-closing subscription
   *
   * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
   */
  subscribeWithId(
    id: string,
    filter: FilterInterface,
    opts: SubscribeAutoCloseOptionsInterface | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Output>;
  /**
   * Subscribe to filters with custom subscription ID to specific relays
   *
   * ### Auto-closing subscription
   *
   * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
   */
  subscribeWithIdTo(
    urls: Array<string>,
    id: string,
    filter: FilterInterface,
    opts: SubscribeAutoCloseOptionsInterface | undefined,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Output>;
  subscription(
    id: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FilterInterface | undefined>;
  subscriptions(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Map<string, FilterInterface>>;
  /**
   * Sync events with relays (negentropy reconciliation)
   *
   * If `gossip` is enabled (see `Options`) the events will be reconciled also with
   * NIP65 relays (automatically discovered) of public keys included in filters (if any).
   *
   * <https://github.com/hoytech/negentropy>
   */
  sync(
    filter: FilterInterface,
    opts: SyncOptionsInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ReconciliationOutput>;
  /**
   * Try to establish a connection with the relays.
   *
   * Attempts to establish a connection for every relay currently in
   * [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`]
   * without spawning the connection task if it fails.
   * This means that if the connection fails, no automatic retries are scheduled.
   * Use [`Client::connect`] if you want to immediately spawn a connection task,
   * regardless of whether the initial connection succeeds.
   *
   * For further details, see the documentation of [`Relay::try_connect`].
   */
  tryConnect(
    timeout: UniffiDuration,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Output>;
  unsubscribe(
    subscriptionId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  unsubscribeAll(asyncOpts_?: { signal: AbortSignal }): Promise<void>;
  /**
   * Unwrap Gift Wrap event
   *
   * Internally verify the `seal` event
   *
   * <https://github.com/nostr-protocol/nips/blob/master/59.md>
   */
  unwrapGiftWrap(
    giftWrap: EventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<UnwrappedGiftInterface>;
  /**
   * Waits for relays connections
   *
   * Wait for relays connections at most for the specified `timeout`.
   * The code continues when the relays are connected or the `timeout` is reached.
   */
  waitForConnection(
    timeout: UniffiDuration,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
}

export class Client extends UniffiAbstractObject implements ClientInterface {
  readonly [uniffiTypeNameSymbol] = 'Client';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(signer: NostrSignerInterface | undefined = undefined) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_client_new(
          FfiConverterOptionalTypeNostrSigner.lower(signer),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeClientObjectFactory.bless(pointer);
  }

  /**
   * Add discovery relay
   *
   * If relay already exists, this method automatically add the `DISCOVERY` flag to it and return `false`.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/65.md>
   */
  public async addDiscoveryRelay(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_add_discovery_relay(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(url)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_nostr_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule().ubrn_ffi_nostr_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Add read relay
   *
   * If relay already exists, this method add the `READ` flag to it and return `false`.
   */
  public async addReadRelay(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_add_read_relay(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(url)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_nostr_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule().ubrn_ffi_nostr_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Add new relay
   *
   * Relays added with this method will have both `READ` and `WRITE` flags enabled
   *
   * If the relay already exists, the flags will be updated and `false` returned.
   *
   * If are set pool subscriptions, the new added relay will inherit them. Use `subscribe_to` method instead of `subscribe`,
   * to avoid to set pool subscriptions.
   *
   * This method use previously set or default `Options` to configure the `Relay` (ex. set proxy, set min POW, set relay limits, ...).
   *
   * Connection is **NOT** automatically started with relay, remember to call `connect` method!
   */
  public async addRelay(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_add_relay(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(url)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_nostr_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule().ubrn_ffi_nostr_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Add new relay with custom options
   */
  public async addRelayWithOpts(
    url: string,
    opts: RelayOptionsInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_add_relay_with_opts(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(url),
            FfiConverterTypeRelayOptions.lower(opts)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_nostr_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule().ubrn_ffi_nostr_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Add write relay
   *
   * If relay already exists, this method add the `WRITE` flag to it and return `false`.
   */
  public async addWriteRelay(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<boolean> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_add_write_relay(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(url)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_nostr_sdk_ffi_rust_future_poll_i8,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_i8,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_i8,
        /*freeFunc:*/ nativeModule().ubrn_ffi_nostr_sdk_ffi_rust_future_free_i8,
        /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Auto authenticate to relays (default: true)
   *
   * <https://github.com/nostr-protocol/nips/blob/master/42.md>
   */
  public automaticAuthentication(enable: boolean): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_automatic_authentication(
          uniffiTypeClientObjectFactory.clonePointer(this),
          FfiConverterBool.lower(enable),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Connect to all added relays
   *
   * Attempts to initiate a connection for every relay currently in
   * [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`].
   * A background connection task is spawned for each such relay, which then tries
   * to establish the connection.
   * Any relay not in one of these two statuses is skipped.
   *
   * For further details, see the documentation of [`Relay::connect`].
   */
  public async connect(asyncOpts_?: { signal: AbortSignal }): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_connect(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Connect to a previously added relay
   */
  public async connectRelay(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_connect_relay(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(url)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public database(): NostrDatabaseInterface {
    return FfiConverterTypeNostrDatabase.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_database(
            uniffiTypeClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Disconnect from all relays
   */
  public async disconnect(asyncOpts_?: { signal: AbortSignal }): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_disconnect(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async disconnectRelay(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_disconnect_relay(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(url)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get events both from database and relays
   *
   * This is an auto-closing subscription and will be closed automatically on `EOSE`.
   *
   * You can obtain the same result by merging the `Events` from different type of sources.
   *
   * This method will be deprecated in the future!
   * This is a temporary solution for who still want to query events both from database and relays and merge the result.
   * The optimal solution is to execute a [`Client::sync`] to get all old events, [`Client::subscribe`] to get all
   * new future events, [`NostrDatabase::query`] to query events and [`Client::handle_notifications`] to listen-for/handle new events (i.e. to know when update the UI).
   * This will allow very fast queries, low bandwidth usage (depending on how many events the client have to sync) and a low load on relays.
   *
   * # Gossip
   *
   * If `gossip` is enabled (see [`Options::gossip`]) the events will be requested also to
   * NIP65 relays (automatically discovered) of public keys included in filters (if any).
   */
  public async fetchCombinedEvents(
    filter: FilterInterface,
    timeout: UniffiDuration,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<EventsInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_fetch_combined_events(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeFilter.lower(filter),
            FfiConverterDuration.lower(timeout)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeEvents.lift.bind(FfiConverterTypeEvents),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Fetch events from relays
   *
   * This is an auto-closing subscription and will be closed automatically on `EOSE`.
   *
   * # Gossip
   *
   * If `gossip` is enabled (see `Options`) the events will be requested also to
   * NIP65 relays (automatically discovered) of public keys included in filters (if any).
   */
  public async fetchEvents(
    filter: FilterInterface,
    timeout: UniffiDuration,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<EventsInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_fetch_events(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeFilter.lower(filter),
            FfiConverterDuration.lower(timeout)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeEvents.lift.bind(FfiConverterTypeEvents),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Fetch events from specific relays
   *
   * This is an auto-closing subscription and will be closed automatically on `EOSE`.
   */
  public async fetchEventsFrom(
    urls: Array<string>,
    filter: FilterInterface,
    timeout: UniffiDuration,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<EventsInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_fetch_events_from(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(urls),
            FfiConverterTypeFilter.lower(filter),
            FfiConverterDuration.lower(timeout)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeEvents.lift.bind(FfiConverterTypeEvents),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Fetch the newest public key metadata from relays.
   *
   * Returns `None` if the `Metadata` of the `PublicKey` has not been found.
   *
   * Check `Client::fetch_events` for more details.
   *
   * If you only want to consult cached data,
   * consider `client.database().profile(PUBKEY)`.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  public async fetchMetadata(
    publicKey: PublicKeyInterface,
    timeout: UniffiDuration,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<MetadataInterface | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_fetch_metadata(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterDuration.lower(timeout)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeMetadata.lift.bind(
          FfiConverterOptionalTypeMetadata
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Disconnect and force remove all relays
   */
  public async forceRemoveAllRelays(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_force_remove_all_relays(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Force remove and disconnect relay
   *
   * Note: this method will remove the relay, also if it's in use for the gossip model or other service!
   */
  public async forceRemoveRelay(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_force_remove_relay(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(url)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Construct Gift Wrap and send to relays
   *
   * Check `send_event` method to know how sending events works.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/59.md>
   */
  public async giftWrap(
    receiver: PublicKeyInterface,
    rumor: UnsignedEventInterface,
    extraTags: Array<TagInterface>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SendEventOutput> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_gift_wrap(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(receiver),
            FfiConverterTypeUnsignedEvent.lower(rumor),
            FfiConverterArrayTypeTag.lower(extraTags)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSendEventOutput.lift.bind(
          FfiConverterTypeSendEventOutput
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Construct Gift Wrap and send to specific relays
   *
   * <https://github.com/nostr-protocol/nips/blob/master/59.md>
   */
  public async giftWrapTo(
    urls: Array<string>,
    receiver: PublicKeyInterface,
    rumor: UnsignedEventInterface,
    extraTags: Array<TagInterface>,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SendEventOutput> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_gift_wrap_to(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(urls),
            FfiConverterTypePublicKey.lower(receiver),
            FfiConverterTypeUnsignedEvent.lower(rumor),
            FfiConverterArrayTypeTag.lower(extraTags)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSendEventOutput.lift.bind(
          FfiConverterTypeSendEventOutput
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Handle notifications
   */
  public async handleNotifications(
    handler: HandleNotification,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_handle_notifications(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeHandleNotification.lower(handler)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async relay(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<RelayInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_relay(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(url)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRelay.lift.bind(FfiConverterTypeRelay),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get relays with `READ` or `WRITE` flags
   */
  public async relays(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Map<string, RelayInterface>> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_relays(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterMapStringTypeRelay.lift.bind(
          FfiConverterMapStringTypeRelay
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Disconnect and remove all relays
   *
   * Some relays used by some services could not be disconnected with this method
   * (like the ones used for gossip).
   * Use [`Client::force_remove_all_relays`] to remove every relay.
   */
  public async removeAllRelays(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_remove_all_relays(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Remove and disconnect relay
   *
   * If the relay has `GOSSIP` flag, it will not be removed from the pool and its
   * flags will be updated (remove `READ`, `WRITE` and `DISCOVERY` flags).
   */
  public async removeRelay(
    url: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_remove_relay(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(url)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Send event
   *
   * Send event to all relays with `WRITE` flag.
   * If `gossip` is enabled (see `Options`) the event will be sent also to NIP65 relays (automatically discovered).
   */
  public async sendEvent(
    event: EventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SendEventOutput> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_send_event(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeEvent.lower(event)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSendEventOutput.lift.bind(
          FfiConverterTypeSendEventOutput
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Take an `EventBuilder`, sign it by using the `NostrSigner` and broadcast to relays (check `send_event` method for more details)
   *
   * Rise an error if the `NostrSigner` is not set.
   */
  public async sendEventBuilder(
    builder: EventBuilderInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SendEventOutput> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_send_event_builder(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeEventBuilder.lower(builder)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSendEventOutput.lift.bind(
          FfiConverterTypeSendEventOutput
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Take an `EventBuilder`, sign it by using the `NostrSigner` and broadcast to specific relays.
   *
   * Rise an error if the `NostrSigner` is not set.
   */
  public async sendEventBuilderTo(
    urls: Array<string>,
    builder: EventBuilderInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SendEventOutput> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_send_event_builder_to(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(urls),
            FfiConverterTypeEventBuilder.lower(builder)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSendEventOutput.lift.bind(
          FfiConverterTypeSendEventOutput
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Send event to specific relays.
   */
  public async sendEventTo(
    urls: Array<string>,
    event: EventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SendEventOutput> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_send_event_to(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(urls),
            FfiConverterTypeEvent.lower(event)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSendEventOutput.lift.bind(
          FfiConverterTypeSendEventOutput
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async sendMsgTo(
    urls: Array<string>,
    msg: ClientMessageInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Output> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_send_msg_to(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(urls),
            FfiConverterTypeClientMessage.lower(msg)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeOutput.lift.bind(FfiConverterTypeOutput),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Send a private direct message
   *
   * If gossip is enabled, the message will be sent to the NIP17 relays (automatically discovered).
   * If gossip is not enabled will be sent to all relays with WRITE` relay service flag.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/17.md>
   */
  public async sendPrivateMsg(
    receiver: PublicKeyInterface,
    message: string,
    rumorExtraTags: Array<TagInterface> = [],
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SendEventOutput> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_send_private_msg(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(receiver),
            FfiConverterString.lower(message),
            FfiConverterArrayTypeTag.lower(rumorExtraTags)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSendEventOutput.lift.bind(
          FfiConverterTypeSendEventOutput
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Send private direct message to specific relays
   *
   * <https://github.com/nostr-protocol/nips/blob/master/17.md>
   */
  public async sendPrivateMsgTo(
    urls: Array<string>,
    receiver: PublicKeyInterface,
    message: string,
    rumorExtraTags: Array<TagInterface> = [],
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SendEventOutput> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_send_private_msg_to(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(urls),
            FfiConverterTypePublicKey.lower(receiver),
            FfiConverterString.lower(message),
            FfiConverterArrayTypeTag.lower(rumorExtraTags)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSendEventOutput.lift.bind(
          FfiConverterTypeSendEventOutput
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async setMetadata(
    metadata: MetadataInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SendEventOutput> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_set_metadata(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeMetadata.lower(metadata)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSendEventOutput.lift.bind(
          FfiConverterTypeSendEventOutput
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async shutdown(asyncOpts_?: { signal: AbortSignal }): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_shutdown(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Signs the `EventBuilder` into an `Event` using the `NostrSigner`
   */
  public async signEventBuilder(
    builder: EventBuilderInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<EventInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_sign_event_builder(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeEventBuilder.lower(builder)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeEvent.lift.bind(FfiConverterTypeEvent),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async signer(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<NostrSignerInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_signer(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeNostrSigner.lift.bind(
          FfiConverterTypeNostrSigner
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Subscribe to filters
   *
   * If `gossip` is enabled (see `Options]) the events will be requested also to
   * NIP65 relays (automatically discovered) of public keys included in filters (if any).
   *
   * ### Auto-closing subscription
   *
   * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
   */
  public async subscribe(
    filter: FilterInterface,
    opts: SubscribeAutoCloseOptionsInterface | undefined = undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SubscribeOutput> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_subscribe(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeFilter.lower(filter),
            FfiConverterOptionalTypeSubscribeAutoCloseOptions.lower(opts)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSubscribeOutput.lift.bind(
          FfiConverterTypeSubscribeOutput
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Subscribe to filters to specific relays
   *
   * ### Auto-closing subscription
   *
   * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
   */
  public async subscribeTo(
    urls: Array<string>,
    filter: FilterInterface,
    opts: SubscribeAutoCloseOptionsInterface | undefined = undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SubscribeOutput> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_subscribe_to(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(urls),
            FfiConverterTypeFilter.lower(filter),
            FfiConverterOptionalTypeSubscribeAutoCloseOptions.lower(opts)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSubscribeOutput.lift.bind(
          FfiConverterTypeSubscribeOutput
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Subscribe to filters with custom subscription ID
   *
   * If `gossip` is enabled (see `Options]) the events will be requested also to
   * NIP65 relays (automatically discovered) of public keys included in filters (if any).
   *
   * ### Auto-closing subscription
   *
   * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
   */
  public async subscribeWithId(
    id: string,
    filter: FilterInterface,
    opts: SubscribeAutoCloseOptionsInterface | undefined = undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Output> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_subscribe_with_id(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(id),
            FfiConverterTypeFilter.lower(filter),
            FfiConverterOptionalTypeSubscribeAutoCloseOptions.lower(opts)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeOutput.lift.bind(FfiConverterTypeOutput),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Subscribe to filters with custom subscription ID to specific relays
   *
   * ### Auto-closing subscription
   *
   * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
   */
  public async subscribeWithIdTo(
    urls: Array<string>,
    id: string,
    filter: FilterInterface,
    opts: SubscribeAutoCloseOptionsInterface | undefined = undefined,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Output> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_subscribe_with_id_to(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(urls),
            FfiConverterString.lower(id),
            FfiConverterTypeFilter.lower(filter),
            FfiConverterOptionalTypeSubscribeAutoCloseOptions.lower(opts)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeOutput.lift.bind(FfiConverterTypeOutput),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async subscription(
    id: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FilterInterface | undefined> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_subscription(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(id)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeFilter.lift.bind(
          FfiConverterOptionalTypeFilter
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async subscriptions(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Map<string, FilterInterface>> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_subscriptions(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterMapStringTypeFilter.lift.bind(
          FfiConverterMapStringTypeFilter
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sync events with relays (negentropy reconciliation)
   *
   * If `gossip` is enabled (see `Options`) the events will be reconciled also with
   * NIP65 relays (automatically discovered) of public keys included in filters (if any).
   *
   * <https://github.com/hoytech/negentropy>
   */
  public async sync(
    filter: FilterInterface,
    opts: SyncOptionsInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ReconciliationOutput> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_sync(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeFilter.lower(filter),
            FfiConverterTypeSyncOptions.lower(opts)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeReconciliationOutput.lift.bind(
          FfiConverterTypeReconciliationOutput
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Try to establish a connection with the relays.
   *
   * Attempts to establish a connection for every relay currently in
   * [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`]
   * without spawning the connection task if it fails.
   * This means that if the connection fails, no automatic retries are scheduled.
   * Use [`Client::connect`] if you want to immediately spawn a connection task,
   * regardless of whether the initial connection succeeds.
   *
   * For further details, see the documentation of [`Relay::try_connect`].
   */
  public async tryConnect(
    timeout: UniffiDuration,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Output> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_try_connect(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterDuration.lower(timeout)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeOutput.lift.bind(FfiConverterTypeOutput),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async unsubscribe(
    subscriptionId: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_unsubscribe(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterString.lower(subscriptionId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async unsubscribeAll(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_unsubscribe_all(
            uniffiTypeClientObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Unwrap Gift Wrap event
   *
   * Internally verify the `seal` event
   *
   * <https://github.com/nostr-protocol/nips/blob/master/59.md>
   */
  public async unwrapGiftWrap(
    giftWrap: EventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<UnwrappedGiftInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_unwrap_gift_wrap(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterTypeEvent.lower(giftWrap)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeUnwrappedGift.lift.bind(
          FfiConverterTypeUnwrappedGift
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Waits for relays connections
   *
   * Wait for relays connections at most for the specified `timeout`.
   * The code continues when the relays are connected or the `timeout` is reached.
   */
  public async waitForConnection(
    timeout: UniffiDuration,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_client_wait_for_connection(
            uniffiTypeClientObjectFactory.clonePointer(this),
            FfiConverterDuration.lower(timeout)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeClientObjectFactory.pointer(this);
      uniffiTypeClientObjectFactory.freePointer(pointer);
      uniffiTypeClientObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Client {
    return uniffiTypeClientObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeClientObjectFactory: UniffiObjectFactory<ClientInterface> = {
  create(pointer: UnsafeMutableRawPointer): ClientInterface {
    const instance = Object.create(Client.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Client';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_client_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: ClientInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: ClientInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_client(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_client(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is ClientInterface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Client';
  },
};
// FfiConverter for ClientInterface
const FfiConverterTypeClient = new FfiConverterObject(
  uniffiTypeClientObjectFactory
);

export interface ClientBuilderInterface {
  /**
   * Set an admission policy
   */
  admitPolicy(policy: AdmitPolicy): ClientBuilderInterface;
  /**
   * Build [`Client`]
   */
  build(): ClientInterface;
  database(database: NostrDatabaseInterface): ClientBuilderInterface;
  /**
   * Set opts
   */
  opts(opts: OptionsInterface): ClientBuilderInterface;
  signer(signer: NostrSignerInterface): ClientBuilderInterface;
  /**
   * Set a custom WebSocket transport
   */
  websocketTransport(
    transport: CustomWebSocketTransport
  ): ClientBuilderInterface;
}

export class ClientBuilder
  extends UniffiAbstractObject
  implements ClientBuilderInterface
{
  readonly [uniffiTypeNameSymbol] = 'ClientBuilder';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * New client builder
   */
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_clientbuilder_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeClientBuilderObjectFactory.bless(pointer);
  }

  /**
   * Set an admission policy
   */
  public admitPolicy(policy: AdmitPolicy): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_clientbuilder_admit_policy(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeAdmitPolicy.lower(policy),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Build [`Client`]
   */
  public build(): ClientInterface {
    return FfiConverterTypeClient.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_clientbuilder_build(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public database(database: NostrDatabaseInterface): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_clientbuilder_database(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeNostrDatabase.lower(database),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set opts
   */
  public opts(opts: OptionsInterface): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_clientbuilder_opts(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeOptions.lower(opts),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public signer(signer: NostrSignerInterface): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_clientbuilder_signer(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeNostrSigner.lower(signer),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set a custom WebSocket transport
   */
  public websocketTransport(
    transport: CustomWebSocketTransport
  ): ClientBuilderInterface {
    return FfiConverterTypeClientBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_clientbuilder_websocket_transport(
            uniffiTypeClientBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeCustomWebSocketTransport.lower(transport),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeClientBuilderObjectFactory.pointer(this);
      uniffiTypeClientBuilderObjectFactory.freePointer(pointer);
      uniffiTypeClientBuilderObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is ClientBuilder {
    return uniffiTypeClientBuilderObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeClientBuilderObjectFactory: UniffiObjectFactory<ClientBuilderInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): ClientBuilderInterface {
      const instance = Object.create(ClientBuilder.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'ClientBuilder';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_clientbuilder_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: ClientBuilderInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: ClientBuilderInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_clientbuilder(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_clientbuilder(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is ClientBuilderInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'ClientBuilder'
      );
    },
  };
// FfiConverter for ClientBuilderInterface
const FfiConverterTypeClientBuilder = new FfiConverterObject(
  uniffiTypeClientBuilderObjectFactory
);

export interface ClientMessageInterface {
  /**
   * Clone `ClientMessage` and convert it to `ClientMessageEnum`
   */
  asEnum(): ClientMessageEnum;
  asJson() /*throws*/ : string;
}

export class ClientMessage
  extends UniffiAbstractObject
  implements ClientMessageInterface
{
  readonly [uniffiTypeNameSymbol] = 'ClientMessage';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeClientMessageObjectFactory.bless(pointer);
  }

  /**
   * Create new `AUTH` message
   */
  public static auth(event: EventInterface): ClientMessageInterface {
    return FfiConverterTypeClientMessage.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_auth(
            FfiConverterTypeEvent.lower(event),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Create new `CLOSE` message
   */
  public static close(subscriptionId: string): ClientMessageInterface {
    return FfiConverterTypeClientMessage.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_close(
            FfiConverterString.lower(subscriptionId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Create new `COUNT` message
   */
  public static count(
    subscriptionId: string,
    filter: FilterInterface
  ): ClientMessageInterface {
    return FfiConverterTypeClientMessage.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_count(
            FfiConverterString.lower(subscriptionId),
            FfiConverterTypeFilter.lower(filter),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Create new `EVENT` message
   */
  public static event(event: EventInterface): ClientMessageInterface {
    return FfiConverterTypeClientMessage.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_event(
            FfiConverterTypeEvent.lower(event),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Convert `ClientMessageEnum` to `ClientMessage`
   */
  public static fromEnum(e: ClientMessageEnum): ClientMessageInterface {
    return FfiConverterTypeClientMessage.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_from_enum(
            FfiConverterTypeClientMessageEnum.lower(e),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Deserialize `ClientMessage` from JSON string
   *
   * **This method NOT verify the event signature!**
   */
  public static fromJson(json: string): ClientMessageInterface /*throws*/ {
    return FfiConverterTypeClientMessage.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_from_json(
            FfiConverterString.lower(json),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Create new `REQ` message
   */
  public static req(
    subscriptionId: string,
    filter: FilterInterface
  ): ClientMessageInterface {
    return FfiConverterTypeClientMessage.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_req(
            FfiConverterString.lower(subscriptionId),
            FfiConverterTypeFilter.lower(filter),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Clone `ClientMessage` and convert it to `ClientMessageEnum`
   */
  public asEnum(): ClientMessageEnum {
    return FfiConverterTypeClientMessageEnum.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_clientmessage_as_enum(
            uniffiTypeClientMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asJson(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_clientmessage_as_json(
            uniffiTypeClientMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `ClientMessageInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_clientmessage_uniffi_trait_debug(
            uniffiTypeClientMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `ClientMessageInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `ClientMessageInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `ClientMessageInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: ClientMessage): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_clientmessage_uniffi_trait_eq_eq(
            uniffiTypeClientMessageObjectFactory.clonePointer(this),
            FfiConverterTypeClientMessage.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeClientMessageObjectFactory.pointer(this);
      uniffiTypeClientMessageObjectFactory.freePointer(pointer);
      uniffiTypeClientMessageObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is ClientMessage {
    return uniffiTypeClientMessageObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeClientMessageObjectFactory: UniffiObjectFactory<ClientMessageInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): ClientMessageInterface {
      const instance = Object.create(ClientMessage.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'ClientMessage';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_clientmessage_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: ClientMessageInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: ClientMessageInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_clientmessage(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_clientmessage(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is ClientMessageInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'ClientMessage'
      );
    },
  };
// FfiConverter for ClientMessageInterface
const FfiConverterTypeClientMessage = new FfiConverterObject(
  uniffiTypeClientMessageObjectFactory
);

/**
 * Connection
 */
export interface ConnectionInterface {
  /**
   * Set proxy (ex. `127.0.0.1:9050`)
   */
  addr(addr: string) /*throws*/ : ConnectionInterface;
  /**
   * Set connection mode (default: direct)
   */
  mode(mode: ConnectionMode) /*throws*/ : ConnectionInterface;
  /**
   * Set connection target (default: all)
   */
  target(target: ConnectionTarget): ConnectionInterface;
}

/**
 * Connection
 */
export class Connection
  extends UniffiAbstractObject
  implements ConnectionInterface
{
  readonly [uniffiTypeNameSymbol] = 'Connection';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_connection_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeConnectionObjectFactory.bless(pointer);
  }

  /**
   * Set proxy (ex. `127.0.0.1:9050`)
   */
  public addr(addr: string): ConnectionInterface /*throws*/ {
    return FfiConverterTypeConnection.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_connection_addr(
            uniffiTypeConnectionObjectFactory.clonePointer(this),
            FfiConverterString.lower(addr),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set connection mode (default: direct)
   */
  public mode(mode: ConnectionMode): ConnectionInterface /*throws*/ {
    return FfiConverterTypeConnection.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_connection_mode(
            uniffiTypeConnectionObjectFactory.clonePointer(this),
            FfiConverterTypeConnectionMode.lower(mode),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set connection target (default: all)
   */
  public target(target: ConnectionTarget): ConnectionInterface {
    return FfiConverterTypeConnection.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_connection_target(
            uniffiTypeConnectionObjectFactory.clonePointer(this),
            FfiConverterTypeConnectionTarget.lower(target),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `ConnectionInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_debug(
            uniffiTypeConnectionObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `ConnectionInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `ConnectionInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `ConnectionInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: Connection): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_eq_eq(
            uniffiTypeConnectionObjectFactory.clonePointer(this),
            FfiConverterTypeConnection.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `ConnectionInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_hash(
            uniffiTypeConnectionObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeConnectionObjectFactory.pointer(this);
      uniffiTypeConnectionObjectFactory.freePointer(pointer);
      uniffiTypeConnectionObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Connection {
    return uniffiTypeConnectionObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeConnectionObjectFactory: UniffiObjectFactory<ConnectionInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): ConnectionInterface {
      const instance = Object.create(Connection.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'Connection';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_connection_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: ConnectionInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: ConnectionInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_connection(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_connection(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is ConnectionInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Connection'
      );
    },
  };
// FfiConverter for ConnectionInterface
const FfiConverterTypeConnection = new FfiConverterObject(
  uniffiTypeConnectionObjectFactory
);

/**
 * Coordinate for event (`a` tag)
 */
export interface CoordinateInterface {
  identifier(): string;
  kind(): KindInterface;
  publicKey(): PublicKeyInterface;
  /**
   * Check if the coordinate is valid.
   *
   * Returns `false` if:
   * - the `Kind` is `replaceable` and the identifier is not empty
   * - the `Kind` is `addressable` and the identifier is empty
   */
  verify(): boolean;
}

/**
 * Coordinate for event (`a` tag)
 */
export class Coordinate
  extends UniffiAbstractObject
  implements CoordinateInterface
{
  readonly [uniffiTypeNameSymbol] = 'Coordinate';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(
    kind: KindInterface,
    publicKey: PublicKeyInterface,
    identifier: string = ''
  ) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_coordinate_new(
          FfiConverterTypeKind.lower(kind),
          FfiConverterTypePublicKey.lower(publicKey),
          FfiConverterString.lower(identifier),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeCoordinateObjectFactory.bless(pointer);
  }

  public static parse(coordinate: string): CoordinateInterface /*throws*/ {
    return FfiConverterTypeCoordinate.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_coordinate_parse(
            FfiConverterString.lower(coordinate),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public identifier(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_coordinate_identifier(
            uniffiTypeCoordinateObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public kind(): KindInterface {
    return FfiConverterTypeKind.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_coordinate_kind(
            uniffiTypeCoordinateObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public publicKey(): PublicKeyInterface {
    return FfiConverterTypePublicKey.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_coordinate_public_key(
            uniffiTypeCoordinateObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Check if the coordinate is valid.
   *
   * Returns `false` if:
   * - the `Kind` is `replaceable` and the identifier is not empty
   * - the `Kind` is `addressable` and the identifier is empty
   */
  public verify(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_coordinate_verify(
            uniffiTypeCoordinateObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `CoordinateInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_debug(
            uniffiTypeCoordinateObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `CoordinateInterface::to_string()` method of the native Rust peer.
   *
   * Generated by deriving the `Display` trait in Rust.
   */
  toString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_display(
            uniffiTypeCoordinateObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `==` method of `CoordinateInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `CoordinateInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: Coordinate): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_eq_eq(
            uniffiTypeCoordinateObjectFactory.clonePointer(this),
            FfiConverterTypeCoordinate.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `CoordinateInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_hash(
            uniffiTypeCoordinateObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeCoordinateObjectFactory.pointer(this);
      uniffiTypeCoordinateObjectFactory.freePointer(pointer);
      uniffiTypeCoordinateObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Coordinate {
    return uniffiTypeCoordinateObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeCoordinateObjectFactory: UniffiObjectFactory<CoordinateInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): CoordinateInterface {
      const instance = Object.create(Coordinate.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'Coordinate';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_coordinate_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: CoordinateInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: CoordinateInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_coordinate(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_coordinate(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is CoordinateInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Coordinate'
      );
    },
  };
// FfiConverter for CoordinateInterface
const FfiConverterTypeCoordinate = new FfiConverterObject(
  uniffiTypeCoordinateObjectFactory
);

export interface CustomNostrSigner {
  backend(): SignerBackend;
  /**
   * Get signer public key
   */
  getPublicKey(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<PublicKeyInterface | undefined>;
  /**
   * Sign an unsigned event
   */
  signEvent(
    unsignedEvent: UnsignedEventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<EventInterface | undefined>;
  /**
   * NIP04 encrypt (deprecate and unsecure)
   */
  nip04Encrypt(
    publicKey: PublicKeyInterface,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  /**
   * NIP04 decrypt
   */
  nip04Decrypt(
    publicKey: PublicKeyInterface,
    encryptedContent: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  /**
   * NIP44 encrypt
   */
  nip44Encrypt(
    publicKey: PublicKeyInterface,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  /**
   * NIP44 decrypt
   */
  nip44Decrypt(
    publicKey: PublicKeyInterface,
    payload: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
}

export class CustomNostrSignerImpl
  extends UniffiAbstractObject
  implements CustomNostrSigner
{
  readonly [uniffiTypeNameSymbol] = 'CustomNostrSignerImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeCustomNostrSignerImplObjectFactory.bless(pointer);
  }

  public backend(): SignerBackend {
    return FfiConverterTypeSignerBackend.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_backend(
            uniffiTypeCustomNostrSignerImplObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get signer public key
   */
  public async getPublicKey(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<PublicKeyInterface | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_get_public_key(
            uniffiTypeCustomNostrSignerImplObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypePublicKey.lift.bind(
          FfiConverterOptionalTypePublicKey
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sign an unsigned event
   */
  public async signEvent(
    unsignedEvent: UnsignedEventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<EventInterface | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_sign_event(
            uniffiTypeCustomNostrSignerImplObjectFactory.clonePointer(this),
            FfiConverterTypeUnsignedEvent.lower(unsignedEvent)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeEvent.lift.bind(
          FfiConverterOptionalTypeEvent
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * NIP04 encrypt (deprecate and unsecure)
   */
  public async nip04Encrypt(
    publicKey: PublicKeyInterface,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip04_encrypt(
            uniffiTypeCustomNostrSignerImplObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterString.lower(content)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * NIP04 decrypt
   */
  public async nip04Decrypt(
    publicKey: PublicKeyInterface,
    encryptedContent: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip04_decrypt(
            uniffiTypeCustomNostrSignerImplObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterString.lower(encryptedContent)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * NIP44 encrypt
   */
  public async nip44Encrypt(
    publicKey: PublicKeyInterface,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip44_encrypt(
            uniffiTypeCustomNostrSignerImplObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterString.lower(content)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * NIP44 decrypt
   */
  public async nip44Decrypt(
    publicKey: PublicKeyInterface,
    payload: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip44_decrypt(
            uniffiTypeCustomNostrSignerImplObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterString.lower(payload)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeCustomNostrSignerImplObjectFactory.pointer(this);
      uniffiTypeCustomNostrSignerImplObjectFactory.freePointer(pointer);
      uniffiTypeCustomNostrSignerImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is CustomNostrSignerImpl {
    return uniffiTypeCustomNostrSignerImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeCustomNostrSignerImplObjectFactory: UniffiObjectFactory<CustomNostrSigner> =
  {
    create(pointer: UnsafeMutableRawPointer): CustomNostrSigner {
      const instance = Object.create(CustomNostrSignerImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'CustomNostrSignerImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_customnostrsigner_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: CustomNostrSigner): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: CustomNostrSigner): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_customnostrsigner(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_customnostrsigner(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is CustomNostrSigner {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'CustomNostrSignerImpl'
      );
    },
  };
// FfiConverter for CustomNostrSigner
const FfiConverterTypeCustomNostrSigner = new FfiConverterObjectWithCallbacks(
  uniffiTypeCustomNostrSignerImplObjectFactory
);

// Add a vtavble for the callbacks that go in CustomNostrSigner.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceCustomNostrSigner: {
  vtable: UniffiVTableCallbackInterfaceCustomNostrSigner;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    backend: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): SignerBackend => {
        const jsCallback = FfiConverterTypeCustomNostrSigner.lift(uniffiHandle);
        return jsCallback.backend();
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterTypeSignerBackend.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    getPublicKey: (
      uniffiHandle: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<PublicKeyInterface | undefined> => {
        const jsCallback = FfiConverterTypeCustomNostrSigner.lift(uniffiHandle);
        return await jsCallback.getPublicKey({ signal });
      };
      const uniffiHandleSuccess = (
        returnValue: PublicKeyInterface | undefined
      ) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterOptionalTypePublicKey.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ NostrSdkError.instanceOf,
        /*lowerError:*/ FfiConverterTypeNostrSdkError.lower.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    signEvent: (
      uniffiHandle: bigint,
      unsignedEvent: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<EventInterface | undefined> => {
        const jsCallback = FfiConverterTypeCustomNostrSigner.lift(uniffiHandle);
        return await jsCallback.signEvent(
          FfiConverterTypeUnsignedEvent.lift(unsignedEvent),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: EventInterface | undefined) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterOptionalTypeEvent.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ NostrSdkError.instanceOf,
        /*lowerError:*/ FfiConverterTypeNostrSdkError.lower.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    nip04Encrypt: (
      uniffiHandle: bigint,
      publicKey: bigint,
      content: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<string> => {
        const jsCallback = FfiConverterTypeCustomNostrSigner.lift(uniffiHandle);
        return await jsCallback.nip04Encrypt(
          FfiConverterTypePublicKey.lift(publicKey),
          FfiConverterString.lift(content),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: string) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterString.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ NostrSdkError.instanceOf,
        /*lowerError:*/ FfiConverterTypeNostrSdkError.lower.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    nip04Decrypt: (
      uniffiHandle: bigint,
      publicKey: bigint,
      encryptedContent: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<string> => {
        const jsCallback = FfiConverterTypeCustomNostrSigner.lift(uniffiHandle);
        return await jsCallback.nip04Decrypt(
          FfiConverterTypePublicKey.lift(publicKey),
          FfiConverterString.lift(encryptedContent),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: string) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterString.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ NostrSdkError.instanceOf,
        /*lowerError:*/ FfiConverterTypeNostrSdkError.lower.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    nip44Encrypt: (
      uniffiHandle: bigint,
      publicKey: bigint,
      content: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<string> => {
        const jsCallback = FfiConverterTypeCustomNostrSigner.lift(uniffiHandle);
        return await jsCallback.nip44Encrypt(
          FfiConverterTypePublicKey.lift(publicKey),
          FfiConverterString.lift(content),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: string) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterString.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ NostrSdkError.instanceOf,
        /*lowerError:*/ FfiConverterTypeNostrSdkError.lower.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    nip44Decrypt: (
      uniffiHandle: bigint,
      publicKey: bigint,
      payload: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<string> => {
        const jsCallback = FfiConverterTypeCustomNostrSigner.lift(uniffiHandle);
        return await jsCallback.nip44Decrypt(
          FfiConverterTypePublicKey.lift(publicKey),
          FfiConverterString.lift(payload),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: string) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterString.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ NostrSdkError.instanceOf,
        /*lowerError:*/ FfiConverterTypeNostrSdkError.lower.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // CustomNostrSigner: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeCustomNostrSigner.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_init_callback_vtable_customnostrsigner(
      uniffiCallbackInterfaceCustomNostrSigner.vtable
    );
  },
};

export interface CustomWebSocketTransport {
  /**
   * If returns `true`, the WebSocket implementation must handle and forward the PING/PONG messages.
   * The ping is used by the SDK,
   * for example, to calculate the average latency or to make sure the relay is still connected.
   */
  supportPing(): boolean;
  /**
   * Connect to a relay
   */
  connect(
    url: string,
    mode: ConnectionMode,
    timeout: UniffiDuration,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<WebSocketAdapterWrapperInterface | undefined>;
}

export class CustomWebSocketTransportImpl
  extends UniffiAbstractObject
  implements CustomWebSocketTransport
{
  readonly [uniffiTypeNameSymbol] = 'CustomWebSocketTransportImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeCustomWebSocketTransportImplObjectFactory.bless(pointer);
  }

  /**
   * If returns `true`, the WebSocket implementation must handle and forward the PING/PONG messages.
   * The ping is used by the SDK,
   * for example, to calculate the average latency or to make sure the relay is still connected.
   */
  public supportPing(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_customwebsockettransport_support_ping(
            uniffiTypeCustomWebSocketTransportImplObjectFactory.clonePointer(
              this
            ),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Connect to a relay
   */
  public async connect(
    url: string,
    mode: ConnectionMode,
    timeout: UniffiDuration,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<WebSocketAdapterWrapperInterface | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_customwebsockettransport_connect(
            uniffiTypeCustomWebSocketTransportImplObjectFactory.clonePointer(
              this
            ),
            FfiConverterString.lower(url),
            FfiConverterTypeConnectionMode.lower(mode),
            FfiConverterDuration.lower(timeout)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeWebSocketAdapterWrapper.lift.bind(
          FfiConverterOptionalTypeWebSocketAdapterWrapper
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeCustomWebSocketTransportImplObjectFactory.pointer(this);
      uniffiTypeCustomWebSocketTransportImplObjectFactory.freePointer(pointer);
      uniffiTypeCustomWebSocketTransportImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is CustomWebSocketTransportImpl {
    return uniffiTypeCustomWebSocketTransportImplObjectFactory.isConcreteType(
      obj
    );
  }
}

const uniffiTypeCustomWebSocketTransportImplObjectFactory: UniffiObjectFactory<CustomWebSocketTransport> =
  {
    create(pointer: UnsafeMutableRawPointer): CustomWebSocketTransport {
      const instance = Object.create(CustomWebSocketTransportImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'CustomWebSocketTransportImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_customwebsockettransport_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: CustomWebSocketTransport): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: CustomWebSocketTransport): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_customwebsockettransport(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_customwebsockettransport(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is CustomWebSocketTransport {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'CustomWebSocketTransportImpl'
      );
    },
  };
// FfiConverter for CustomWebSocketTransport
const FfiConverterTypeCustomWebSocketTransport =
  new FfiConverterObjectWithCallbacks(
    uniffiTypeCustomWebSocketTransportImplObjectFactory
  );

// Add a vtavble for the callbacks that go in CustomWebSocketTransport.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceCustomWebSocketTransport: {
  vtable: UniffiVTableCallbackInterfaceCustomWebSocketTransport;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    supportPing: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): boolean => {
        const jsCallback =
          FfiConverterTypeCustomWebSocketTransport.lift(uniffiHandle);
        return jsCallback.supportPing();
      };
      const uniffiResult = UniffiResult.ready<number>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(uniffiResult, FfiConverterBool.lower(obj));
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    connect: (
      uniffiHandle: bigint,
      url: Uint8Array,
      mode: Uint8Array,
      timeout: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<WebSocketAdapterWrapperInterface | undefined> => {
        const jsCallback =
          FfiConverterTypeCustomWebSocketTransport.lift(uniffiHandle);
        return await jsCallback.connect(
          FfiConverterString.lift(url),
          FfiConverterTypeConnectionMode.lift(mode),
          FfiConverterDuration.lift(timeout),
          { signal }
        );
      };
      const uniffiHandleSuccess = (
        returnValue: WebSocketAdapterWrapperInterface | undefined
      ) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue:
              FfiConverterOptionalTypeWebSocketAdapterWrapper.lower(
                returnValue
              ),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ NostrSdkError.instanceOf,
        /*lowerError:*/ FfiConverterTypeNostrSdkError.lower.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // CustomWebSocketTransport: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeCustomWebSocketTransport.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_init_callback_vtable_customwebsockettransport(
      uniffiCallbackInterfaceCustomWebSocketTransport.vtable
    );
  },
};

/**
 * Encrypted Secret Key
 */
export interface EncryptedSecretKeyInterface {
  /**
   * Decrypt secret key
   */
  decrypt(password: string) /*throws*/ : SecretKeyInterface;
  /**
   * Get encrypted secret key security
   */
  keySecurity(): KeySecurity;
  toBech32() /*throws*/ : string;
  /**
   * Get encrypted secret key version
   */
  version(): EncryptedSecretKeyVersion;
}

/**
 * Encrypted Secret Key
 */
export class EncryptedSecretKey
  extends UniffiAbstractObject
  implements EncryptedSecretKeyInterface
{
  readonly [uniffiTypeNameSymbol] = 'EncryptedSecretKey';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Encrypt secret key
   */
  constructor(
    secretKey: SecretKeyInterface,
    password: string,
    logN: /*u8*/ number,
    keySecurity: KeySecurity
  ) /*throws*/ {
    super();
    const pointer = uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_encryptedsecretkey_new(
          FfiConverterTypeSecretKey.lower(secretKey),
          FfiConverterString.lower(password),
          FfiConverterUInt8.lower(logN),
          FfiConverterTypeKeySecurity.lower(keySecurity),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeEncryptedSecretKeyObjectFactory.bless(pointer);
  }

  public static fromBech32(
    bech32: string
  ): EncryptedSecretKeyInterface /*throws*/ {
    return FfiConverterTypeEncryptedSecretKey.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_encryptedsecretkey_from_bech32(
            FfiConverterString.lower(bech32),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Decrypt secret key
   */
  public decrypt(password: string): SecretKeyInterface /*throws*/ {
    return FfiConverterTypeSecretKey.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_decrypt(
            uniffiTypeEncryptedSecretKeyObjectFactory.clonePointer(this),
            FfiConverterString.lower(password),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get encrypted secret key security
   */
  public keySecurity(): KeySecurity {
    return FfiConverterTypeKeySecurity.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_key_security(
            uniffiTypeEncryptedSecretKeyObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toBech32(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_to_bech32(
            uniffiTypeEncryptedSecretKeyObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get encrypted secret key version
   */
  public version(): EncryptedSecretKeyVersion {
    return FfiConverterTypeEncryptedSecretKeyVersion.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_version(
            uniffiTypeEncryptedSecretKeyObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `EncryptedSecretKeyInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_uniffi_trait_debug(
            uniffiTypeEncryptedSecretKeyObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `EncryptedSecretKeyInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `EncryptedSecretKeyInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `EncryptedSecretKeyInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: EncryptedSecretKey): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_uniffi_trait_eq_eq(
            uniffiTypeEncryptedSecretKeyObjectFactory.clonePointer(this),
            FfiConverterTypeEncryptedSecretKey.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `EncryptedSecretKeyInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_uniffi_trait_hash(
            uniffiTypeEncryptedSecretKeyObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeEncryptedSecretKeyObjectFactory.pointer(this);
      uniffiTypeEncryptedSecretKeyObjectFactory.freePointer(pointer);
      uniffiTypeEncryptedSecretKeyObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is EncryptedSecretKey {
    return uniffiTypeEncryptedSecretKeyObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeEncryptedSecretKeyObjectFactory: UniffiObjectFactory<EncryptedSecretKeyInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): EncryptedSecretKeyInterface {
      const instance = Object.create(EncryptedSecretKey.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'EncryptedSecretKey';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_encryptedsecretkey_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: EncryptedSecretKeyInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: EncryptedSecretKeyInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_encryptedsecretkey(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_encryptedsecretkey(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is EncryptedSecretKeyInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'EncryptedSecretKey'
      );
    },
  };
// FfiConverter for EncryptedSecretKeyInterface
const FfiConverterTypeEncryptedSecretKey = new FfiConverterObject(
  uniffiTypeEncryptedSecretKeyObjectFactory
);

export interface EventInterface {
  asJson() /*throws*/ : string;
  asPrettyJson() /*throws*/ : string;
  /**
   * Get event author (`pubkey` field)
   */
  author(): PublicKeyInterface;
  content(): string;
  createdAt(): TimestampInterface;
  id(): EventIdInterface;
  /**
   * Returns `true` if the event has an expiration tag that is expired.
   * If an event has no expiration tag, then it will return `false`.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/40.md>
   */
  isExpired(): boolean;
  /**
   * Check if it's a protected event
   *
   * <https://github.com/nostr-protocol/nips/blob/master/70.md>
   */
  isProtected(): boolean;
  kind(): KindInterface;
  signature(): string;
  tags(): TagsInterface;
  /**
   * Verify both `EventId` and `Signature`
   */
  verify(): boolean;
  /**
   * Verify if the `EventId` it's composed correctly
   */
  verifyId(): boolean;
  /**
   * Verify only event `Signature`
   */
  verifySignature(): boolean;
}

export class Event extends UniffiAbstractObject implements EventInterface {
  readonly [uniffiTypeNameSymbol] = 'Event';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeEventObjectFactory.bless(pointer);
  }

  public static fromJson(json: string): EventInterface /*throws*/ {
    return FfiConverterTypeEvent.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_event_from_json(
            FfiConverterString.lower(json),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asJson(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_event_as_json(
            uniffiTypeEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asPrettyJson(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_event_as_pretty_json(
            uniffiTypeEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get event author (`pubkey` field)
   */
  public author(): PublicKeyInterface {
    return FfiConverterTypePublicKey.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_event_author(
            uniffiTypeEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public content(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_event_content(
            uniffiTypeEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public createdAt(): TimestampInterface {
    return FfiConverterTypeTimestamp.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_event_created_at(
            uniffiTypeEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public id(): EventIdInterface {
    return FfiConverterTypeEventId.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_event_id(
            uniffiTypeEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Returns `true` if the event has an expiration tag that is expired.
   * If an event has no expiration tag, then it will return `false`.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/40.md>
   */
  public isExpired(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_event_is_expired(
            uniffiTypeEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Check if it's a protected event
   *
   * <https://github.com/nostr-protocol/nips/blob/master/70.md>
   */
  public isProtected(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_event_is_protected(
            uniffiTypeEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public kind(): KindInterface {
    return FfiConverterTypeKind.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_event_kind(
            uniffiTypeEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public signature(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_event_signature(
            uniffiTypeEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public tags(): TagsInterface {
    return FfiConverterTypeTags.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_event_tags(
            uniffiTypeEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Verify both `EventId` and `Signature`
   */
  public verify(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_event_verify(
            uniffiTypeEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Verify if the `EventId` it's composed correctly
   */
  public verifyId(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_event_verify_id(
            uniffiTypeEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Verify only event `Signature`
   */
  public verifySignature(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_event_verify_signature(
            uniffiTypeEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `EventInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_event_uniffi_trait_debug(
            uniffiTypeEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `EventInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `EventInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `EventInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: Event): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_event_uniffi_trait_eq_eq(
            uniffiTypeEventObjectFactory.clonePointer(this),
            FfiConverterTypeEvent.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `EventInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_event_uniffi_trait_hash(
            uniffiTypeEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeEventObjectFactory.pointer(this);
      uniffiTypeEventObjectFactory.freePointer(pointer);
      uniffiTypeEventObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Event {
    return uniffiTypeEventObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeEventObjectFactory: UniffiObjectFactory<EventInterface> = {
  create(pointer: UnsafeMutableRawPointer): EventInterface {
    const instance = Object.create(Event.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Event';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_event_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: EventInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: EventInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_event(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_event(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is EventInterface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Event';
  },
};
// FfiConverter for EventInterface
const FfiConverterTypeEvent = new FfiConverterObject(
  uniffiTypeEventObjectFactory
);

export interface EventBuilderInterface {
  /**
   * Allow self-tagging
   *
   * When this mode is enabled, any `p` tags referencing the authors public key will not be discarded.
   */
  allowSelfTagging(): EventBuilderInterface;
  /**
   * Build an unsigned event
   *
   * By default, this method removes any `p` tags that match the author's public key.
   * To allow self-tagging, call [`EventBuilder::allow_self_tagging`] first.
   */
  build(publicKey: PublicKeyInterface): UnsignedEventInterface;
  /**
   * Set a custom `created_at` UNIX timestamp
   */
  customCreatedAt(createdAt: TimestampInterface): EventBuilderInterface;
  /**
   * Deduplicate tags
   *
   * For more details check [`Tags::dedup`].
   */
  dedupTags(): EventBuilderInterface;
  /**
   * Set POW difficulty
   *
   * Only values `> 0` are accepted!
   */
  pow(difficulty: /*u8*/ number): EventBuilderInterface;
  /**
   * Build, sign and return [`Event`]
   *
   * Check [`EventBuilder::build`] to learn more.
   */
  sign(
    signer: NostrSignerInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<EventInterface>;
  /**
   * Build, sign and return [`Event`] using [`Keys`] signer
   *
   * Check [`EventBuilder::build`] to learn more.
   */
  signWithKeys(keys: KeysInterface) /*throws*/ : EventInterface;
  /**
   * Add tags
   *
   * This method extend the current tags (if any).
   */
  tags(tags: Array<TagInterface>): EventBuilderInterface;
}

export class EventBuilder
  extends UniffiAbstractObject
  implements EventBuilderInterface
{
  readonly [uniffiTypeNameSymbol] = 'EventBuilder';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(kind: KindInterface, content: string) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_new(
          FfiConverterTypeKind.lower(kind),
          FfiConverterString.lower(content),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeEventBuilderObjectFactory.bless(pointer);
  }

  /**
   * Article Curation set
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  public static articlesCurationSet(
    identifier: string,
    list: ArticlesCuration
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_articles_curation_set(
            FfiConverterString.lower(identifier),
            FfiConverterTypeArticlesCuration.lower(list),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Authentication of clients to relays
   *
   * <https://github.com/nostr-protocol/nips/blob/master/42.md>
   */
  public static auth(
    challenge: string,
    relayUrl: string
  ): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_auth(
            FfiConverterString.lower(challenge),
            FfiConverterString.lower(relayUrl),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Badge award
   *
   * <https://github.com/nostr-protocol/nips/blob/master/58.md>
   */
  public static awardBadge(
    badgeDefinition: EventInterface,
    awardedPublicKeys: Array<PublicKeyInterface>
  ): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_award_badge(
            FfiConverterTypeEvent.lower(badgeDefinition),
            FfiConverterArrayTypePublicKey.lower(awardedPublicKeys),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Blocked relays
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  public static blockedRelays(relay: Array<string>): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_blocked_relays(
            FfiConverterArrayString.lower(relay),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Bookmarks
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  public static bookmarks(list: Bookmarks): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_bookmarks(
            FfiConverterTypeBookmarks.lower(list),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Bookmark set
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  public static bookmarksSet(
    identifier: string,
    list: Bookmarks
  ): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_bookmarks_set(
            FfiConverterString.lower(identifier),
            FfiConverterTypeBookmarks.lower(list),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Create new channel
   *
   * <https://github.com/nostr-protocol/nips/blob/master/28.md>
   */
  public static channel(metadata: MetadataInterface): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_channel(
            FfiConverterTypeMetadata.lower(metadata),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Channel metadata
   *
   * <https://github.com/nostr-protocol/nips/blob/master/28.md>
   */
  public static channelMetadata(
    channelId: EventIdInterface,
    metadata: MetadataInterface,
    relayUrl: string | undefined = undefined
  ): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_channel_metadata(
            FfiConverterTypeEventId.lower(channelId),
            FfiConverterTypeMetadata.lower(metadata),
            FfiConverterOptionalString.lower(relayUrl),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Channel message
   *
   * <https://github.com/nostr-protocol/nips/blob/master/28.md>
   */
  public static channelMsg(
    channelId: EventIdInterface,
    relayUrl: string,
    content: string
  ): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_channel_msg(
            FfiConverterTypeEventId.lower(channelId),
            FfiConverterString.lower(relayUrl),
            FfiConverterString.lower(content),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Comment
   *
   * This adds only the most significant tags, like:
   * - `p` tag with the author of the `comment_to` event;
   * - the `a`/`e` and `k` tags of the `comment_to` event;
   * - `P` tag with the author of the `root` event;
   * - the `A`/`E` and `K` tags of the `root` event.
   *
   * Any additional necessary tag can be added with [`EventBuilder::tag`] or [`EventBuilder::tags`].
   *
   * <https://github.com/nostr-protocol/nips/blob/master/22.md>
   */
  public static comment(
    content: string,
    commentTo: EventInterface,
    root: EventInterface | undefined = undefined,
    relayUrl: string | undefined = undefined
  ): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_comment(
            FfiConverterString.lower(content),
            FfiConverterTypeEvent.lower(commentTo),
            FfiConverterOptionalTypeEvent.lower(root),
            FfiConverterOptionalString.lower(relayUrl),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Communities
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  public static communities(
    communities: Array<CoordinateInterface>
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_communities(
            FfiConverterArrayTypeCoordinate.lower(communities),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Contact/Follow list
   *
   * <https://github.com/nostr-protocol/nips/blob/master/02.md>
   */
  public static contactList(
    contacts: Array<Contact>
  ): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_contact_list(
            FfiConverterArrayTypeContact.lower(contacts),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Badge definition
   *
   * <https://github.com/nostr-protocol/nips/blob/master/58.md>
   */
  public static defineBadge(
    badgeId: string,
    name: string | undefined = undefined,
    description: string | undefined = undefined,
    image: string | undefined = undefined,
    imageDimensions: ImageDimensions | undefined = undefined,
    thumbnails: Array<Image> = []
  ): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_define_badge(
            FfiConverterString.lower(badgeId),
            FfiConverterOptionalString.lower(name),
            FfiConverterOptionalString.lower(description),
            FfiConverterOptionalString.lower(image),
            FfiConverterOptionalTypeImageDimensions.lower(imageDimensions),
            FfiConverterArrayTypeImage.lower(thumbnails),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Event deletion request
   *
   * <https://github.com/nostr-protocol/nips/blob/master/09.md>
   */
  public static delete_(request: EventDeletionRequest): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_delete(
            FfiConverterTypeEventDeletionRequest.lower(request),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Emoji set
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  public static emojiSet(
    identifier: string,
    emojis: Array<EmojiInfo>
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_emoji_set(
            FfiConverterString.lower(identifier),
            FfiConverterArrayTypeEmojiInfo.lower(emojis),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Emojis
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  public static emojis(list: Emojis): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_emojis(
            FfiConverterTypeEmojis.lower(list),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * File metadata
   *
   * <https://github.com/nostr-protocol/nips/blob/master/94.md>
   */
  public static fileMetadata(
    description: string,
    metadata: FileMetadataInterface
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_file_metadata(
            FfiConverterString.lower(description),
            FfiConverterTypeFileMetadata.lower(metadata),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Follow set
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  public static followSet(
    identifier: string,
    publicKeys: Array<PublicKeyInterface>
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_follow_set(
            FfiConverterString.lower(identifier),
            FfiConverterArrayTypePublicKey.lower(publicKeys),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Git Issue
   *
   * <https://github.com/nostr-protocol/nips/blob/master/34.md>
   */
  public static gitIssue(issue: GitIssue): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_git_issue(
            FfiConverterTypeGitIssue.lower(issue),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Git Patch
   *
   * <https://github.com/nostr-protocol/nips/blob/master/34.md>
   */
  public static gitPatch(patch: GitPatch): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_git_patch(
            FfiConverterTypeGitPatch.lower(patch),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Git Repository Announcement
   *
   * <https://github.com/nostr-protocol/nips/blob/master/34.md>
   */
  public static gitRepositoryAnnouncement(
    data: GitRepositoryAnnouncement
  ): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_git_repository_announcement(
            FfiConverterTypeGitRepositoryAnnouncement.lower(data),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Hide message
   *
   * <https://github.com/nostr-protocol/nips/blob/master/28.md>
   */
  public static hideChannelMsg(
    messageId: EventIdInterface,
    reason: string | undefined = undefined
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_hide_channel_msg(
            FfiConverterTypeEventId.lower(messageId),
            FfiConverterOptionalString.lower(reason),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * HTTP Auth
   *
   * <https://github.com/nostr-protocol/nips/blob/master/98.md>
   */
  public static httpAuth(data: HttpData): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_http_auth(
            FfiConverterTypeHttpData.lower(data),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Interest set
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  public static interestSet(
    identifier: string,
    hashtags: Array<string>
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_interest_set(
            FfiConverterString.lower(identifier),
            FfiConverterArrayString.lower(hashtags),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Interests
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  public static interests(list: Interests): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_interests(
            FfiConverterTypeInterests.lower(list),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Data Vending Machine (DVM) - Job Feedback
   *
   * <https://github.com/nostr-protocol/nips/blob/master/90.md>
   */
  public static jobFeedback(
    data: JobFeedbackDataInterface
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_job_feedback(
            FfiConverterTypeJobFeedbackData.lower(data),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Data Vending Machine (DVM) - Job Request
   *
   * <https://github.com/nostr-protocol/nips/blob/master/90.md>
   */
  public static jobRequest(
    kind: KindInterface
  ): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_job_request(
            FfiConverterTypeKind.lower(kind),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Data Vending Machine (DVM) - Job Result
   *
   * <https://github.com/nostr-protocol/nips/blob/master/90.md>
   */
  public static jobResult(
    jobRequest: EventInterface,
    payload: string,
    millisats: /*u64*/ bigint,
    bolt11: string | undefined = undefined
  ): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_job_result(
            FfiConverterTypeEvent.lower(jobRequest),
            FfiConverterString.lower(payload),
            FfiConverterUInt64.lower(millisats),
            FfiConverterOptionalString.lower(bolt11),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Label
   *
   * <https://github.com/nostr-protocol/nips/blob/master/32.md>
   */
  public static label(
    labelNamespace: string,
    labels: Array<string>
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_label(
            FfiConverterString.lower(labelNamespace),
            FfiConverterArrayString.lower(labels),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Live Event
   *
   * <https://github.com/nostr-protocol/nips/blob/master/53.md>
   */
  public static liveEvent(
    liveEvent: LiveEvent
  ): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_live_event(
            FfiConverterTypeLiveEvent.lower(liveEvent),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Live Event Message
   *
   * <https://github.com/nostr-protocol/nips/blob/master/53.md>
   */
  public static liveEventMsg(
    liveEventId: string,
    liveEventHost: PublicKeyInterface,
    content: string,
    relayUrl: string | undefined = undefined
  ): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_live_event_msg(
            FfiConverterString.lower(liveEventId),
            FfiConverterTypePublicKey.lower(liveEventHost),
            FfiConverterString.lower(content),
            FfiConverterOptionalString.lower(relayUrl),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Long-form text note (generally referred to as "articles" or "blog posts").
   *
   * <https://github.com/nostr-protocol/nips/blob/master/23.md>
   */
  public static longFormTextNote(content: string): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_long_form_text_note(
            FfiConverterString.lower(content),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Profile metadata
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  public static metadata(metadata: MetadataInterface): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_metadata(
            FfiConverterTypeMetadata.lower(metadata),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Mute channel user
   *
   * <https://github.com/nostr-protocol/nips/blob/master/28.md>
   */
  public static muteChannelUser(
    publicKey: PublicKeyInterface,
    reason: string | undefined = undefined
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_mute_channel_user(
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterOptionalString.lower(reason),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Mute list
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  public static muteList(list: MuteList): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_mute_list(
            FfiConverterTypeMuteList.lower(list),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Nostr Connect / Nostr Remote Signing
   *
   * <https://github.com/nostr-protocol/nips/blob/master/46.md>
   */
  public static nostrConnect(
    senderKeys: KeysInterface,
    receiverPubkey: PublicKeyInterface,
    msg: NostrConnectMessage
  ): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_nostr_connect(
            FfiConverterTypeKeys.lower(senderKeys),
            FfiConverterTypePublicKey.lower(receiverPubkey),
            FfiConverterTypeNostrConnectMessage.lower(msg),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Pinned notes
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  public static pinnedNotes(
    ids: Array<EventIdInterface>
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_pinned_notes(
            FfiConverterArrayTypeEventId.lower(ids),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Private Direct message rumor
   *
   * <div class="warning">
   * This constructor compose ONLY the rumor for the private direct message!
   * NOT USE THIS IF YOU DON'T KNOW WHAT YOU ARE DOING!
   * </div>
   *
   * <https://github.com/nostr-protocol/nips/blob/master/17.md>
   */
  public static privateMsgRumor(
    receiver: PublicKeyInterface,
    message: string
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_private_msg_rumor(
            FfiConverterTypePublicKey.lower(receiver),
            FfiConverterString.lower(message),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set product data
   *
   * <https://github.com/nostr-protocol/nips/blob/master/15.md>
   */
  public static productData(data: ProductData): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_product_data(
            FfiConverterTypeProductData.lower(data),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Profile badges
   *
   * <https://github.com/nostr-protocol/nips/blob/master/58.md>
   */
  public static profileBadges(
    badgeDefinitions: Array<EventInterface>,
    badgeAwards: Array<EventInterface>,
    pubkeyAwarded: PublicKeyInterface
  ): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_profile_badges(
            FfiConverterArrayTypeEvent.lower(badgeDefinitions),
            FfiConverterArrayTypeEvent.lower(badgeAwards),
            FfiConverterTypePublicKey.lower(pubkeyAwarded),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Public chats
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  public static publicChats(
    chat: Array<EventIdInterface>
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_public_chats(
            FfiConverterArrayTypeEventId.lower(chat),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Create **public** zap request event
   *
   * **This event MUST NOT be broadcasted to relays**, instead must be sent to a recipient's LNURL pay callback url.
   *
   * To build a **private** or **anonymous** zap request use `nip57_private_zap_request(...)` or `nip57_anonymous_zap_request(...)` functions.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/57.md>
   */
  public static publicZapRequest(
    data: ZapRequestDataInterface
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_public_zap_request(
            FfiConverterTypeZapRequestData.lower(data),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add reaction (like/upvote, dislike/downvote or emoji) to an event
   *
   * <https://github.com/nostr-protocol/nips/blob/master/25.md>
   */
  public static reaction(
    event: EventInterface,
    reaction: string
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_reaction(
            FfiConverterTypeEvent.lower(event),
            FfiConverterString.lower(reaction),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add reaction (like/upvote, dislike/downvote or emoji) to an event
   *
   * <https://github.com/nostr-protocol/nips/blob/master/25.md>
   */
  public static reactionExtended(
    eventId: EventIdInterface,
    publicKey: PublicKeyInterface,
    reaction: string,
    kind: KindInterface | undefined = undefined
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_reaction_extended(
            FfiConverterTypeEventId.lower(eventId),
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterString.lower(reaction),
            FfiConverterOptionalTypeKind.lower(kind),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Relay list metadata
   *
   * <https://github.com/nostr-protocol/nips/blob/master/65.md>
   */
  public static relayList(
    map: Map<string, RelayMetadata | undefined>
  ): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_relay_list(
            FfiConverterMapStringOptionalTypeRelayMetadata.lower(map),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Relay set
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  public static relaySet(
    identifier: string,
    relays: Array<string>
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_relay_set(
            FfiConverterString.lower(identifier),
            FfiConverterArrayString.lower(relays),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Reporting
   *
   * <https://github.com/nostr-protocol/nips/blob/master/56.md>
   */
  public static report(
    tags: Array<TagInterface>,
    content: string
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_report(
            FfiConverterArrayTypeTag.lower(tags),
            FfiConverterString.lower(content),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Repost
   *
   * <https://github.com/nostr-protocol/nips/blob/master/18.md>
   */
  public static repost(
    event: EventInterface,
    relayUrl: string | undefined = undefined
  ): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_repost(
            FfiConverterTypeEvent.lower(event),
            FfiConverterOptionalString.lower(relayUrl),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Seal
   *
   * <https://github.com/nostr-protocol/nips/blob/master/59.md>
   */
  public static async seal(
    signer: NostrSignerInterface,
    receiverPublicKey: PublicKeyInterface,
    rumor: UnsignedEventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<EventBuilderInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_seal(
            FfiConverterTypeNostrSigner.lower(signer),
            FfiConverterTypePublicKey.lower(receiverPublicKey),
            FfiConverterTypeUnsignedEvent.lower(rumor)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeEventBuilder.lift.bind(
          FfiConverterTypeEventBuilder
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Search relays
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  public static searchRelays(relay: Array<string>): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_search_relays(
            FfiConverterArrayString.lower(relay),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set stall data
   *
   * <https://github.com/nostr-protocol/nips/blob/master/15.md>
   */
  public static stallData(data: StallDataInterface): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_stall_data(
            FfiConverterTypeStallData.lower(data),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Text note
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  public static textNote(content: string): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_text_note(
            FfiConverterString.lower(content),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Text note reply
   *
   * This adds only the most significant tags, like:
   * - `p` tag with the author of the `reply_to` and `root` events;
   * - `e` tag of the `reply_to` and `root` events.
   *
   * Any additional necessary tag can be added with [`EventBuilder::tag`] or [`EventBuilder::tags`].
   *
   * <https://github.com/nostr-protocol/nips/blob/master/10.md>
   */
  public static textNoteReply(
    content: string,
    replyTo: EventInterface,
    root: EventInterface | undefined = undefined,
    relayUrl: string | undefined = undefined
  ): EventBuilderInterface /*throws*/ {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_text_note_reply(
            FfiConverterString.lower(content),
            FfiConverterTypeEvent.lower(replyTo),
            FfiConverterOptionalTypeEvent.lower(root),
            FfiConverterOptionalString.lower(relayUrl),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Videos Curation set
   *
   * <https://github.com/nostr-protocol/nips/blob/master/51.md>
   */
  public static videosCurationSet(
    identifier: string,
    video: Array<CoordinateInterface>
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_videos_curation_set(
            FfiConverterString.lower(identifier),
            FfiConverterArrayTypeCoordinate.lower(video),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Zap Receipt
   *
   * <https://github.com/nostr-protocol/nips/blob/master/57.md>
   */
  public static zapReceipt(
    bolt11: string,
    preimage: string | undefined,
    zapRequest: EventInterface
  ): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_zap_receipt(
            FfiConverterString.lower(bolt11),
            FfiConverterOptionalString.lower(preimage),
            FfiConverterTypeEvent.lower(zapRequest),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Allow self-tagging
   *
   * When this mode is enabled, any `p` tags referencing the authors public key will not be discarded.
   */
  public allowSelfTagging(): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_eventbuilder_allow_self_tagging(
            uniffiTypeEventBuilderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Build an unsigned event
   *
   * By default, this method removes any `p` tags that match the author's public key.
   * To allow self-tagging, call [`EventBuilder::allow_self_tagging`] first.
   */
  public build(publicKey: PublicKeyInterface): UnsignedEventInterface {
    return FfiConverterTypeUnsignedEvent.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_eventbuilder_build(
            uniffiTypeEventBuilderObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(publicKey),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set a custom `created_at` UNIX timestamp
   */
  public customCreatedAt(createdAt: TimestampInterface): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_eventbuilder_custom_created_at(
            uniffiTypeEventBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeTimestamp.lower(createdAt),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Deduplicate tags
   *
   * For more details check [`Tags::dedup`].
   */
  public dedupTags(): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_eventbuilder_dedup_tags(
            uniffiTypeEventBuilderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set POW difficulty
   *
   * Only values `> 0` are accepted!
   */
  public pow(difficulty: /*u8*/ number): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_eventbuilder_pow(
            uniffiTypeEventBuilderObjectFactory.clonePointer(this),
            FfiConverterUInt8.lower(difficulty),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Build, sign and return [`Event`]
   *
   * Check [`EventBuilder::build`] to learn more.
   */
  public async sign(
    signer: NostrSignerInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<EventInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_eventbuilder_sign(
            uniffiTypeEventBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeNostrSigner.lower(signer)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeEvent.lift.bind(FfiConverterTypeEvent),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Build, sign and return [`Event`] using [`Keys`] signer
   *
   * Check [`EventBuilder::build`] to learn more.
   */
  public signWithKeys(keys: KeysInterface): EventInterface /*throws*/ {
    return FfiConverterTypeEvent.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_eventbuilder_sign_with_keys(
            uniffiTypeEventBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeKeys.lower(keys),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add tags
   *
   * This method extend the current tags (if any).
   */
  public tags(tags: Array<TagInterface>): EventBuilderInterface {
    return FfiConverterTypeEventBuilder.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_eventbuilder_tags(
            uniffiTypeEventBuilderObjectFactory.clonePointer(this),
            FfiConverterArrayTypeTag.lower(tags),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `EventBuilderInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_eventbuilder_uniffi_trait_debug(
            uniffiTypeEventBuilderObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `EventBuilderInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `EventBuilderInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `EventBuilderInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: EventBuilder): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_eventbuilder_uniffi_trait_eq_eq(
            uniffiTypeEventBuilderObjectFactory.clonePointer(this),
            FfiConverterTypeEventBuilder.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeEventBuilderObjectFactory.pointer(this);
      uniffiTypeEventBuilderObjectFactory.freePointer(pointer);
      uniffiTypeEventBuilderObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is EventBuilder {
    return uniffiTypeEventBuilderObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeEventBuilderObjectFactory: UniffiObjectFactory<EventBuilderInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): EventBuilderInterface {
      const instance = Object.create(EventBuilder.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'EventBuilder';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_eventbuilder_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: EventBuilderInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: EventBuilderInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_eventbuilder(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_eventbuilder(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is EventBuilderInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'EventBuilder'
      );
    },
  };
// FfiConverter for EventBuilderInterface
const FfiConverterTypeEventBuilder = new FfiConverterObject(
  uniffiTypeEventBuilderObjectFactory
);

export interface EventIdInterface {
  asBytes(): ArrayBuffer;
  toBech32() /*throws*/ : string;
  toHex(): string;
  toNostrUri() /*throws*/ : string;
}

export class EventId extends UniffiAbstractObject implements EventIdInterface {
  readonly [uniffiTypeNameSymbol] = 'EventId';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(
    publicKey: PublicKeyInterface,
    createdAt: TimestampInterface,
    kind: KindInterface,
    tags: TagsInterface,
    content: string
  ) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventid_new(
          FfiConverterTypePublicKey.lower(publicKey),
          FfiConverterTypeTimestamp.lower(createdAt),
          FfiConverterTypeKind.lower(kind),
          FfiConverterTypeTags.lower(tags),
          FfiConverterString.lower(content),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeEventIdObjectFactory.bless(pointer);
  }

  public static fromBytes(bytes: ArrayBuffer): EventIdInterface /*throws*/ {
    return FfiConverterTypeEventId.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventid_from_bytes(
            FfiConverterArrayBuffer.lower(bytes),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Try to parse event ID from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
   */
  public static parse(id: string): EventIdInterface /*throws*/ {
    return FfiConverterTypeEventId.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_eventid_parse(
            FfiConverterString.lower(id),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asBytes(): ArrayBuffer {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_eventid_as_bytes(
            uniffiTypeEventIdObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toBech32(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_eventid_to_bech32(
            uniffiTypeEventIdObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toHex(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_eventid_to_hex(
            uniffiTypeEventIdObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toNostrUri(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_eventid_to_nostr_uri(
            uniffiTypeEventIdObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `EventIdInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_eventid_uniffi_trait_debug(
            uniffiTypeEventIdObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `EventIdInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `EventIdInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `EventIdInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: EventId): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_eventid_uniffi_trait_eq_eq(
            uniffiTypeEventIdObjectFactory.clonePointer(this),
            FfiConverterTypeEventId.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `EventIdInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_eventid_uniffi_trait_hash(
            uniffiTypeEventIdObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeEventIdObjectFactory.pointer(this);
      uniffiTypeEventIdObjectFactory.freePointer(pointer);
      uniffiTypeEventIdObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is EventId {
    return uniffiTypeEventIdObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeEventIdObjectFactory: UniffiObjectFactory<EventIdInterface> = {
  create(pointer: UnsafeMutableRawPointer): EventIdInterface {
    const instance = Object.create(EventId.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'EventId';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_eventid_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: EventIdInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: EventIdInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_eventid(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_eventid(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is EventIdInterface {
    return (
      obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'EventId'
    );
  },
};
// FfiConverter for EventIdInterface
const FfiConverterTypeEventId = new FfiConverterObject(
  uniffiTypeEventIdObjectFactory
);

export interface EventsInterface {
  /**
   * Check if contains `Event`
   */
  contains(event: EventInterface): boolean;
  /**
   * Get first `Event` (descending order)
   */
  first(): EventInterface | undefined;
  /**
   * Returns the number of events in the collection.
   */
  isEmpty(): boolean;
  /**
   * Returns the number of events in the collection.
   */
  len(): /*u64*/ bigint;
  /**
   * Merge events collections into a single one.
   *
   * This method consumes the object, making it unavailable for further use.
   *
   * Collection is converted to unbounded if one of the merge `Events` has a different hash.
   * In other words, the filter limit is respected only if the `Events` are related to the same
   * list of filters.
   */
  merge(other: EventsInterface) /*throws*/ : EventsInterface;
  /**
   * Convert the collection to vector of events.
   *
   * This method consumes the object, making it unavailable for further use.
   */
  toVec() /*throws*/ : Array<EventInterface>;
}

export class Events extends UniffiAbstractObject implements EventsInterface {
  readonly [uniffiTypeNameSymbol] = 'Events';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeEventsObjectFactory.bless(pointer);
  }

  /**
   * Check if contains `Event`
   */
  public contains(event: EventInterface): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_events_contains(
            uniffiTypeEventsObjectFactory.clonePointer(this),
            FfiConverterTypeEvent.lower(event),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get first `Event` (descending order)
   */
  public first(): EventInterface | undefined {
    return FfiConverterOptionalTypeEvent.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_events_first(
            uniffiTypeEventsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Returns the number of events in the collection.
   */
  public isEmpty(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_events_is_empty(
            uniffiTypeEventsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Returns the number of events in the collection.
   */
  public len(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_events_len(
            uniffiTypeEventsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Merge events collections into a single one.
   *
   * This method consumes the object, making it unavailable for further use.
   *
   * Collection is converted to unbounded if one of the merge `Events` has a different hash.
   * In other words, the filter limit is respected only if the `Events` are related to the same
   * list of filters.
   */
  public merge(other: EventsInterface): EventsInterface /*throws*/ {
    return FfiConverterTypeEvents.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_events_merge(
            uniffiTypeEventsObjectFactory.clonePointer(this),
            FfiConverterTypeEvents.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Convert the collection to vector of events.
   *
   * This method consumes the object, making it unavailable for further use.
   */
  public toVec(): Array<EventInterface> /*throws*/ {
    return FfiConverterArrayTypeEvent.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_events_to_vec(
            uniffiTypeEventsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeEventsObjectFactory.pointer(this);
      uniffiTypeEventsObjectFactory.freePointer(pointer);
      uniffiTypeEventsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Events {
    return uniffiTypeEventsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeEventsObjectFactory: UniffiObjectFactory<EventsInterface> = {
  create(pointer: UnsafeMutableRawPointer): EventsInterface {
    const instance = Object.create(Events.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Events';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_events_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: EventsInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: EventsInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_events(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_events(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is EventsInterface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Events';
  },
};
// FfiConverter for EventsInterface
const FfiConverterTypeEvents = new FfiConverterObject(
  uniffiTypeEventsObjectFactory
);

export interface FileMetadataInterface {
  aes256Gcm(key: string, iv: string): FileMetadataInterface;
  /**
   * Add blurhash
   */
  blurhash(blurhash: string): FileMetadataInterface;
  /**
   * Add file size (pixels)
   */
  dimensions(dim: ImageDimensions): FileMetadataInterface;
  /**
   * Add magnet
   */
  magnet(magnet: string): FileMetadataInterface;
  /**
   * Add file size (bytes)
   */
  size(size: /*u64*/ bigint): FileMetadataInterface;
}

export class FileMetadata
  extends UniffiAbstractObject
  implements FileMetadataInterface
{
  readonly [uniffiTypeNameSymbol] = 'FileMetadata';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(url: string, mimeType: string, hash: string) /*throws*/ {
    super();
    const pointer = uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_filemetadata_new(
          FfiConverterString.lower(url),
          FfiConverterString.lower(mimeType),
          FfiConverterString.lower(hash),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFileMetadataObjectFactory.bless(pointer);
  }

  public aes256Gcm(key: string, iv: string): FileMetadataInterface {
    return FfiConverterTypeFileMetadata.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filemetadata_aes_256_gcm(
            uniffiTypeFileMetadataObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            FfiConverterString.lower(iv),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add blurhash
   */
  public blurhash(blurhash: string): FileMetadataInterface {
    return FfiConverterTypeFileMetadata.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filemetadata_blurhash(
            uniffiTypeFileMetadataObjectFactory.clonePointer(this),
            FfiConverterString.lower(blurhash),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add file size (pixels)
   */
  public dimensions(dim: ImageDimensions): FileMetadataInterface {
    return FfiConverterTypeFileMetadata.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filemetadata_dimensions(
            uniffiTypeFileMetadataObjectFactory.clonePointer(this),
            FfiConverterTypeImageDimensions.lower(dim),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add magnet
   */
  public magnet(magnet: string): FileMetadataInterface {
    return FfiConverterTypeFileMetadata.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filemetadata_magnet(
            uniffiTypeFileMetadataObjectFactory.clonePointer(this),
            FfiConverterString.lower(magnet),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add file size (bytes)
   */
  public size(size: /*u64*/ bigint): FileMetadataInterface {
    return FfiConverterTypeFileMetadata.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filemetadata_size(
            uniffiTypeFileMetadataObjectFactory.clonePointer(this),
            FfiConverterUInt64.lower(size),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `FileMetadataInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filemetadata_uniffi_trait_debug(
            uniffiTypeFileMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `FileMetadataInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `FileMetadataInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `FileMetadataInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: FileMetadata): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filemetadata_uniffi_trait_eq_eq(
            uniffiTypeFileMetadataObjectFactory.clonePointer(this),
            FfiConverterTypeFileMetadata.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `FileMetadataInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filemetadata_uniffi_trait_hash(
            uniffiTypeFileMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeFileMetadataObjectFactory.pointer(this);
      uniffiTypeFileMetadataObjectFactory.freePointer(pointer);
      uniffiTypeFileMetadataObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FileMetadata {
    return uniffiTypeFileMetadataObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFileMetadataObjectFactory: UniffiObjectFactory<FileMetadataInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): FileMetadataInterface {
      const instance = Object.create(FileMetadata.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'FileMetadata';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_filemetadata_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: FileMetadataInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: FileMetadataInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_filemetadata(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_filemetadata(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is FileMetadataInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'FileMetadata'
      );
    },
  };
// FfiConverter for FileMetadataInterface
const FfiConverterTypeFileMetadata = new FfiConverterObject(
  uniffiTypeFileMetadataObjectFactory
);

export interface FilterInterface {
  asJson() /*throws*/ : string;
  asRecord(): FilterRecord;
  /**
   * Add event author Public Key
   */
  author(author: PublicKeyInterface): FilterInterface;
  authors(authors: Array<PublicKeyInterface>): FilterInterface;
  /**
   * Add coordinate
   *
   * Query for `a` tag.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  coordinate(coordinate: CoordinateInterface): FilterInterface;
  /**
   * Add coordinates
   *
   * Query for `a` tags.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  coordinates(coordinates: Array<CoordinateInterface>): FilterInterface;
  customTag(tag: SingleLetterTagInterface, content: string): FilterInterface;
  customTags(
    tag: SingleLetterTagInterface,
    contents: Array<string>
  ): FilterInterface;
  /**
   * Add event ID (`e` tag)
   */
  event(eventId: EventIdInterface): FilterInterface;
  /**
   * Add event IDs (`e` tag)
   */
  events(ids: Array<EventIdInterface>): FilterInterface;
  hashtag(hashtag: string): FilterInterface;
  hashtags(hashtags: Array<string>): FilterInterface;
  id(id: EventIdInterface): FilterInterface;
  identifier(identifier: string): FilterInterface;
  identifiers(identifiers: Array<string>): FilterInterface;
  ids(ids: Array<EventIdInterface>): FilterInterface;
  isEmpty(): boolean;
  kind(kind: KindInterface): FilterInterface;
  kinds(kinds: Array<KindInterface>): FilterInterface;
  limit(limit: /*u64*/ bigint): FilterInterface;
  /**
   * Determine if `Filter` match given `Event`.
   */
  matchEvent(event: EventInterface): boolean;
  /**
   * Add Public Key (`p` tag)
   */
  pubkey(pubkey: PublicKeyInterface): FilterInterface;
  /**
   * Add Public Keys (`p` tag)
   */
  pubkeys(pubkeys: Array<PublicKeyInterface>): FilterInterface;
  reference(reference: string): FilterInterface;
  references(references: Array<string>): FilterInterface;
  removeAuthors(authors: Array<PublicKeyInterface>): FilterInterface;
  /**
   * Remove coordinates
   *
   * Remove `a` tags.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  removeCoordinates(coordinates: Array<CoordinateInterface>): FilterInterface;
  removeCustomTags(
    tag: SingleLetterTagInterface,
    contents: Array<string>
  ): FilterInterface;
  removeEvents(ids: Array<EventIdInterface>): FilterInterface;
  removeHashtags(hashtags: Array<string>): FilterInterface;
  removeIdentifiers(identifiers: Array<string>): FilterInterface;
  removeIds(ids: Array<EventIdInterface>): FilterInterface;
  removeKinds(kinds: Array<KindInterface>): FilterInterface;
  removeLimit(): FilterInterface;
  removePubkeys(pubkeys: Array<PublicKeyInterface>): FilterInterface;
  removeReferences(references: Array<string>): FilterInterface;
  removeSearch(): FilterInterface;
  removeSince(): FilterInterface;
  removeUntil(): FilterInterface;
  search(text: string): FilterInterface;
  since(timestamp: TimestampInterface): FilterInterface;
  until(timestamp: TimestampInterface): FilterInterface;
}

export class Filter extends UniffiAbstractObject implements FilterInterface {
  readonly [uniffiTypeNameSymbol] = 'Filter';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_filter_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeFilterObjectFactory.bless(pointer);
  }

  public static fromJson(json: string): FilterInterface /*throws*/ {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_filter_from_json(
            FfiConverterString.lower(json),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public static fromRecord(record: FilterRecord): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_filter_from_record(
            FfiConverterTypeFilterRecord.lower(record),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asJson(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_as_json(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asRecord(): FilterRecord {
    return FfiConverterTypeFilterRecord.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_as_record(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add event author Public Key
   */
  public author(author: PublicKeyInterface): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_author(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(author),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public authors(authors: Array<PublicKeyInterface>): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_authors(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterArrayTypePublicKey.lower(authors),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add coordinate
   *
   * Query for `a` tag.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  public coordinate(coordinate: CoordinateInterface): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_coordinate(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterTypeCoordinate.lower(coordinate),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add coordinates
   *
   * Query for `a` tags.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  public coordinates(coordinates: Array<CoordinateInterface>): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_coordinates(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterArrayTypeCoordinate.lower(coordinates),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public customTag(
    tag: SingleLetterTagInterface,
    content: string
  ): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_custom_tag(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterTypeSingleLetterTag.lower(tag),
            FfiConverterString.lower(content),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public customTags(
    tag: SingleLetterTagInterface,
    contents: Array<string>
  ): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_custom_tags(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterTypeSingleLetterTag.lower(tag),
            FfiConverterArrayString.lower(contents),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add event ID (`e` tag)
   */
  public event(eventId: EventIdInterface): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_event(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterTypeEventId.lower(eventId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add event IDs (`e` tag)
   */
  public events(ids: Array<EventIdInterface>): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_events(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterArrayTypeEventId.lower(ids),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public hashtag(hashtag: string): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_hashtag(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterString.lower(hashtag),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public hashtags(hashtags: Array<string>): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_hashtags(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(hashtags),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public id(id: EventIdInterface): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_id(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterTypeEventId.lower(id),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public identifier(identifier: string): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_identifier(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterString.lower(identifier),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public identifiers(identifiers: Array<string>): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_identifiers(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(identifiers),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public ids(ids: Array<EventIdInterface>): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_ids(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterArrayTypeEventId.lower(ids),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public isEmpty(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_is_empty(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public kind(kind: KindInterface): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_kind(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterTypeKind.lower(kind),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public kinds(kinds: Array<KindInterface>): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_kinds(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterArrayTypeKind.lower(kinds),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public limit(limit: /*u64*/ bigint): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_limit(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterUInt64.lower(limit),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Determine if `Filter` match given `Event`.
   */
  public matchEvent(event: EventInterface): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_match_event(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterTypeEvent.lower(event),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add Public Key (`p` tag)
   */
  public pubkey(pubkey: PublicKeyInterface): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_pubkey(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(pubkey),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add Public Keys (`p` tag)
   */
  public pubkeys(pubkeys: Array<PublicKeyInterface>): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_pubkeys(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterArrayTypePublicKey.lower(pubkeys),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public reference(reference: string): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_reference(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterString.lower(reference),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public references(references: Array<string>): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_references(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(references),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public removeAuthors(authors: Array<PublicKeyInterface>): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_remove_authors(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterArrayTypePublicKey.lower(authors),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Remove coordinates
   *
   * Remove `a` tags.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  public removeCoordinates(
    coordinates: Array<CoordinateInterface>
  ): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_remove_coordinates(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterArrayTypeCoordinate.lower(coordinates),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public removeCustomTags(
    tag: SingleLetterTagInterface,
    contents: Array<string>
  ): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_remove_custom_tags(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterTypeSingleLetterTag.lower(tag),
            FfiConverterArrayString.lower(contents),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public removeEvents(ids: Array<EventIdInterface>): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_remove_events(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterArrayTypeEventId.lower(ids),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public removeHashtags(hashtags: Array<string>): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_remove_hashtags(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(hashtags),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public removeIdentifiers(identifiers: Array<string>): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_remove_identifiers(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(identifiers),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public removeIds(ids: Array<EventIdInterface>): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_remove_ids(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterArrayTypeEventId.lower(ids),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public removeKinds(kinds: Array<KindInterface>): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_remove_kinds(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterArrayTypeKind.lower(kinds),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public removeLimit(): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_remove_limit(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public removePubkeys(pubkeys: Array<PublicKeyInterface>): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_remove_pubkeys(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterArrayTypePublicKey.lower(pubkeys),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public removeReferences(references: Array<string>): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_remove_references(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(references),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public removeSearch(): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_remove_search(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public removeSince(): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_remove_since(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public removeUntil(): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_remove_until(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public search(text: string): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_search(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterString.lower(text),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public since(timestamp: TimestampInterface): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_since(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterTypeTimestamp.lower(timestamp),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public until(timestamp: TimestampInterface): FilterInterface {
    return FfiConverterTypeFilter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_until(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterTypeTimestamp.lower(timestamp),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `FilterInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_uniffi_trait_debug(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `FilterInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `FilterInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `FilterInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: Filter): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_filter_uniffi_trait_eq_eq(
            uniffiTypeFilterObjectFactory.clonePointer(this),
            FfiConverterTypeFilter.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeFilterObjectFactory.pointer(this);
      uniffiTypeFilterObjectFactory.freePointer(pointer);
      uniffiTypeFilterObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Filter {
    return uniffiTypeFilterObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFilterObjectFactory: UniffiObjectFactory<FilterInterface> = {
  create(pointer: UnsafeMutableRawPointer): FilterInterface {
    const instance = Object.create(Filter.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Filter';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_filter_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: FilterInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: FilterInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_filter(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_filter(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is FilterInterface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Filter';
  },
};
// FfiConverter for FilterInterface
const FfiConverterTypeFilter = new FfiConverterObject(
  uniffiTypeFilterObjectFactory
);

export interface HandleNotification {
  handleMsg(
    relayUrl: string,
    msg: RelayMessageInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
  handle(
    relayUrl: string,
    subscriptionId: string,
    event: EventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void>;
}

export class HandleNotificationImpl
  extends UniffiAbstractObject
  implements HandleNotification
{
  readonly [uniffiTypeNameSymbol] = 'HandleNotificationImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeHandleNotificationImplObjectFactory.bless(pointer);
  }

  public async handleMsg(
    relayUrl: string,
    msg: RelayMessageInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_handlenotification_handle_msg(
            uniffiTypeHandleNotificationImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(relayUrl),
            FfiConverterTypeRelayMessage.lower(msg)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async handle(
    relayUrl: string,
    subscriptionId: string,
    event: EventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_handlenotification_handle(
            uniffiTypeHandleNotificationImplObjectFactory.clonePointer(this),
            FfiConverterString.lower(relayUrl),
            FfiConverterString.lower(subscriptionId),
            FfiConverterTypeEvent.lower(event)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeHandleNotificationImplObjectFactory.pointer(this);
      uniffiTypeHandleNotificationImplObjectFactory.freePointer(pointer);
      uniffiTypeHandleNotificationImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is HandleNotificationImpl {
    return uniffiTypeHandleNotificationImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeHandleNotificationImplObjectFactory: UniffiObjectFactory<HandleNotification> =
  {
    create(pointer: UnsafeMutableRawPointer): HandleNotification {
      const instance = Object.create(HandleNotificationImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'HandleNotificationImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_handlenotification_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: HandleNotification): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: HandleNotification): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_handlenotification(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_handlenotification(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is HandleNotification {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'HandleNotificationImpl'
      );
    },
  };
// FfiConverter for HandleNotification
const FfiConverterTypeHandleNotification = new FfiConverterObjectWithCallbacks(
  uniffiTypeHandleNotificationImplObjectFactory
);

// Add a vtavble for the callbacks that go in HandleNotification.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceHandleNotification: {
  vtable: UniffiVTableCallbackInterfaceHandleNotification;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    handleMsg: (
      uniffiHandle: bigint,
      relayUrl: Uint8Array,
      msg: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback =
          FfiConverterTypeHandleNotification.lift(uniffiHandle);
        return await jsCallback.handleMsg(
          FfiConverterString.lift(relayUrl),
          FfiConverterTypeRelayMessage.lift(msg),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    handle: (
      uniffiHandle: bigint,
      relayUrl: Uint8Array,
      subscriptionId: Uint8Array,
      event: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback =
          FfiConverterTypeHandleNotification.lift(uniffiHandle);
        return await jsCallback.handle(
          FfiConverterString.lift(relayUrl),
          FfiConverterString.lift(subscriptionId),
          FfiConverterTypeEvent.lift(event),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // HandleNotification: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeHandleNotification.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_init_callback_vtable_handlenotification(
      uniffiCallbackInterfaceHandleNotification.vtable
    );
  },
};

/**
 * Data Vending Machine (DVM) - Job Feedback data
 *
 * <https://github.com/nostr-protocol/nips/blob/master/90.md>
 */
export interface JobFeedbackDataInterface {
  /**
   * Add payment amount
   */
  amount(
    millisats: /*u64*/ bigint,
    bolt11: string | undefined
  ): JobFeedbackDataInterface;
  /**
   * Add extra info
   */
  extraInfo(info: string): JobFeedbackDataInterface;
  /**
   * Add payload
   */
  payload(payload: string): JobFeedbackDataInterface;
}

/**
 * Data Vending Machine (DVM) - Job Feedback data
 *
 * <https://github.com/nostr-protocol/nips/blob/master/90.md>
 */
export class JobFeedbackData
  extends UniffiAbstractObject
  implements JobFeedbackDataInterface
{
  readonly [uniffiTypeNameSymbol] = 'JobFeedbackData';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Construct new Job Feedback
   */
  constructor(jobRequest: EventInterface, status: DataVendingMachineStatus) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_jobfeedbackdata_new(
          FfiConverterTypeEvent.lower(jobRequest),
          FfiConverterTypeDataVendingMachineStatus.lower(status),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeJobFeedbackDataObjectFactory.bless(pointer);
  }

  /**
   * Add payment amount
   */
  public amount(
    millisats: /*u64*/ bigint,
    bolt11: string | undefined
  ): JobFeedbackDataInterface {
    return FfiConverterTypeJobFeedbackData.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_jobfeedbackdata_amount(
            uniffiTypeJobFeedbackDataObjectFactory.clonePointer(this),
            FfiConverterUInt64.lower(millisats),
            FfiConverterOptionalString.lower(bolt11),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add extra info
   */
  public extraInfo(info: string): JobFeedbackDataInterface {
    return FfiConverterTypeJobFeedbackData.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_jobfeedbackdata_extra_info(
            uniffiTypeJobFeedbackDataObjectFactory.clonePointer(this),
            FfiConverterString.lower(info),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add payload
   */
  public payload(payload: string): JobFeedbackDataInterface {
    return FfiConverterTypeJobFeedbackData.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_jobfeedbackdata_payload(
            uniffiTypeJobFeedbackDataObjectFactory.clonePointer(this),
            FfiConverterString.lower(payload),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeJobFeedbackDataObjectFactory.pointer(this);
      uniffiTypeJobFeedbackDataObjectFactory.freePointer(pointer);
      uniffiTypeJobFeedbackDataObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is JobFeedbackData {
    return uniffiTypeJobFeedbackDataObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeJobFeedbackDataObjectFactory: UniffiObjectFactory<JobFeedbackDataInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): JobFeedbackDataInterface {
      const instance = Object.create(JobFeedbackData.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'JobFeedbackData';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_jobfeedbackdata_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: JobFeedbackDataInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: JobFeedbackDataInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_jobfeedbackdata(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_jobfeedbackdata(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is JobFeedbackDataInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'JobFeedbackData'
      );
    },
  };
// FfiConverter for JobFeedbackDataInterface
const FfiConverterTypeJobFeedbackData = new FfiConverterObject(
  uniffiTypeJobFeedbackDataObjectFactory
);

/**
 * Nostr keys
 */
export interface KeysInterface {
  /**
   * Get public key
   */
  publicKey(): PublicKeyInterface;
  /**
   * Get secret key
   */
  secretKey(): SecretKeyInterface;
  /**
   * Creates a schnorr signature of a message.
   *
   * This method use a random number generator that retrieves randomness from the operating system.
   */
  signSchnorr(message: ArrayBuffer) /*throws*/ : string;
}

/**
 * Nostr keys
 */
export class Keys extends UniffiAbstractObject implements KeysInterface {
  readonly [uniffiTypeNameSymbol] = 'Keys';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Initialize nostr keys from secret key.
   */
  constructor(secretKey: SecretKeyInterface) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_keys_new(
          FfiConverterTypeSecretKey.lower(secretKey),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeKeysObjectFactory.bless(pointer);
  }

  /**
   * Derive keys from BIP-39 mnemonics (ENGLISH wordlist).
   *
   * <https://github.com/nostr-protocol/nips/blob/master/06.md>
   */
  public static fromMnemonic(
    mnemonic: string,
    passphrase: string | undefined = undefined,
    account: /*u32*/ number | undefined = undefined,
    typ: /*u32*/ number | undefined = undefined,
    index: /*u32*/ number | undefined = undefined
  ): KeysInterface /*throws*/ {
    return FfiConverterTypeKeys.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_keys_from_mnemonic(
            FfiConverterString.lower(mnemonic),
            FfiConverterOptionalString.lower(passphrase),
            FfiConverterOptionalUInt32.lower(account),
            FfiConverterOptionalUInt32.lower(typ),
            FfiConverterOptionalUInt32.lower(index),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Generate random keys
   *
   * This constructor use a random number generator that retrieves randomness from the operating system.
   *
   * Generate random keys **without** construct the `Keypair`.
   * This allows faster keys generation (i.e. for vanity pubkey mining).
   * The `Keypair` will be automatically created when needed and stored in a cell.
   */
  public static generate(): KeysInterface {
    return FfiConverterTypeKeys.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_keys_generate(
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Parse secret key from `hex` or `bech32` and compose keys
   */
  public static parse(secretKey: string): KeysInterface /*throws*/ {
    return FfiConverterTypeKeys.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_keys_parse(
            FfiConverterString.lower(secretKey),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get public key
   */
  public publicKey(): PublicKeyInterface {
    return FfiConverterTypePublicKey.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_keys_public_key(
            uniffiTypeKeysObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get secret key
   */
  public secretKey(): SecretKeyInterface {
    return FfiConverterTypeSecretKey.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_keys_secret_key(
            uniffiTypeKeysObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Creates a schnorr signature of a message.
   *
   * This method use a random number generator that retrieves randomness from the operating system.
   */
  public signSchnorr(message: ArrayBuffer): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_keys_sign_schnorr(
            uniffiTypeKeysObjectFactory.clonePointer(this),
            FfiConverterArrayBuffer.lower(message),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `KeysInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_keys_uniffi_trait_debug(
            uniffiTypeKeysObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `KeysInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `KeysInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `KeysInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: Keys): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_keys_uniffi_trait_eq_eq(
            uniffiTypeKeysObjectFactory.clonePointer(this),
            FfiConverterTypeKeys.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeKeysObjectFactory.pointer(this);
      uniffiTypeKeysObjectFactory.freePointer(pointer);
      uniffiTypeKeysObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Keys {
    return uniffiTypeKeysObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeKeysObjectFactory: UniffiObjectFactory<KeysInterface> = {
  create(pointer: UnsafeMutableRawPointer): KeysInterface {
    const instance = Object.create(Keys.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Keys';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_keys_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: KeysInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: KeysInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_keys(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_keys(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is KeysInterface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Keys';
  },
};
// FfiConverter for KeysInterface
const FfiConverterTypeKeys = new FfiConverterObject(
  uniffiTypeKeysObjectFactory
);

/**
 * Event Kind
 */
export interface KindInterface {
  asStd(): KindStandard | undefined;
  /**
   * Get as 16-bit unsigned integer
   */
  asU16(): /*u16*/ number;
  /**
   * Check if it's addressable
   *
   * Addressable means that, for each combination of `pubkey`, `kind` and the `d` tag's first value,
   * only the latest event MUST be stored by relays, older versions MAY be discarded.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  isAddressable(): boolean;
  /**
   * Check if it's ephemeral
   *
   * Ephemeral means that event is not expected to be stored by relays.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  isEphemeral(): boolean;
  /**
   * Check if it's a NIP90 job request
   *
   * <https://github.com/nostr-protocol/nips/blob/master/90.md>
   */
  isJobRequest(): boolean;
  /**
   * Check if it's a NIP90 job result
   *
   * <https://github.com/nostr-protocol/nips/blob/master/90.md>
   */
  isJobResult(): boolean;
  /**
   * Check if it's regular
   *
   * Regular means that event is expected to be stored by relays.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  isRegular(): boolean;
  /**
   * Check if it's replaceable
   *
   * Replaceable means that, for each combination of `pubkey` and `kind`,
   * only the latest event MUST be stored by relays, older versions MAY be discarded.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  isReplaceable(): boolean;
}

/**
 * Event Kind
 */
export class Kind extends UniffiAbstractObject implements KindInterface {
  readonly [uniffiTypeNameSymbol] = 'Kind';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(kind: /*u16*/ number) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_kind_new(
          FfiConverterUInt16.lower(kind),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeKindObjectFactory.bless(pointer);
  }

  public static fromStd(e: KindStandard): KindInterface {
    return FfiConverterTypeKind.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_kind_from_std(
            FfiConverterTypeKindStandard.lower(e),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asStd(): KindStandard | undefined {
    return FfiConverterOptionalTypeKindStandard.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_kind_as_std(
            uniffiTypeKindObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get as 16-bit unsigned integer
   */
  public asU16(): /*u16*/ number {
    return FfiConverterUInt16.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_kind_as_u16(
            uniffiTypeKindObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Check if it's addressable
   *
   * Addressable means that, for each combination of `pubkey`, `kind` and the `d` tag's first value,
   * only the latest event MUST be stored by relays, older versions MAY be discarded.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  public isAddressable(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_kind_is_addressable(
            uniffiTypeKindObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Check if it's ephemeral
   *
   * Ephemeral means that event is not expected to be stored by relays.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  public isEphemeral(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_kind_is_ephemeral(
            uniffiTypeKindObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Check if it's a NIP90 job request
   *
   * <https://github.com/nostr-protocol/nips/blob/master/90.md>
   */
  public isJobRequest(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_kind_is_job_request(
            uniffiTypeKindObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Check if it's a NIP90 job result
   *
   * <https://github.com/nostr-protocol/nips/blob/master/90.md>
   */
  public isJobResult(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_kind_is_job_result(
            uniffiTypeKindObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Check if it's regular
   *
   * Regular means that event is expected to be stored by relays.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  public isRegular(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_kind_is_regular(
            uniffiTypeKindObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Check if it's replaceable
   *
   * Replaceable means that, for each combination of `pubkey` and `kind`,
   * only the latest event MUST be stored by relays, older versions MAY be discarded.
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  public isReplaceable(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_kind_is_replaceable(
            uniffiTypeKindObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `KindInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_debug(
            uniffiTypeKindObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `KindInterface::to_string()` method of the native Rust peer.
   *
   * Generated by deriving the `Display` trait in Rust.
   */
  toString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_display(
            uniffiTypeKindObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `==` method of `KindInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `KindInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: Kind): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_eq_eq(
            uniffiTypeKindObjectFactory.clonePointer(this),
            FfiConverterTypeKind.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `KindInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_hash(
            uniffiTypeKindObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeKindObjectFactory.pointer(this);
      uniffiTypeKindObjectFactory.freePointer(pointer);
      uniffiTypeKindObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Kind {
    return uniffiTypeKindObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeKindObjectFactory: UniffiObjectFactory<KindInterface> = {
  create(pointer: UnsafeMutableRawPointer): KindInterface {
    const instance = Object.create(Kind.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Kind';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_kind_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: KindInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: KindInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_kind(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_kind(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is KindInterface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Kind';
  },
};
// FfiConverter for KindInterface
const FfiConverterTypeKind = new FfiConverterObject(
  uniffiTypeKindObjectFactory
);

export interface MetadataInterface {
  asJson() /*throws*/ : string;
  asPrettyJson() /*throws*/ : string;
  asRecord(): MetadataRecord;
  getAbout(): string | undefined;
  getBanner(): string | undefined;
  getCustomField(key: string) /*throws*/ : JsonValue | undefined;
  getDisplayName(): string | undefined;
  getLud06(): string | undefined;
  getLud16(): string | undefined;
  getName(): string | undefined;
  getNip05(): string | undefined;
  getPicture(): string | undefined;
  getWebsite(): string | undefined;
  setAbout(about: string): MetadataInterface;
  setBanner(banner: string) /*throws*/ : MetadataInterface;
  setCustomField(key: string, value: JsonValue) /*throws*/ : MetadataInterface;
  setDisplayName(displayName: string): MetadataInterface;
  setLud06(lud06: string): MetadataInterface;
  setLud16(lud16: string): MetadataInterface;
  setName(name: string): MetadataInterface;
  setNip05(nip05: string): MetadataInterface;
  setPicture(picture: string) /*throws*/ : MetadataInterface;
  setWebsite(website: string) /*throws*/ : MetadataInterface;
}

export class Metadata
  extends UniffiAbstractObject
  implements MetadataInterface
{
  readonly [uniffiTypeNameSymbol] = 'Metadata';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_metadata_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeMetadataObjectFactory.bless(pointer);
  }

  public static fromJson(json: string): MetadataInterface /*throws*/ {
    return FfiConverterTypeMetadata.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_metadata_from_json(
            FfiConverterString.lower(json),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public static fromRecord(r: MetadataRecord): MetadataInterface {
    return FfiConverterTypeMetadata.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_metadata_from_record(
            FfiConverterTypeMetadataRecord.lower(r),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asJson(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_as_json(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asPrettyJson(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_as_pretty_json(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asRecord(): MetadataRecord {
    return FfiConverterTypeMetadataRecord.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_as_record(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getAbout(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_get_about(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getBanner(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_get_banner(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getCustomField(key: string): JsonValue | undefined /*throws*/ {
    return FfiConverterOptionalTypeJsonValue.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_get_custom_field(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getDisplayName(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_get_display_name(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getLud06(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_get_lud06(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getLud16(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_get_lud16(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getName(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_get_name(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getNip05(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_get_nip05(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getPicture(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_get_picture(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getWebsite(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_get_website(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setAbout(about: string): MetadataInterface {
    return FfiConverterTypeMetadata.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_set_about(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            FfiConverterString.lower(about),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setBanner(banner: string): MetadataInterface /*throws*/ {
    return FfiConverterTypeMetadata.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_set_banner(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            FfiConverterString.lower(banner),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setCustomField(
    key: string,
    value: JsonValue
  ): MetadataInterface /*throws*/ {
    return FfiConverterTypeMetadata.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_set_custom_field(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            FfiConverterTypeJsonValue.lower(value),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setDisplayName(displayName: string): MetadataInterface {
    return FfiConverterTypeMetadata.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_set_display_name(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            FfiConverterString.lower(displayName),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setLud06(lud06: string): MetadataInterface {
    return FfiConverterTypeMetadata.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_set_lud06(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            FfiConverterString.lower(lud06),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setLud16(lud16: string): MetadataInterface {
    return FfiConverterTypeMetadata.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_set_lud16(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            FfiConverterString.lower(lud16),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setName(name: string): MetadataInterface {
    return FfiConverterTypeMetadata.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_set_name(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            FfiConverterString.lower(name),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setNip05(nip05: string): MetadataInterface {
    return FfiConverterTypeMetadata.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_set_nip05(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            FfiConverterString.lower(nip05),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setPicture(picture: string): MetadataInterface /*throws*/ {
    return FfiConverterTypeMetadata.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_set_picture(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            FfiConverterString.lower(picture),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setWebsite(website: string): MetadataInterface /*throws*/ {
    return FfiConverterTypeMetadata.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_set_website(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            FfiConverterString.lower(website),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `MetadataInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_uniffi_trait_debug(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `MetadataInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `MetadataInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `MetadataInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: Metadata): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_metadata_uniffi_trait_eq_eq(
            uniffiTypeMetadataObjectFactory.clonePointer(this),
            FfiConverterTypeMetadata.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeMetadataObjectFactory.pointer(this);
      uniffiTypeMetadataObjectFactory.freePointer(pointer);
      uniffiTypeMetadataObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Metadata {
    return uniffiTypeMetadataObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeMetadataObjectFactory: UniffiObjectFactory<MetadataInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): MetadataInterface {
      const instance = Object.create(Metadata.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'Metadata';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_metadata_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: MetadataInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: MetadataInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_metadata(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_metadata(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is MetadataInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Metadata'
      );
    },
  };
// FfiConverter for MetadataInterface
const FfiConverterTypeMetadata = new FfiConverterObject(
  uniffiTypeMetadataObjectFactory
);

/**
 * Nostr Wallet Connect client
 */
export interface NwcInterface {
  /**
   * Get balance
   */
  getBalance(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise</*u64*/ bigint>;
  /**
   * Get info
   */
  getInfo(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<GetInfoResponse>;
  /**
   * List transactions
   */
  listTransactions(
    params: ListTransactionsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Array<LookupInvoiceResponse>>;
  /**
   * Lookup invoice
   */
  lookupInvoice(
    params: LookupInvoiceRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<LookupInvoiceResponse>;
  /**
   * Create invoice
   */
  makeInvoice(
    params: MakeInvoiceRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<MakeInvoiceResponse>;
  /**
   * Pay invoice
   */
  payInvoice(
    params: PayInvoiceRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<PayInvoiceResponse>;
  /**
   * Pay keysend
   */
  payKeysend(
    params: PayKeysendRequest,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<PayKeysendResponse>;
  /**
   * Get relays status
   */
  status(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Map<string, RelayStatus>>;
}

/**
 * Nostr Wallet Connect client
 */
export class Nwc extends UniffiAbstractObject implements NwcInterface {
  readonly [uniffiTypeNameSymbol] = 'Nwc';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Compose new `NWC` client
   */
  constructor(uri: NostrWalletConnectUriInterface) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nwc_new(
          FfiConverterTypeNostrWalletConnectURI.lower(uri),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeNwcObjectFactory.bless(pointer);
  }

  /**
   * Compose new `NWC` client with `NostrWalletConnectOptions`
   */
  public static withOpts(
    uri: NostrWalletConnectUriInterface,
    opts: NostrWalletConnectOptionsInterface
  ): NwcInterface {
    return FfiConverterTypeNWC.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nwc_with_opts(
            FfiConverterTypeNostrWalletConnectURI.lower(uri),
            FfiConverterTypeNostrWalletConnectOptions.lower(opts),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get balance
   */
  public async getBalance(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise</*u64*/ bigint> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nwc_get_balance(
            uniffiTypeNwcObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_u64,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_u64,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_u64,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_u64,
        /*liftFunc:*/ FfiConverterUInt64.lift.bind(FfiConverterUInt64),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get info
   */
  public async getInfo(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<GetInfoResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nwc_get_info(
            uniffiTypeNwcObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeGetInfoResponse.lift.bind(
          FfiConverterTypeGetInfoResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * List transactions
   */
  public async listTransactions(
    params: ListTransactionsRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Array<LookupInvoiceResponse>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nwc_list_transactions(
            uniffiTypeNwcObjectFactory.clonePointer(this),
            FfiConverterTypeListTransactionsRequest.lower(params)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayTypeLookupInvoiceResponse.lift.bind(
          FfiConverterArrayTypeLookupInvoiceResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Lookup invoice
   */
  public async lookupInvoice(
    params: LookupInvoiceRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<LookupInvoiceResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nwc_lookup_invoice(
            uniffiTypeNwcObjectFactory.clonePointer(this),
            FfiConverterTypeLookupInvoiceRequest.lower(params)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeLookupInvoiceResponse.lift.bind(
          FfiConverterTypeLookupInvoiceResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Create invoice
   */
  public async makeInvoice(
    params: MakeInvoiceRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<MakeInvoiceResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nwc_make_invoice(
            uniffiTypeNwcObjectFactory.clonePointer(this),
            FfiConverterTypeMakeInvoiceRequest.lower(params)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeMakeInvoiceResponse.lift.bind(
          FfiConverterTypeMakeInvoiceResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Pay invoice
   */
  public async payInvoice(
    params: PayInvoiceRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<PayInvoiceResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nwc_pay_invoice(
            uniffiTypeNwcObjectFactory.clonePointer(this),
            FfiConverterTypePayInvoiceRequest.lower(params)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypePayInvoiceResponse.lift.bind(
          FfiConverterTypePayInvoiceResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Pay keysend
   */
  public async payKeysend(
    params: PayKeysendRequest,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<PayKeysendResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nwc_pay_keysend(
            uniffiTypeNwcObjectFactory.clonePointer(this),
            FfiConverterTypePayKeysendRequest.lower(params)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypePayKeysendResponse.lift.bind(
          FfiConverterTypePayKeysendResponse
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get relays status
   */
  public async status(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Map<string, RelayStatus>> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nwc_status(
            uniffiTypeNwcObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterMapStringTypeRelayStatus.lift.bind(
          FfiConverterMapStringTypeRelayStatus
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeNwcObjectFactory.pointer(this);
      uniffiTypeNwcObjectFactory.freePointer(pointer);
      uniffiTypeNwcObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Nwc {
    return uniffiTypeNwcObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNwcObjectFactory: UniffiObjectFactory<NwcInterface> = {
  create(pointer: UnsafeMutableRawPointer): NwcInterface {
    const instance = Object.create(Nwc.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Nwc';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_nwc_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: NwcInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: NwcInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_nwc(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_nwc(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is NwcInterface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Nwc';
  },
};
// FfiConverter for NwcInterface
const FfiConverterTypeNWC = new FfiConverterObject(uniffiTypeNwcObjectFactory);

export interface Nip05ProfileInterface {
  /**
   * Get NIP46 relays
   */
  nip46(): Array<string>;
  publicKey(): PublicKeyInterface;
  /**
   * Get relays
   */
  relays(): Array<string>;
}

export class Nip05Profile
  extends UniffiAbstractObject
  implements Nip05ProfileInterface
{
  readonly [uniffiTypeNameSymbol] = 'Nip05Profile';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeNip05ProfileObjectFactory.bless(pointer);
  }

  /**
   * Get NIP46 relays
   */
  public nip46(): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip05profile_nip46(
            uniffiTypeNip05ProfileObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public publicKey(): PublicKeyInterface {
    return FfiConverterTypePublicKey.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip05profile_public_key(
            uniffiTypeNip05ProfileObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get relays
   */
  public relays(): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip05profile_relays(
            uniffiTypeNip05ProfileObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeNip05ProfileObjectFactory.pointer(this);
      uniffiTypeNip05ProfileObjectFactory.freePointer(pointer);
      uniffiTypeNip05ProfileObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Nip05Profile {
    return uniffiTypeNip05ProfileObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNip05ProfileObjectFactory: UniffiObjectFactory<Nip05ProfileInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): Nip05ProfileInterface {
      const instance = Object.create(Nip05Profile.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'Nip05Profile';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_nip05profile_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: Nip05ProfileInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: Nip05ProfileInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_nip05profile(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_nip05profile(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is Nip05ProfileInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'Nip05Profile'
      );
    },
  };
// FfiConverter for Nip05ProfileInterface
const FfiConverterTypeNip05Profile = new FfiConverterObject(
  uniffiTypeNip05ProfileObjectFactory
);

export interface Nip19Interface {
  asEnum(): Nip19Enum;
}

export class Nip19 extends UniffiAbstractObject implements Nip19Interface {
  readonly [uniffiTypeNameSymbol] = 'Nip19';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeNip19ObjectFactory.bless(pointer);
  }

  public static fromBech32(bech32: string): Nip19Interface /*throws*/ {
    return FfiConverterTypeNip19.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nip19_from_bech32(
            FfiConverterString.lower(bech32),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asEnum(): Nip19Enum {
    return FfiConverterTypeNip19Enum.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19_as_enum(
            uniffiTypeNip19ObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `Nip19Interface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19_uniffi_trait_debug(
            uniffiTypeNip19ObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `Nip19Interface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `Nip19Interface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `Nip19Interface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: Nip19): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19_uniffi_trait_eq_eq(
            uniffiTypeNip19ObjectFactory.clonePointer(this),
            FfiConverterTypeNip19.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeNip19ObjectFactory.pointer(this);
      uniffiTypeNip19ObjectFactory.freePointer(pointer);
      uniffiTypeNip19ObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Nip19 {
    return uniffiTypeNip19ObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNip19ObjectFactory: UniffiObjectFactory<Nip19Interface> = {
  create(pointer: UnsafeMutableRawPointer): Nip19Interface {
    const instance = Object.create(Nip19.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Nip19';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_nip19_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: Nip19Interface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: Nip19Interface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_nip19(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_nip19(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is Nip19Interface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Nip19';
  },
};
// FfiConverter for Nip19Interface
const FfiConverterTypeNip19 = new FfiConverterObject(
  uniffiTypeNip19ObjectFactory
);

export interface Nip19CoordinateInterface {
  coordinate(): CoordinateInterface;
  relays(): Array<string>;
  toBech32() /*throws*/ : string;
  toNostrUri() /*throws*/ : string;
}

export class Nip19Coordinate
  extends UniffiAbstractObject
  implements Nip19CoordinateInterface
{
  readonly [uniffiTypeNameSymbol] = 'Nip19Coordinate';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(
    coordinate: CoordinateInterface,
    relays: Array<string> = []
  ) /*throws*/ {
    super();
    const pointer = uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nip19coordinate_new(
          FfiConverterTypeCoordinate.lower(coordinate),
          FfiConverterArrayString.lower(relays),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeNip19CoordinateObjectFactory.bless(pointer);
  }

  public static fromBech32(
    bech32: string
  ): Nip19CoordinateInterface /*throws*/ {
    return FfiConverterTypeNip19Coordinate.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nip19coordinate_from_bech32(
            FfiConverterString.lower(bech32),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public static fromNostrUri(uri: string): Nip19CoordinateInterface /*throws*/ {
    return FfiConverterTypeNip19Coordinate.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nip19coordinate_from_nostr_uri(
            FfiConverterString.lower(uri),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public coordinate(): CoordinateInterface {
    return FfiConverterTypeCoordinate.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_coordinate(
            uniffiTypeNip19CoordinateObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public relays(): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_relays(
            uniffiTypeNip19CoordinateObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toBech32(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_to_bech32(
            uniffiTypeNip19CoordinateObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toNostrUri(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_to_nostr_uri(
            uniffiTypeNip19CoordinateObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `Nip19CoordinateInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_uniffi_trait_debug(
            uniffiTypeNip19CoordinateObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `Nip19CoordinateInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `Nip19CoordinateInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `Nip19CoordinateInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: Nip19Coordinate): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_uniffi_trait_eq_eq(
            uniffiTypeNip19CoordinateObjectFactory.clonePointer(this),
            FfiConverterTypeNip19Coordinate.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `Nip19CoordinateInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_uniffi_trait_hash(
            uniffiTypeNip19CoordinateObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeNip19CoordinateObjectFactory.pointer(this);
      uniffiTypeNip19CoordinateObjectFactory.freePointer(pointer);
      uniffiTypeNip19CoordinateObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Nip19Coordinate {
    return uniffiTypeNip19CoordinateObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNip19CoordinateObjectFactory: UniffiObjectFactory<Nip19CoordinateInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): Nip19CoordinateInterface {
      const instance = Object.create(Nip19Coordinate.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'Nip19Coordinate';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_nip19coordinate_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: Nip19CoordinateInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: Nip19CoordinateInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_nip19coordinate(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_nip19coordinate(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is Nip19CoordinateInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'Nip19Coordinate'
      );
    },
  };
// FfiConverter for Nip19CoordinateInterface
const FfiConverterTypeNip19Coordinate = new FfiConverterObject(
  uniffiTypeNip19CoordinateObjectFactory
);

export interface Nip19EventInterface {
  author(): PublicKeyInterface | undefined;
  eventId(): EventIdInterface;
  kind(): KindInterface | undefined;
  relays(): Array<string>;
  toBech32() /*throws*/ : string;
  toNostrUri() /*throws*/ : string;
}

export class Nip19Event
  extends UniffiAbstractObject
  implements Nip19EventInterface
{
  readonly [uniffiTypeNameSymbol] = 'Nip19Event';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(
    eventId: EventIdInterface,
    author: PublicKeyInterface | undefined = undefined,
    kind: KindInterface | undefined = undefined,
    relays: Array<string> = []
  ) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nip19event_new(
          FfiConverterTypeEventId.lower(eventId),
          FfiConverterOptionalTypePublicKey.lower(author),
          FfiConverterOptionalTypeKind.lower(kind),
          FfiConverterArrayString.lower(relays),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeNip19EventObjectFactory.bless(pointer);
  }

  public static fromBech32(bech32: string): Nip19EventInterface /*throws*/ {
    return FfiConverterTypeNip19Event.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nip19event_from_bech32(
            FfiConverterString.lower(bech32),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public static fromEvent(event: EventInterface): Nip19EventInterface {
    return FfiConverterTypeNip19Event.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nip19event_from_event(
            FfiConverterTypeEvent.lower(event),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public static fromNostrUri(uri: string): Nip19EventInterface /*throws*/ {
    return FfiConverterTypeNip19Event.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nip19event_from_nostr_uri(
            FfiConverterString.lower(uri),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public author(): PublicKeyInterface | undefined {
    return FfiConverterOptionalTypePublicKey.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19event_author(
            uniffiTypeNip19EventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public eventId(): EventIdInterface {
    return FfiConverterTypeEventId.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19event_event_id(
            uniffiTypeNip19EventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public kind(): KindInterface | undefined {
    return FfiConverterOptionalTypeKind.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19event_kind(
            uniffiTypeNip19EventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public relays(): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19event_relays(
            uniffiTypeNip19EventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toBech32(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19event_to_bech32(
            uniffiTypeNip19EventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toNostrUri(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19event_to_nostr_uri(
            uniffiTypeNip19EventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `Nip19EventInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19event_uniffi_trait_debug(
            uniffiTypeNip19EventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `Nip19EventInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `Nip19EventInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `Nip19EventInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: Nip19Event): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19event_uniffi_trait_eq_eq(
            uniffiTypeNip19EventObjectFactory.clonePointer(this),
            FfiConverterTypeNip19Event.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `Nip19EventInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19event_uniffi_trait_hash(
            uniffiTypeNip19EventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeNip19EventObjectFactory.pointer(this);
      uniffiTypeNip19EventObjectFactory.freePointer(pointer);
      uniffiTypeNip19EventObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Nip19Event {
    return uniffiTypeNip19EventObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNip19EventObjectFactory: UniffiObjectFactory<Nip19EventInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): Nip19EventInterface {
      const instance = Object.create(Nip19Event.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'Nip19Event';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_nip19event_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: Nip19EventInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: Nip19EventInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_nip19event(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_nip19event(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is Nip19EventInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Nip19Event'
      );
    },
  };
// FfiConverter for Nip19EventInterface
const FfiConverterTypeNip19Event = new FfiConverterObject(
  uniffiTypeNip19EventObjectFactory
);

export interface Nip19ProfileInterface {
  publicKey(): PublicKeyInterface;
  relays(): Array<string>;
  toBech32() /*throws*/ : string;
  toNostrUri() /*throws*/ : string;
}

export class Nip19Profile
  extends UniffiAbstractObject
  implements Nip19ProfileInterface
{
  readonly [uniffiTypeNameSymbol] = 'Nip19Profile';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * New NIP19 profile
   */
  constructor(
    publicKey: PublicKeyInterface,
    relays: Array<string> = []
  ) /*throws*/ {
    super();
    const pointer = uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nip19profile_new(
          FfiConverterTypePublicKey.lower(publicKey),
          FfiConverterArrayString.lower(relays),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeNip19ProfileObjectFactory.bless(pointer);
  }

  public static fromBech32(bech32: string): Nip19ProfileInterface /*throws*/ {
    return FfiConverterTypeNip19Profile.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nip19profile_from_bech32(
            FfiConverterString.lower(bech32),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public static fromNostrUri(uri: string): Nip19ProfileInterface /*throws*/ {
    return FfiConverterTypeNip19Profile.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nip19profile_from_nostr_uri(
            FfiConverterString.lower(uri),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public publicKey(): PublicKeyInterface {
    return FfiConverterTypePublicKey.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19profile_public_key(
            uniffiTypeNip19ProfileObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public relays(): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19profile_relays(
            uniffiTypeNip19ProfileObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toBech32(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19profile_to_bech32(
            uniffiTypeNip19ProfileObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toNostrUri(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19profile_to_nostr_uri(
            uniffiTypeNip19ProfileObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `Nip19ProfileInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19profile_uniffi_trait_debug(
            uniffiTypeNip19ProfileObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `Nip19ProfileInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `Nip19ProfileInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `Nip19ProfileInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: Nip19Profile): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19profile_uniffi_trait_eq_eq(
            uniffiTypeNip19ProfileObjectFactory.clonePointer(this),
            FfiConverterTypeNip19Profile.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `Nip19ProfileInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip19profile_uniffi_trait_hash(
            uniffiTypeNip19ProfileObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeNip19ProfileObjectFactory.pointer(this);
      uniffiTypeNip19ProfileObjectFactory.freePointer(pointer);
      uniffiTypeNip19ProfileObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Nip19Profile {
    return uniffiTypeNip19ProfileObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNip19ProfileObjectFactory: UniffiObjectFactory<Nip19ProfileInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): Nip19ProfileInterface {
      const instance = Object.create(Nip19Profile.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'Nip19Profile';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_nip19profile_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: Nip19ProfileInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: Nip19ProfileInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_nip19profile(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_nip19profile(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is Nip19ProfileInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'Nip19Profile'
      );
    },
  };
// FfiConverter for Nip19ProfileInterface
const FfiConverterTypeNip19Profile = new FfiConverterObject(
  uniffiTypeNip19ProfileObjectFactory
);

export interface Nip21Interface {
  asEnum(): Nip21Enum;
  /**
   * Serialize to NIP21 nostr URI
   */
  toNostrUri() /*throws*/ : string;
}

export class Nip21 extends UniffiAbstractObject implements Nip21Interface {
  readonly [uniffiTypeNameSymbol] = 'Nip21';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeNip21ObjectFactory.bless(pointer);
  }

  /**
   * Parse NIP21 string
   */
  public static parse(uri: string): Nip21Interface /*throws*/ {
    return FfiConverterTypeNip21.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nip21_parse(
            FfiConverterString.lower(uri),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asEnum(): Nip21Enum {
    return FfiConverterTypeNip21Enum.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip21_as_enum(
            uniffiTypeNip21ObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Serialize to NIP21 nostr URI
   */
  public toNostrUri(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip21_to_nostr_uri(
            uniffiTypeNip21ObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `Nip21Interface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip21_uniffi_trait_debug(
            uniffiTypeNip21ObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `Nip21Interface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `Nip21Interface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `Nip21Interface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: Nip21): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nip21_uniffi_trait_eq_eq(
            uniffiTypeNip21ObjectFactory.clonePointer(this),
            FfiConverterTypeNip21.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeNip21ObjectFactory.pointer(this);
      uniffiTypeNip21ObjectFactory.freePointer(pointer);
      uniffiTypeNip21ObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Nip21 {
    return uniffiTypeNip21ObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNip21ObjectFactory: UniffiObjectFactory<Nip21Interface> = {
  create(pointer: UnsafeMutableRawPointer): Nip21Interface {
    const instance = Object.create(Nip21.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Nip21';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_nip21_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: Nip21Interface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: Nip21Interface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_nip21(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_nip21(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is Nip21Interface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Nip21';
  },
};
// FfiConverter for Nip21Interface
const FfiConverterTypeNip21 = new FfiConverterObject(
  uniffiTypeNip21ObjectFactory
);

export interface NostrConnectInterface {
  /**
   * Get `bunker` URI
   */
  bunkerUri(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<NostrConnectUriInterface>;
  getPublicKey(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<PublicKeyInterface>;
  nip04Decrypt(
    publicKey: PublicKeyInterface,
    encryptedContent: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  nip04Encrypt(
    publicKey: PublicKeyInterface,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  nip44Decrypt(
    publicKey: PublicKeyInterface,
    payload: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  nip44Encrypt(
    publicKey: PublicKeyInterface,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  /**
   * Get signer relays
   */
  relays(): Array<string>;
  signEvent(
    unsignedEvent: UnsignedEventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<EventInterface>;
}

export class NostrConnect
  extends UniffiAbstractObject
  implements NostrConnectInterface
{
  readonly [uniffiTypeNameSymbol] = 'NostrConnect';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Construct Nostr Connect client
   */
  constructor(
    uri: NostrConnectUriInterface,
    appKeys: KeysInterface,
    timeout: UniffiDuration,
    opts: RelayOptionsInterface | undefined
  ) /*throws*/ {
    super();
    const pointer = uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nostrconnect_new(
          FfiConverterTypeNostrConnectURI.lower(uri),
          FfiConverterTypeKeys.lower(appKeys),
          FfiConverterDuration.lower(timeout),
          FfiConverterOptionalTypeRelayOptions.lower(opts),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeNostrConnectObjectFactory.bless(pointer);
  }

  /**
   * Get `bunker` URI
   */
  public async bunkerUri(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<NostrConnectUriInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnect_bunker_uri(
            uniffiTypeNostrConnectObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeNostrConnectURI.lift.bind(
          FfiConverterTypeNostrConnectURI
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async getPublicKey(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<PublicKeyInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnect_get_public_key(
            uniffiTypeNostrConnectObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypePublicKey.lift.bind(
          FfiConverterTypePublicKey
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async nip04Decrypt(
    publicKey: PublicKeyInterface,
    encryptedContent: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip04_decrypt(
            uniffiTypeNostrConnectObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterString.lower(encryptedContent)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async nip04Encrypt(
    publicKey: PublicKeyInterface,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip04_encrypt(
            uniffiTypeNostrConnectObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterString.lower(content)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async nip44Decrypt(
    publicKey: PublicKeyInterface,
    payload: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip44_decrypt(
            uniffiTypeNostrConnectObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterString.lower(payload)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async nip44Encrypt(
    publicKey: PublicKeyInterface,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip44_encrypt(
            uniffiTypeNostrConnectObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterString.lower(content)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get signer relays
   */
  public relays(): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnect_relays(
            uniffiTypeNostrConnectObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async signEvent(
    unsignedEvent: UnsignedEventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<EventInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnect_sign_event(
            uniffiTypeNostrConnectObjectFactory.clonePointer(this),
            FfiConverterTypeUnsignedEvent.lower(unsignedEvent)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeEvent.lift.bind(FfiConverterTypeEvent),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeNostrConnectObjectFactory.pointer(this);
      uniffiTypeNostrConnectObjectFactory.freePointer(pointer);
      uniffiTypeNostrConnectObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is NostrConnect {
    return uniffiTypeNostrConnectObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNostrConnectObjectFactory: UniffiObjectFactory<NostrConnectInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): NostrConnectInterface {
      const instance = Object.create(NostrConnect.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'NostrConnect';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_nostrconnect_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: NostrConnectInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: NostrConnectInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_nostrconnect(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_nostrconnect(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is NostrConnectInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'NostrConnect'
      );
    },
  };
// FfiConverter for NostrConnectInterface
const FfiConverterTypeNostrConnect = new FfiConverterObject(
  uniffiTypeNostrConnectObjectFactory
);

export interface NostrConnectMetadataInterface {
  /**
   * Serialize as JSON string
   */
  asJson() /*throws*/ : string;
  /**
   * Description of the `App`
   */
  description(description: string): NostrConnectMetadataInterface;
  /**
   * List of URLs for icons of the `App`
   */
  icons(icons: Array<string>): NostrConnectMetadataInterface;
  /**
   * URL of the website requesting the connection
   */
  url(url: string) /*throws*/ : NostrConnectMetadataInterface;
}

export class NostrConnectMetadata
  extends UniffiAbstractObject
  implements NostrConnectMetadataInterface
{
  readonly [uniffiTypeNameSymbol] = 'NostrConnectMetadata';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * New Nostr Connect Metadata
   */
  constructor(name: string) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nostrconnectmetadata_new(
          FfiConverterString.lower(name),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeNostrConnectMetadataObjectFactory.bless(pointer);
  }

  /**
   * Serialize as JSON string
   */
  public asJson(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_as_json(
            uniffiTypeNostrConnectMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Description of the `App`
   */
  public description(description: string): NostrConnectMetadataInterface {
    return FfiConverterTypeNostrConnectMetadata.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_description(
            uniffiTypeNostrConnectMetadataObjectFactory.clonePointer(this),
            FfiConverterString.lower(description),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * List of URLs for icons of the `App`
   */
  public icons(icons: Array<string>): NostrConnectMetadataInterface {
    return FfiConverterTypeNostrConnectMetadata.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_icons(
            uniffiTypeNostrConnectMetadataObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(icons),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * URL of the website requesting the connection
   */
  public url(url: string): NostrConnectMetadataInterface /*throws*/ {
    return FfiConverterTypeNostrConnectMetadata.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_url(
            uniffiTypeNostrConnectMetadataObjectFactory.clonePointer(this),
            FfiConverterString.lower(url),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `NostrConnectMetadataInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_uniffi_trait_debug(
            uniffiTypeNostrConnectMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `NostrConnectMetadataInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `NostrConnectMetadataInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `NostrConnectMetadataInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: NostrConnectMetadata): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_uniffi_trait_eq_eq(
            uniffiTypeNostrConnectMetadataObjectFactory.clonePointer(this),
            FfiConverterTypeNostrConnectMetadata.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `NostrConnectMetadataInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_uniffi_trait_hash(
            uniffiTypeNostrConnectMetadataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeNostrConnectMetadataObjectFactory.pointer(this);
      uniffiTypeNostrConnectMetadataObjectFactory.freePointer(pointer);
      uniffiTypeNostrConnectMetadataObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is NostrConnectMetadata {
    return uniffiTypeNostrConnectMetadataObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNostrConnectMetadataObjectFactory: UniffiObjectFactory<NostrConnectMetadataInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): NostrConnectMetadataInterface {
      const instance = Object.create(NostrConnectMetadata.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'NostrConnectMetadata';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_nostrconnectmetadata_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: NostrConnectMetadataInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: NostrConnectMetadataInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_nostrconnectmetadata(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_nostrconnectmetadata(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is NostrConnectMetadataInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'NostrConnectMetadata'
      );
    },
  };
// FfiConverter for NostrConnectMetadataInterface
const FfiConverterTypeNostrConnectMetadata = new FfiConverterObject(
  uniffiTypeNostrConnectMetadataObjectFactory
);

export interface NostrConnectUriInterface {}

export class NostrConnectUri
  extends UniffiAbstractObject
  implements NostrConnectUriInterface
{
  readonly [uniffiTypeNameSymbol] = 'NostrConnectUri';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeNostrConnectUriObjectFactory.bless(pointer);
  }

  public static parse(uri: string): NostrConnectUriInterface /*throws*/ {
    return FfiConverterTypeNostrConnectURI.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nostrconnecturi_parse(
            FfiConverterString.lower(uri),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `NostrConnectUriInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_debug(
            uniffiTypeNostrConnectUriObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `NostrConnectUriInterface::to_string()` method of the native Rust peer.
   *
   * Generated by deriving the `Display` trait in Rust.
   */
  toString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_display(
            uniffiTypeNostrConnectUriObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `==` method of `NostrConnectUriInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `NostrConnectUriInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: NostrConnectUri): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_eq_eq(
            uniffiTypeNostrConnectUriObjectFactory.clonePointer(this),
            FfiConverterTypeNostrConnectURI.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `NostrConnectUriInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_hash(
            uniffiTypeNostrConnectUriObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeNostrConnectUriObjectFactory.pointer(this);
      uniffiTypeNostrConnectUriObjectFactory.freePointer(pointer);
      uniffiTypeNostrConnectUriObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is NostrConnectUri {
    return uniffiTypeNostrConnectUriObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNostrConnectUriObjectFactory: UniffiObjectFactory<NostrConnectUriInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): NostrConnectUriInterface {
      const instance = Object.create(NostrConnectUri.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'NostrConnectUri';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_nostrconnecturi_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: NostrConnectUriInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: NostrConnectUriInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_nostrconnecturi(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_nostrconnecturi(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is NostrConnectUriInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'NostrConnectUri'
      );
    },
  };
// FfiConverter for NostrConnectUriInterface
const FfiConverterTypeNostrConnectURI = new FfiConverterObject(
  uniffiTypeNostrConnectUriObjectFactory
);

export interface NostrDatabaseInterface {
  count(
    filter: FilterInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise</*u64*/ bigint>;
  /**
   * Delete all events that match the `Filter`
   */
  delete_(
    filter: FilterInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Get [`Event`] by [`EventId`]
   */
  eventById(
    eventId: EventIdInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<EventInterface | undefined>;
  metadata(
    publicKey: PublicKeyInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<MetadataInterface | undefined>;
  query(
    filter: FilterInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<EventsInterface>;
  /**
   * Save [`Event`] into store
   */
  saveEvent(
    event: EventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<SaveEventStatus>;
  /**
   * Wipe all data
   */
  wipe(asyncOpts_?: { signal: AbortSignal }) /*throws*/ : Promise<void>;
}

export class NostrDatabase
  extends UniffiAbstractObject
  implements NostrDatabaseInterface
{
  readonly [uniffiTypeNameSymbol] = 'NostrDatabase';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeNostrDatabaseObjectFactory.bless(pointer);
  }

  /**
   * LMDB backend
   */
  public static lmdb(path: string): NostrDatabaseInterface /*throws*/ {
    return FfiConverterTypeNostrDatabase.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nostrdatabase_lmdb(
            FfiConverterString.lower(path),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async count(
    filter: FilterInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise</*u64*/ bigint> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_count(
            uniffiTypeNostrDatabaseObjectFactory.clonePointer(this),
            FfiConverterTypeFilter.lower(filter)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_u64,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_u64,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_u64,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_u64,
        /*liftFunc:*/ FfiConverterUInt64.lift.bind(FfiConverterUInt64),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Delete all events that match the `Filter`
   */
  public async delete_(
    filter: FilterInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_delete(
            uniffiTypeNostrDatabaseObjectFactory.clonePointer(this),
            FfiConverterTypeFilter.lower(filter)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get [`Event`] by [`EventId`]
   */
  public async eventById(
    eventId: EventIdInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<EventInterface | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_event_by_id(
            uniffiTypeNostrDatabaseObjectFactory.clonePointer(this),
            FfiConverterTypeEventId.lower(eventId)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeEvent.lift.bind(
          FfiConverterOptionalTypeEvent
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async metadata(
    publicKey: PublicKeyInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<MetadataInterface | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_metadata(
            uniffiTypeNostrDatabaseObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(publicKey)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeMetadata.lift.bind(
          FfiConverterOptionalTypeMetadata
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async query(
    filter: FilterInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<EventsInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_query(
            uniffiTypeNostrDatabaseObjectFactory.clonePointer(this),
            FfiConverterTypeFilter.lower(filter)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeEvents.lift.bind(FfiConverterTypeEvents),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Save [`Event`] into store
   */
  public async saveEvent(
    event: EventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<SaveEventStatus> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_save_event(
            uniffiTypeNostrDatabaseObjectFactory.clonePointer(this),
            FfiConverterTypeEvent.lower(event)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeSaveEventStatus.lift.bind(
          FfiConverterTypeSaveEventStatus
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Wipe all data
   */
  public async wipe(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_wipe(
            uniffiTypeNostrDatabaseObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeNostrDatabaseObjectFactory.pointer(this);
      uniffiTypeNostrDatabaseObjectFactory.freePointer(pointer);
      uniffiTypeNostrDatabaseObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is NostrDatabase {
    return uniffiTypeNostrDatabaseObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNostrDatabaseObjectFactory: UniffiObjectFactory<NostrDatabaseInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): NostrDatabaseInterface {
      const instance = Object.create(NostrDatabase.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'NostrDatabase';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_nostrdatabase_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: NostrDatabaseInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: NostrDatabaseInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_nostrdatabase(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_nostrdatabase(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is NostrDatabaseInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'NostrDatabase'
      );
    },
  };
// FfiConverter for NostrDatabaseInterface
const FfiConverterTypeNostrDatabase = new FfiConverterObject(
  uniffiTypeNostrDatabaseObjectFactory
);

export interface NostrSignerInterface {
  backend(): SignerBackend;
  getPublicKey(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<PublicKeyInterface>;
  nip04Decrypt(
    publicKey: PublicKeyInterface,
    encryptedContent: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  nip04Encrypt(
    publicKey: PublicKeyInterface,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  nip44Decrypt(
    publicKey: PublicKeyInterface,
    payload: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  nip44Encrypt(
    publicKey: PublicKeyInterface,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  signEvent(
    unsignedEvent: UnsignedEventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<EventInterface>;
}

export class NostrSigner
  extends UniffiAbstractObject
  implements NostrSignerInterface
{
  readonly [uniffiTypeNameSymbol] = 'NostrSigner';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeNostrSignerObjectFactory.bless(pointer);
  }

  public static custom(custom: CustomNostrSigner): NostrSignerInterface {
    return FfiConverterTypeNostrSigner.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_custom(
            FfiConverterTypeCustomNostrSigner.lower(custom),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public static keys(keys: KeysInterface): NostrSignerInterface {
    return FfiConverterTypeNostrSigner.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_keys(
            FfiConverterTypeKeys.lower(keys),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public static nostrConnect(
    connect: NostrConnectInterface
  ): NostrSignerInterface {
    return FfiConverterTypeNostrSigner.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_nostr_connect(
            FfiConverterTypeNostrConnect.lower(connect),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public backend(): SignerBackend {
    return FfiConverterTypeSignerBackend.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrsigner_backend(
            uniffiTypeNostrSignerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public async getPublicKey(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<PublicKeyInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrsigner_get_public_key(
            uniffiTypeNostrSignerObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypePublicKey.lift.bind(
          FfiConverterTypePublicKey
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async nip04Decrypt(
    publicKey: PublicKeyInterface,
    encryptedContent: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip04_decrypt(
            uniffiTypeNostrSignerObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterString.lower(encryptedContent)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async nip04Encrypt(
    publicKey: PublicKeyInterface,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip04_encrypt(
            uniffiTypeNostrSignerObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterString.lower(content)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async nip44Decrypt(
    publicKey: PublicKeyInterface,
    payload: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip44_decrypt(
            uniffiTypeNostrSignerObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterString.lower(payload)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async nip44Encrypt(
    publicKey: PublicKeyInterface,
    content: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip44_encrypt(
            uniffiTypeNostrSignerObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterString.lower(content)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async signEvent(
    unsignedEvent: UnsignedEventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<EventInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrsigner_sign_event(
            uniffiTypeNostrSignerObjectFactory.clonePointer(this),
            FfiConverterTypeUnsignedEvent.lower(unsignedEvent)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeEvent.lift.bind(FfiConverterTypeEvent),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeNostrSignerObjectFactory.pointer(this);
      uniffiTypeNostrSignerObjectFactory.freePointer(pointer);
      uniffiTypeNostrSignerObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is NostrSigner {
    return uniffiTypeNostrSignerObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNostrSignerObjectFactory: UniffiObjectFactory<NostrSignerInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): NostrSignerInterface {
      const instance = Object.create(NostrSigner.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'NostrSigner';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_nostrsigner_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: NostrSignerInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: NostrSignerInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_nostrsigner(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_nostrsigner(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is NostrSignerInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'NostrSigner'
      );
    },
  };
// FfiConverter for NostrSignerInterface
const FfiConverterTypeNostrSigner = new FfiConverterObject(
  uniffiTypeNostrSignerObjectFactory
);

/**
 * NWC options
 */
export interface NostrWalletConnectOptionsInterface {
  /**
   * Set connection mode
   */
  connectionMode(
    mode: ConnectionMode
  ) /*throws*/ : NostrWalletConnectOptionsInterface;
  /**
   * Set NWC requests timeout (default: 10 secs)
   */
  timeout(timeout: UniffiDuration): NostrWalletConnectOptionsInterface;
}

/**
 * NWC options
 */
export class NostrWalletConnectOptions
  extends UniffiAbstractObject
  implements NostrWalletConnectOptionsInterface
{
  readonly [uniffiTypeNameSymbol] = 'NostrWalletConnectOptions';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * New default NWC options
   */
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nostrwalletconnectoptions_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeNostrWalletConnectOptionsObjectFactory.bless(pointer);
  }

  /**
   * Set connection mode
   */
  public connectionMode(
    mode: ConnectionMode
  ): NostrWalletConnectOptionsInterface /*throws*/ {
    return FfiConverterTypeNostrWalletConnectOptions.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnectoptions_connection_mode(
            uniffiTypeNostrWalletConnectOptionsObjectFactory.clonePointer(this),
            FfiConverterTypeConnectionMode.lower(mode),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set NWC requests timeout (default: 10 secs)
   */
  public timeout(timeout: UniffiDuration): NostrWalletConnectOptionsInterface {
    return FfiConverterTypeNostrWalletConnectOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnectoptions_timeout(
            uniffiTypeNostrWalletConnectOptionsObjectFactory.clonePointer(this),
            FfiConverterDuration.lower(timeout),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeNostrWalletConnectOptionsObjectFactory.pointer(this);
      uniffiTypeNostrWalletConnectOptionsObjectFactory.freePointer(pointer);
      uniffiTypeNostrWalletConnectOptionsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is NostrWalletConnectOptions {
    return uniffiTypeNostrWalletConnectOptionsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNostrWalletConnectOptionsObjectFactory: UniffiObjectFactory<NostrWalletConnectOptionsInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): NostrWalletConnectOptionsInterface {
      const instance = Object.create(NostrWalletConnectOptions.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'NostrWalletConnectOptions';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_nostrwalletconnectoptions_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: NostrWalletConnectOptionsInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: NostrWalletConnectOptionsInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_nostrwalletconnectoptions(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_nostrwalletconnectoptions(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is NostrWalletConnectOptionsInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'NostrWalletConnectOptions'
      );
    },
  };
// FfiConverter for NostrWalletConnectOptionsInterface
const FfiConverterTypeNostrWalletConnectOptions = new FfiConverterObject(
  uniffiTypeNostrWalletConnectOptionsObjectFactory
);

/**
 * Nostr Connect URI
 */
export interface NostrWalletConnectUriInterface {
  /**
   * A lightning address that clients can use to automatically setup the lud16 field on the user's profile if they have none configured.
   */
  lud16(): string | undefined;
  /**
   * App Pubkey
   */
  publicKey(): PublicKeyInterface;
  /**
   * URLs of the relays of choice where the `App` is connected and the `Signer` must send and listen for messages.
   */
  relays(): Array<string>;
  /**
   * 32-byte randomly generated hex encoded string
   */
  secret(): SecretKeyInterface;
}

/**
 * Nostr Connect URI
 */
export class NostrWalletConnectUri
  extends UniffiAbstractObject
  implements NostrWalletConnectUriInterface
{
  readonly [uniffiTypeNameSymbol] = 'NostrWalletConnectUri';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Create new Nostr Wallet Connect URI
   */
  constructor(
    publicKey: PublicKeyInterface,
    relays: Array<string>,
    randomSecretKey: SecretKeyInterface,
    lud16: string | undefined
  ) /*throws*/ {
    super();
    const pointer = uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nostrwalletconnecturi_new(
          FfiConverterTypePublicKey.lower(publicKey),
          FfiConverterArrayString.lower(relays),
          FfiConverterTypeSecretKey.lower(randomSecretKey),
          FfiConverterOptionalString.lower(lud16),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeNostrWalletConnectUriObjectFactory.bless(pointer);
  }

  public static parse(uri: string): NostrWalletConnectUriInterface /*throws*/ {
    return FfiConverterTypeNostrWalletConnectURI.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_nostrwalletconnecturi_parse(
            FfiConverterString.lower(uri),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * A lightning address that clients can use to automatically setup the lud16 field on the user's profile if they have none configured.
   */
  public lud16(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_lud16(
            uniffiTypeNostrWalletConnectUriObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * App Pubkey
   */
  public publicKey(): PublicKeyInterface {
    return FfiConverterTypePublicKey.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_public_key(
            uniffiTypeNostrWalletConnectUriObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * URLs of the relays of choice where the `App` is connected and the `Signer` must send and listen for messages.
   */
  public relays(): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_relays(
            uniffiTypeNostrWalletConnectUriObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * 32-byte randomly generated hex encoded string
   */
  public secret(): SecretKeyInterface {
    return FfiConverterTypeSecretKey.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_secret(
            uniffiTypeNostrWalletConnectUriObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `NostrWalletConnectUriInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_debug(
            uniffiTypeNostrWalletConnectUriObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `NostrWalletConnectUriInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `NostrWalletConnectUriInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `NostrWalletConnectUriInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: NostrWalletConnectUri): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_eq_eq(
            uniffiTypeNostrWalletConnectUriObjectFactory.clonePointer(this),
            FfiConverterTypeNostrWalletConnectURI.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeNostrWalletConnectUriObjectFactory.pointer(this);
      uniffiTypeNostrWalletConnectUriObjectFactory.freePointer(pointer);
      uniffiTypeNostrWalletConnectUriObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is NostrWalletConnectUri {
    return uniffiTypeNostrWalletConnectUriObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNostrWalletConnectUriObjectFactory: UniffiObjectFactory<NostrWalletConnectUriInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): NostrWalletConnectUriInterface {
      const instance = Object.create(NostrWalletConnectUri.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'NostrWalletConnectUri';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_nostrwalletconnecturi_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: NostrWalletConnectUriInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: NostrWalletConnectUriInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_nostrwalletconnecturi(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_nostrwalletconnecturi(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is NostrWalletConnectUriInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'NostrWalletConnectUri'
      );
    },
  };
// FfiConverter for NostrWalletConnectUriInterface
const FfiConverterTypeNostrWalletConnectURI = new FfiConverterObject(
  uniffiTypeNostrWalletConnectUriObjectFactory
);

export interface OptionsInterface {
  /**
   * Automatically start connection with relays (default: false)
   *
   * When set to `true`, there isn't the need of calling the connect methods.
   */
  autoconnect(val: boolean): OptionsInterface;
  /**
   * Auto authenticate to relays (default: true)
   *
   * <https://github.com/nostr-protocol/nips/blob/master/42.md>
   */
  automaticAuthentication(enabled: boolean): OptionsInterface;
  /**
   * Connection
   */
  connection(connection: ConnectionInterface): OptionsInterface;
  /**
   * Enable gossip model (default: false)
   */
  gossip(enabled: boolean): OptionsInterface;
  /**
   * Set max latency (default: None)
   *
   * Relays with an avg. latency greater that this value will be skipped.
   */
  maxAvgLatency(max: UniffiDuration): OptionsInterface;
  /**
   * Set custom relay limits
   */
  relayLimits(limits: RelayLimitsInterface): OptionsInterface;
}

export class Options extends UniffiAbstractObject implements OptionsInterface {
  readonly [uniffiTypeNameSymbol] = 'Options';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_options_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeOptionsObjectFactory.bless(pointer);
  }

  /**
   * Automatically start connection with relays (default: false)
   *
   * When set to `true`, there isn't the need of calling the connect methods.
   */
  public autoconnect(val: boolean): OptionsInterface {
    return FfiConverterTypeOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_options_autoconnect(
            uniffiTypeOptionsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(val),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Auto authenticate to relays (default: true)
   *
   * <https://github.com/nostr-protocol/nips/blob/master/42.md>
   */
  public automaticAuthentication(enabled: boolean): OptionsInterface {
    return FfiConverterTypeOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_options_automatic_authentication(
            uniffiTypeOptionsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(enabled),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Connection
   */
  public connection(connection: ConnectionInterface): OptionsInterface {
    return FfiConverterTypeOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_options_connection(
            uniffiTypeOptionsObjectFactory.clonePointer(this),
            FfiConverterTypeConnection.lower(connection),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Enable gossip model (default: false)
   */
  public gossip(enabled: boolean): OptionsInterface {
    return FfiConverterTypeOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_options_gossip(
            uniffiTypeOptionsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(enabled),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set max latency (default: None)
   *
   * Relays with an avg. latency greater that this value will be skipped.
   */
  public maxAvgLatency(max: UniffiDuration): OptionsInterface {
    return FfiConverterTypeOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_options_max_avg_latency(
            uniffiTypeOptionsObjectFactory.clonePointer(this),
            FfiConverterDuration.lower(max),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set custom relay limits
   */
  public relayLimits(limits: RelayLimitsInterface): OptionsInterface {
    return FfiConverterTypeOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_options_relay_limits(
            uniffiTypeOptionsObjectFactory.clonePointer(this),
            FfiConverterTypeRelayLimits.lower(limits),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeOptionsObjectFactory.pointer(this);
      uniffiTypeOptionsObjectFactory.freePointer(pointer);
      uniffiTypeOptionsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Options {
    return uniffiTypeOptionsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeOptionsObjectFactory: UniffiObjectFactory<OptionsInterface> = {
  create(pointer: UnsafeMutableRawPointer): OptionsInterface {
    const instance = Object.create(Options.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Options';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_options_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: OptionsInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: OptionsInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_options(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_options(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is OptionsInterface {
    return (
      obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Options'
    );
  },
};
// FfiConverter for OptionsInterface
const FfiConverterTypeOptions = new FfiConverterObject(
  uniffiTypeOptionsObjectFactory
);

export interface PublicKeyInterface {
  toBech32() /*throws*/ : string;
  toHex(): string;
  toNostrUri() /*throws*/ : string;
}

export class PublicKey
  extends UniffiAbstractObject
  implements PublicKeyInterface
{
  readonly [uniffiTypeNameSymbol] = 'PublicKey';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypePublicKeyObjectFactory.bless(pointer);
  }

  public static fromBytes(bytes: ArrayBuffer): PublicKeyInterface /*throws*/ {
    return FfiConverterTypePublicKey.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_publickey_from_bytes(
            FfiConverterArrayBuffer.lower(bytes),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Try to parse public key from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
   */
  public static parse(publicKey: string): PublicKeyInterface /*throws*/ {
    return FfiConverterTypePublicKey.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_publickey_parse(
            FfiConverterString.lower(publicKey),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toBech32(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_publickey_to_bech32(
            uniffiTypePublicKeyObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toHex(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_publickey_to_hex(
            uniffiTypePublicKeyObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toNostrUri(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_publickey_to_nostr_uri(
            uniffiTypePublicKeyObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `PublicKeyInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_publickey_uniffi_trait_debug(
            uniffiTypePublicKeyObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `PublicKeyInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `PublicKeyInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `PublicKeyInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: PublicKey): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_publickey_uniffi_trait_eq_eq(
            uniffiTypePublicKeyObjectFactory.clonePointer(this),
            FfiConverterTypePublicKey.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `PublicKeyInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_publickey_uniffi_trait_hash(
            uniffiTypePublicKeyObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypePublicKeyObjectFactory.pointer(this);
      uniffiTypePublicKeyObjectFactory.freePointer(pointer);
      uniffiTypePublicKeyObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is PublicKey {
    return uniffiTypePublicKeyObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypePublicKeyObjectFactory: UniffiObjectFactory<PublicKeyInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): PublicKeyInterface {
      const instance = Object.create(PublicKey.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'PublicKey';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_publickey_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: PublicKeyInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: PublicKeyInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_publickey(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_publickey(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is PublicKeyInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'PublicKey'
      );
    },
  };
// FfiConverter for PublicKeyInterface
const FfiConverterTypePublicKey = new FfiConverterObject(
  uniffiTypePublicKeyObjectFactory
);

export interface RelayInterface {
  /**
   * Send multiple `ClientMessage` at once
   */
  batchMsg(msgs: Array<ClientMessageInterface>) /*throws*/ : void;
  /**
   * Connect to the relay
   *
   * # Overview
   *
   * If the relays status is not [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`],
   * this method returns immediately without doing anything.
   * Otherwise, the connection task will be spawned, which will attempt to connect to relay.
   *
   * This method returns immediately and doesn't provide any information on if the connection was successful or not.
   *
   * # Automatic reconnection
   *
   * By default, in case of disconnection, the connection task will automatically attempt to reconnect.
   * This behavior can be disabled by changing [`RelayOptions::reconnect`] option.
   */
  connect(): void;
  /**
   * Get connection mode
   */
  connectionMode(): ConnectionMode;
  /**
   * Count events
   */
  countEvents(
    filter: FilterInterface,
    timeout: UniffiDuration,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise</*u64*/ bigint>;
  /**
   * Disconnect from relay and set status to 'Terminated'
   */
  disconnect(): void;
  document(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RelayInformationDocumentInterface>;
  /**
   * Fetch events
   */
  fetchEvents(
    filter: FilterInterface,
    timeout: UniffiDuration,
    policy: ReqExitPolicy,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<EventsInterface>;
  /**
   * Check if `Relay` is connected
   */
  isConnected(): boolean;
  opts(): RelayOptionsInterface;
  /**
   * Get number of messages in queue
   */
  queue(): /*u64*/ bigint;
  /**
   * Send event and wait for `OK` relay msg
   */
  sendEvent(
    event: EventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<EventIdInterface>;
  /**
   * Send msg to relay
   */
  sendMsg(msg: ClientMessageInterface) /*throws*/ : void;
  stats(): RelayConnectionStatsInterface;
  /**
   * Get status
   */
  status(): RelayStatus;
  /**
   * Subscribe to filters
   *
   * Internally generate a new random subscription ID. Check `subscribe_with_id` method to use a custom subscription ID.
   *
   * ### Auto-closing subscription
   *
   * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
   *
   * Note: auto-closing subscriptions aren't saved in subscriptions map!
   */
  subscribe(
    filter: FilterInterface,
    opts: SubscribeOptionsInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<string>;
  /**
   * Subscribe with custom subscription ID
   *
   * ### Auto-closing subscription
   *
   * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
   *
   * Note: auto-closing subscriptions aren't saved in subscriptions map!
   */
  subscribeWithId(
    id: string,
    filter: FilterInterface,
    opts: SubscribeOptionsInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Get filters by subscription ID
   */
  subscription(
    id: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FilterInterface | undefined>;
  subscriptions(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Map<string, FilterInterface>>;
  /**
   * Sync events with relays (negentropy reconciliation)
   */
  sync(
    filter: FilterInterface,
    opts: SyncOptionsInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Reconciliation>;
  /**
   * Sync events with relays (negentropy reconciliation)
   */
  syncWithItems(
    filter: FilterInterface,
    items: Array<NegentropyItem>,
    opts: SyncOptionsInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<Reconciliation>;
  /**
   * Try to establish a connection with the relay.
   *
   * # Overview
   *
   * If the relays status is not [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`],
   * this method returns immediately without doing anything.
   * Otherwise, attempts to establish a connection without spawning the connection task if it fails.
   * This means that if the connection fails, no automatic retries are scheduled.
   * Use [`Relay::connect`] if you want to immediately spawn a connection task,
   * regardless of whether the initial connection succeeds.
   *
   * Returns an error if the connection fails.
   *
   * # Automatic reconnection
   *
   * By default, in case of disconnection (after a first successful connection),
   * the connection task will automatically attempt to reconnect.
   * This behavior can be disabled by changing [`RelayOptions::reconnect`] option.
   */
  tryConnect(
    timeout: UniffiDuration,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Unsubscribe
   */
  unsubscribe(
    id: string,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Unsubscribe from all subscriptions
   */
  unsubscribeAll(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
  /**
   * Get relay url
   */
  url(): string;
}

export class Relay extends UniffiAbstractObject implements RelayInterface {
  readonly [uniffiTypeNameSymbol] = 'Relay';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeRelayObjectFactory.bless(pointer);
  }

  /**
   * Send multiple `ClientMessage` at once
   */
  public batchMsg(msgs: Array<ClientMessageInterface>): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_batch_msg(
          uniffiTypeRelayObjectFactory.clonePointer(this),
          FfiConverterArrayTypeClientMessage.lower(msgs),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Connect to the relay
   *
   * # Overview
   *
   * If the relays status is not [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`],
   * this method returns immediately without doing anything.
   * Otherwise, the connection task will be spawned, which will attempt to connect to relay.
   *
   * This method returns immediately and doesn't provide any information on if the connection was successful or not.
   *
   * # Automatic reconnection
   *
   * By default, in case of disconnection, the connection task will automatically attempt to reconnect.
   * This behavior can be disabled by changing [`RelayOptions::reconnect`] option.
   */
  public connect(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_connect(
          uniffiTypeRelayObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Get connection mode
   */
  public connectionMode(): ConnectionMode {
    return FfiConverterTypeConnectionMode.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_connection_mode(
            uniffiTypeRelayObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Count events
   */
  public async countEvents(
    filter: FilterInterface,
    timeout: UniffiDuration,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise</*u64*/ bigint> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_count_events(
            uniffiTypeRelayObjectFactory.clonePointer(this),
            FfiConverterTypeFilter.lower(filter),
            FfiConverterDuration.lower(timeout)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_u64,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_u64,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_u64,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_u64,
        /*liftFunc:*/ FfiConverterUInt64.lift.bind(FfiConverterUInt64),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Disconnect from relay and set status to 'Terminated'
   */
  public disconnect(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_disconnect(
          uniffiTypeRelayObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public async document(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<RelayInformationDocumentInterface> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_document(
            uniffiTypeRelayObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeRelayInformationDocument.lift.bind(
          FfiConverterTypeRelayInformationDocument
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Fetch events
   */
  public async fetchEvents(
    filter: FilterInterface,
    timeout: UniffiDuration,
    policy: ReqExitPolicy,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<EventsInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_fetch_events(
            uniffiTypeRelayObjectFactory.clonePointer(this),
            FfiConverterTypeFilter.lower(filter),
            FfiConverterDuration.lower(timeout),
            FfiConverterTypeReqExitPolicy.lower(policy)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeEvents.lift.bind(FfiConverterTypeEvents),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Check if `Relay` is connected
   */
  public isConnected(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_is_connected(
            uniffiTypeRelayObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public opts(): RelayOptionsInterface {
    return FfiConverterTypeRelayOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_opts(
            uniffiTypeRelayObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get number of messages in queue
   */
  public queue(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_queue(
            uniffiTypeRelayObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Send event and wait for `OK` relay msg
   */
  public async sendEvent(
    event: EventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<EventIdInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_send_event(
            uniffiTypeRelayObjectFactory.clonePointer(this),
            FfiConverterTypeEvent.lower(event)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeEventId.lift.bind(
          FfiConverterTypeEventId
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Send msg to relay
   */
  public sendMsg(msg: ClientMessageInterface): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
        FfiConverterTypeNostrSdkError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_send_msg(
          uniffiTypeRelayObjectFactory.clonePointer(this),
          FfiConverterTypeClientMessage.lower(msg),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public stats(): RelayConnectionStatsInterface {
    return FfiConverterTypeRelayConnectionStats.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_stats(
            uniffiTypeRelayObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get status
   */
  public status(): RelayStatus {
    return FfiConverterTypeRelayStatus.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_status(
            uniffiTypeRelayObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Subscribe to filters
   *
   * Internally generate a new random subscription ID. Check `subscribe_with_id` method to use a custom subscription ID.
   *
   * ### Auto-closing subscription
   *
   * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
   *
   * Note: auto-closing subscriptions aren't saved in subscriptions map!
   */
  public async subscribe(
    filter: FilterInterface,
    opts: SubscribeOptionsInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_subscribe(
            uniffiTypeRelayObjectFactory.clonePointer(this),
            FfiConverterTypeFilter.lower(filter),
            FfiConverterTypeSubscribeOptions.lower(opts)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Subscribe with custom subscription ID
   *
   * ### Auto-closing subscription
   *
   * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
   *
   * Note: auto-closing subscriptions aren't saved in subscriptions map!
   */
  public async subscribeWithId(
    id: string,
    filter: FilterInterface,
    opts: SubscribeOptionsInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_subscribe_with_id(
            uniffiTypeRelayObjectFactory.clonePointer(this),
            FfiConverterString.lower(id),
            FfiConverterTypeFilter.lower(filter),
            FfiConverterTypeSubscribeOptions.lower(opts)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get filters by subscription ID
   */
  public async subscription(
    id: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<FilterInterface | undefined> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_subscription(
            uniffiTypeRelayObjectFactory.clonePointer(this),
            FfiConverterString.lower(id)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeFilter.lift.bind(
          FfiConverterOptionalTypeFilter
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async subscriptions(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<Map<string, FilterInterface>> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_subscriptions(
            uniffiTypeRelayObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterMapStringTypeFilter.lift.bind(
          FfiConverterMapStringTypeFilter
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sync events with relays (negentropy reconciliation)
   */
  public async sync(
    filter: FilterInterface,
    opts: SyncOptionsInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Reconciliation> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_sync(
            uniffiTypeRelayObjectFactory.clonePointer(this),
            FfiConverterTypeFilter.lower(filter),
            FfiConverterTypeSyncOptions.lower(opts)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeReconciliation.lift.bind(
          FfiConverterTypeReconciliation
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sync events with relays (negentropy reconciliation)
   */
  public async syncWithItems(
    filter: FilterInterface,
    items: Array<NegentropyItem>,
    opts: SyncOptionsInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<Reconciliation> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_sync_with_items(
            uniffiTypeRelayObjectFactory.clonePointer(this),
            FfiConverterTypeFilter.lower(filter),
            FfiConverterArrayTypeNegentropyItem.lower(items),
            FfiConverterTypeSyncOptions.lower(opts)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterTypeReconciliation.lift.bind(
          FfiConverterTypeReconciliation
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Try to establish a connection with the relay.
   *
   * # Overview
   *
   * If the relays status is not [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`],
   * this method returns immediately without doing anything.
   * Otherwise, attempts to establish a connection without spawning the connection task if it fails.
   * This means that if the connection fails, no automatic retries are scheduled.
   * Use [`Relay::connect`] if you want to immediately spawn a connection task,
   * regardless of whether the initial connection succeeds.
   *
   * Returns an error if the connection fails.
   *
   * # Automatic reconnection
   *
   * By default, in case of disconnection (after a first successful connection),
   * the connection task will automatically attempt to reconnect.
   * This behavior can be disabled by changing [`RelayOptions::reconnect`] option.
   */
  public async tryConnect(
    timeout: UniffiDuration,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_try_connect(
            uniffiTypeRelayObjectFactory.clonePointer(this),
            FfiConverterDuration.lower(timeout)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Unsubscribe
   */
  public async unsubscribe(
    id: string,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_unsubscribe(
            uniffiTypeRelayObjectFactory.clonePointer(this),
            FfiConverterString.lower(id)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Unsubscribe from all subscriptions
   */
  public async unsubscribeAll(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_unsubscribe_all(
            uniffiTypeRelayObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get relay url
   */
  public url(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relay_url(
            uniffiTypeRelayObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRelayObjectFactory.pointer(this);
      uniffiTypeRelayObjectFactory.freePointer(pointer);
      uniffiTypeRelayObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Relay {
    return uniffiTypeRelayObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRelayObjectFactory: UniffiObjectFactory<RelayInterface> = {
  create(pointer: UnsafeMutableRawPointer): RelayInterface {
    const instance = Object.create(Relay.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Relay';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_relay_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: RelayInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: RelayInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_relay(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_relay(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is RelayInterface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Relay';
  },
};
// FfiConverter for RelayInterface
const FfiConverterTypeRelay = new FfiConverterObject(
  uniffiTypeRelayObjectFactory
);

export interface RelayConnectionStatsInterface {
  /**
   * The number of times a connection has been attempted
   */
  attempts(): /*u64*/ bigint;
  /**
   * Bytes received
   */
  bytesReceived(): /*u64*/ bigint;
  /**
   * Bytes sent
   */
  bytesSent(): /*u64*/ bigint;
  /**
   * Get UNIX timestamp of the last connection
   */
  connectedAt(): TimestampInterface;
  /**
   * Get UNIX timestamp of the first connection
   */
  firstConnectionTimestamp(): TimestampInterface;
  latency(): UniffiDuration | undefined;
  /**
   * The number of times a connection has been successfully established
   */
  success(): /*u64*/ bigint;
  /**
   * Success rate
   */
  successRate(): /*f64*/ number;
}

export class RelayConnectionStats
  extends UniffiAbstractObject
  implements RelayConnectionStatsInterface
{
  readonly [uniffiTypeNameSymbol] = 'RelayConnectionStats';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRelayConnectionStatsObjectFactory.bless(pointer);
  }

  /**
   * The number of times a connection has been attempted
   */
  public attempts(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_attempts(
            uniffiTypeRelayConnectionStatsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Bytes received
   */
  public bytesReceived(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_bytes_received(
            uniffiTypeRelayConnectionStatsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Bytes sent
   */
  public bytesSent(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_bytes_sent(
            uniffiTypeRelayConnectionStatsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get UNIX timestamp of the last connection
   */
  public connectedAt(): TimestampInterface {
    return FfiConverterTypeTimestamp.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_connected_at(
            uniffiTypeRelayConnectionStatsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get UNIX timestamp of the first connection
   */
  public firstConnectionTimestamp(): TimestampInterface {
    return FfiConverterTypeTimestamp.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_first_connection_timestamp(
            uniffiTypeRelayConnectionStatsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public latency(): UniffiDuration | undefined {
    return FfiConverterOptionalDuration.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_latency(
            uniffiTypeRelayConnectionStatsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * The number of times a connection has been successfully established
   */
  public success(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_success(
            uniffiTypeRelayConnectionStatsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Success rate
   */
  public successRate(): /*f64*/ number {
    return FfiConverterFloat64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_success_rate(
            uniffiTypeRelayConnectionStatsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRelayConnectionStatsObjectFactory.pointer(this);
      uniffiTypeRelayConnectionStatsObjectFactory.freePointer(pointer);
      uniffiTypeRelayConnectionStatsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RelayConnectionStats {
    return uniffiTypeRelayConnectionStatsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRelayConnectionStatsObjectFactory: UniffiObjectFactory<RelayConnectionStatsInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): RelayConnectionStatsInterface {
      const instance = Object.create(RelayConnectionStats.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RelayConnectionStats';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_relayconnectionstats_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: RelayConnectionStatsInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RelayConnectionStatsInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_relayconnectionstats(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_relayconnectionstats(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RelayConnectionStatsInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RelayConnectionStats'
      );
    },
  };
// FfiConverter for RelayConnectionStatsInterface
const FfiConverterTypeRelayConnectionStats = new FfiConverterObject(
  uniffiTypeRelayConnectionStatsObjectFactory
);

export interface RelayInformationDocumentInterface {
  contact(): string | undefined;
  description(): string | undefined;
  fees(): FeeSchedules | undefined;
  icon(): string | undefined;
  languageTags(): Array<string>;
  limitation(): Limitation | undefined;
  name(): string | undefined;
  paymentsUrl(): string | undefined;
  postingPolicy(): string | undefined;
  pubkey(): string | undefined;
  relayCountries(): Array<string>;
  retention(): Array<Retention>;
  software(): string | undefined;
  supportedNips(): Array</*u16*/ number> | undefined;
  tags(): Array<string>;
  version(): string | undefined;
}

export class RelayInformationDocument
  extends UniffiAbstractObject
  implements RelayInformationDocumentInterface
{
  readonly [uniffiTypeNameSymbol] = 'RelayInformationDocument';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Create new empty [`RelayInformationDocument`]
   */
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_relayinformationdocument_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRelayInformationDocumentObjectFactory.bless(pointer);
  }

  public contact(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_contact(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public description(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_description(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public fees(): FeeSchedules | undefined {
    return FfiConverterOptionalTypeFeeSchedules.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_fees(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public icon(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_icon(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public languageTags(): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_language_tags(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public limitation(): Limitation | undefined {
    return FfiConverterOptionalTypeLimitation.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_limitation(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public name(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_name(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public paymentsUrl(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_payments_url(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public postingPolicy(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_posting_policy(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public pubkey(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_pubkey(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public relayCountries(): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_relay_countries(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public retention(): Array<Retention> {
    return FfiConverterArrayTypeRetention.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_retention(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public software(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_software(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public supportedNips(): Array</*u16*/ number> | undefined {
    return FfiConverterOptionalArrayUInt16.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_supported_nips(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public tags(): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_tags(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public version(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_version(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `RelayInformationDocumentInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_uniffi_trait_debug(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `RelayInformationDocumentInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `RelayInformationDocumentInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `RelayInformationDocumentInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: RelayInformationDocument): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_uniffi_trait_eq_eq(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            FfiConverterTypeRelayInformationDocument.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `RelayInformationDocumentInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_uniffi_trait_hash(
            uniffiTypeRelayInformationDocumentObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeRelayInformationDocumentObjectFactory.pointer(this);
      uniffiTypeRelayInformationDocumentObjectFactory.freePointer(pointer);
      uniffiTypeRelayInformationDocumentObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RelayInformationDocument {
    return uniffiTypeRelayInformationDocumentObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRelayInformationDocumentObjectFactory: UniffiObjectFactory<RelayInformationDocumentInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): RelayInformationDocumentInterface {
      const instance = Object.create(RelayInformationDocument.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RelayInformationDocument';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_relayinformationdocument_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: RelayInformationDocumentInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: RelayInformationDocumentInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_relayinformationdocument(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_relayinformationdocument(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RelayInformationDocumentInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RelayInformationDocument'
      );
    },
  };
// FfiConverter for RelayInformationDocumentInterface
const FfiConverterTypeRelayInformationDocument = new FfiConverterObject(
  uniffiTypeRelayInformationDocumentObjectFactory
);

/**
 * Relay Limits
 */
export interface RelayLimitsInterface {
  /**
   * Maximum number of tags allowed (default: 2_000)
   */
  eventMaxNumTags(maxNumTags: /*u16*/ number | undefined): RelayLimitsInterface;
  /**
   * Maximum number of tags allowed per kind
   */
  eventMaxNumTagsPerKind(
    kind: KindInterface,
    maxNumTags: /*u16*/ number | undefined
  ): RelayLimitsInterface;
  /**
   * Maximum size of normalised JSON, in bytes (default: 70_000)
   */
  eventMaxSize(maxSize: /*u32*/ number | undefined): RelayLimitsInterface;
  /**
   * Maximum size per kind of normalised JSON, in bytes.
   */
  eventMaxSizePerKind(
    kind: KindInterface,
    maxSize: /*u32*/ number | undefined
  ): RelayLimitsInterface;
  /**
   * Maximum size of normalized JSON, in bytes (default: 5MB)
   */
  messageMaxSize(maxSize: /*u32*/ number | undefined): RelayLimitsInterface;
}

/**
 * Relay Limits
 */
export class RelayLimits
  extends UniffiAbstractObject
  implements RelayLimitsInterface
{
  readonly [uniffiTypeNameSymbol] = 'RelayLimits';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Construct with default limits
   */
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_relaylimits_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRelayLimitsObjectFactory.bless(pointer);
  }

  /**
   * Disable all limits
   */
  public static disable(): RelayLimitsInterface {
    return FfiConverterTypeRelayLimits.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_relaylimits_disable(
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Maximum number of tags allowed (default: 2_000)
   */
  public eventMaxNumTags(
    maxNumTags: /*u16*/ number | undefined
  ): RelayLimitsInterface {
    return FfiConverterTypeRelayLimits.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_num_tags(
            uniffiTypeRelayLimitsObjectFactory.clonePointer(this),
            FfiConverterOptionalUInt16.lower(maxNumTags),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Maximum number of tags allowed per kind
   */
  public eventMaxNumTagsPerKind(
    kind: KindInterface,
    maxNumTags: /*u16*/ number | undefined
  ): RelayLimitsInterface {
    return FfiConverterTypeRelayLimits.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_num_tags_per_kind(
            uniffiTypeRelayLimitsObjectFactory.clonePointer(this),
            FfiConverterTypeKind.lower(kind),
            FfiConverterOptionalUInt16.lower(maxNumTags),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Maximum size of normalised JSON, in bytes (default: 70_000)
   */
  public eventMaxSize(
    maxSize: /*u32*/ number | undefined
  ): RelayLimitsInterface {
    return FfiConverterTypeRelayLimits.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_size(
            uniffiTypeRelayLimitsObjectFactory.clonePointer(this),
            FfiConverterOptionalUInt32.lower(maxSize),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Maximum size per kind of normalised JSON, in bytes.
   */
  public eventMaxSizePerKind(
    kind: KindInterface,
    maxSize: /*u32*/ number | undefined
  ): RelayLimitsInterface {
    return FfiConverterTypeRelayLimits.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_size_per_kind(
            uniffiTypeRelayLimitsObjectFactory.clonePointer(this),
            FfiConverterTypeKind.lower(kind),
            FfiConverterOptionalUInt32.lower(maxSize),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Maximum size of normalized JSON, in bytes (default: 5MB)
   */
  public messageMaxSize(
    maxSize: /*u32*/ number | undefined
  ): RelayLimitsInterface {
    return FfiConverterTypeRelayLimits.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relaylimits_message_max_size(
            uniffiTypeRelayLimitsObjectFactory.clonePointer(this),
            FfiConverterOptionalUInt32.lower(maxSize),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `RelayLimitsInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_debug(
            uniffiTypeRelayLimitsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `RelayLimitsInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `RelayLimitsInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `RelayLimitsInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: RelayLimits): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_eq_eq(
            uniffiTypeRelayLimitsObjectFactory.clonePointer(this),
            FfiConverterTypeRelayLimits.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRelayLimitsObjectFactory.pointer(this);
      uniffiTypeRelayLimitsObjectFactory.freePointer(pointer);
      uniffiTypeRelayLimitsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RelayLimits {
    return uniffiTypeRelayLimitsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRelayLimitsObjectFactory: UniffiObjectFactory<RelayLimitsInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): RelayLimitsInterface {
      const instance = Object.create(RelayLimits.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RelayLimits';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_relaylimits_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: RelayLimitsInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RelayLimitsInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_relaylimits(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_relaylimits(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RelayLimitsInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RelayLimits'
      );
    },
  };
// FfiConverter for RelayLimitsInterface
const FfiConverterTypeRelayLimits = new FfiConverterObject(
  uniffiTypeRelayLimitsObjectFactory
);

export interface RelayMessageInterface {
  /**
   * Clone `RelayMessage` and convert it to `RelayMessageEnum`
   */
  asEnum(): RelayMessageEnum;
  asJson() /*throws*/ : string;
}

export class RelayMessage
  extends UniffiAbstractObject
  implements RelayMessageInterface
{
  readonly [uniffiTypeNameSymbol] = 'RelayMessage';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRelayMessageObjectFactory.bless(pointer);
  }

  /**
   * Create new `AUTH` message
   */
  public static auth(challenge: string): RelayMessageInterface {
    return FfiConverterTypeRelayMessage.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_auth(
            FfiConverterString.lower(challenge),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Create new `CLOSED` message
   */
  public static closed(
    subscriptionId: string,
    message: string
  ): RelayMessageInterface {
    return FfiConverterTypeRelayMessage.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_closed(
            FfiConverterString.lower(subscriptionId),
            FfiConverterString.lower(message),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Create new `EVENT` message
   */
  public static count(
    subscriptionId: string,
    count: /*f64*/ number
  ): RelayMessageInterface {
    return FfiConverterTypeRelayMessage.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_count(
            FfiConverterString.lower(subscriptionId),
            FfiConverterFloat64.lower(count),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Create new `EOSE` message
   */
  public static eose(subscriptionId: string): RelayMessageInterface {
    return FfiConverterTypeRelayMessage.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_eose(
            FfiConverterString.lower(subscriptionId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Create new `EVENT` message
   */
  public static event(
    subscriptionId: string,
    event: EventInterface
  ): RelayMessageInterface {
    return FfiConverterTypeRelayMessage.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_event(
            FfiConverterString.lower(subscriptionId),
            FfiConverterTypeEvent.lower(event),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Convert `RelayMessageEnum` to `RelayMessage`
   */
  public static fromEnum(e: RelayMessageEnum): RelayMessageInterface {
    return FfiConverterTypeRelayMessage.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_from_enum(
            FfiConverterTypeRelayMessageEnum.lower(e),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Deserialize `RelayMessage` from JSON string
   *
   * **This method NOT verify the event signature!**
   */
  public static fromJson(json: string): RelayMessageInterface /*throws*/ {
    return FfiConverterTypeRelayMessage.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_from_json(
            FfiConverterString.lower(json),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Create new `NOTICE` message
   */
  public static notice(message: string): RelayMessageInterface {
    return FfiConverterTypeRelayMessage.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_notice(
            FfiConverterString.lower(message),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Create new `OK` message
   */
  public static ok(
    eventId: EventIdInterface,
    status: boolean,
    message: string
  ): RelayMessageInterface {
    return FfiConverterTypeRelayMessage.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_ok(
            FfiConverterTypeEventId.lower(eventId),
            FfiConverterBool.lower(status),
            FfiConverterString.lower(message),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Clone `RelayMessage` and convert it to `RelayMessageEnum`
   */
  public asEnum(): RelayMessageEnum {
    return FfiConverterTypeRelayMessageEnum.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relaymessage_as_enum(
            uniffiTypeRelayMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asJson(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relaymessage_as_json(
            uniffiTypeRelayMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `RelayMessageInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relaymessage_uniffi_trait_debug(
            uniffiTypeRelayMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `RelayMessageInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `RelayMessageInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `RelayMessageInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: RelayMessage): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relaymessage_uniffi_trait_eq_eq(
            uniffiTypeRelayMessageObjectFactory.clonePointer(this),
            FfiConverterTypeRelayMessage.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `RelayMessageInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relaymessage_uniffi_trait_hash(
            uniffiTypeRelayMessageObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRelayMessageObjectFactory.pointer(this);
      uniffiTypeRelayMessageObjectFactory.freePointer(pointer);
      uniffiTypeRelayMessageObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RelayMessage {
    return uniffiTypeRelayMessageObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRelayMessageObjectFactory: UniffiObjectFactory<RelayMessageInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): RelayMessageInterface {
      const instance = Object.create(RelayMessage.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RelayMessage';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_relaymessage_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: RelayMessageInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RelayMessageInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_relaymessage(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_relaymessage(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RelayMessageInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RelayMessage'
      );
    },
  };
// FfiConverter for RelayMessageInterface
const FfiConverterTypeRelayMessage = new FfiConverterObject(
  uniffiTypeRelayMessageObjectFactory
);

/**
 * `Relay` options
 */
export interface RelayOptionsInterface {
  /**
   * Automatically adjust retry interval based on success/attempts (default: true)
   */
  adjustRetryInterval(adjustRetryInterval: boolean): RelayOptionsInterface;
  /**
   * Set connection mode
   */
  connectionMode(mode: ConnectionMode) /*throws*/ : RelayOptionsInterface;
  /**
   * Set custom limits
   */
  limits(limits: RelayLimitsInterface): RelayOptionsInterface;
  /**
   * Set max latency (default: None)
   *
   * Relay with an avg. latency greater that this value will be skipped.
   */
  maxAvgLatency(max: UniffiDuration | undefined): RelayOptionsInterface;
  /**
   * Set ping flag
   */
  ping(ping: boolean): RelayOptionsInterface;
  /**
   * Set read flag
   */
  read(read: boolean): RelayOptionsInterface;
  /**
   * Enable/disable auto reconnection (default: true)
   */
  reconnect(reconnect: boolean): RelayOptionsInterface;
  /**
   * Retry interval (default: 10 sec)
   *
   * Minimum allowed value is `5 secs`
   */
  retryInterval(interval: UniffiDuration): RelayOptionsInterface;
  /**
   * Set write flag
   */
  write(write: boolean): RelayOptionsInterface;
}

/**
 * `Relay` options
 */
export class RelayOptions
  extends UniffiAbstractObject
  implements RelayOptionsInterface
{
  readonly [uniffiTypeNameSymbol] = 'RelayOptions';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * New default relay options
   */
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_relayoptions_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRelayOptionsObjectFactory.bless(pointer);
  }

  /**
   * Automatically adjust retry interval based on success/attempts (default: true)
   */
  public adjustRetryInterval(
    adjustRetryInterval: boolean
  ): RelayOptionsInterface {
    return FfiConverterTypeRelayOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayoptions_adjust_retry_interval(
            uniffiTypeRelayOptionsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(adjustRetryInterval),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set connection mode
   */
  public connectionMode(
    mode: ConnectionMode
  ): RelayOptionsInterface /*throws*/ {
    return FfiConverterTypeRelayOptions.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayoptions_connection_mode(
            uniffiTypeRelayOptionsObjectFactory.clonePointer(this),
            FfiConverterTypeConnectionMode.lower(mode),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set custom limits
   */
  public limits(limits: RelayLimitsInterface): RelayOptionsInterface {
    return FfiConverterTypeRelayOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayoptions_limits(
            uniffiTypeRelayOptionsObjectFactory.clonePointer(this),
            FfiConverterTypeRelayLimits.lower(limits),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set max latency (default: None)
   *
   * Relay with an avg. latency greater that this value will be skipped.
   */
  public maxAvgLatency(max: UniffiDuration | undefined): RelayOptionsInterface {
    return FfiConverterTypeRelayOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayoptions_max_avg_latency(
            uniffiTypeRelayOptionsObjectFactory.clonePointer(this),
            FfiConverterOptionalDuration.lower(max),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set ping flag
   */
  public ping(ping: boolean): RelayOptionsInterface {
    return FfiConverterTypeRelayOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayoptions_ping(
            uniffiTypeRelayOptionsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(ping),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set read flag
   */
  public read(read: boolean): RelayOptionsInterface {
    return FfiConverterTypeRelayOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayoptions_read(
            uniffiTypeRelayOptionsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(read),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Enable/disable auto reconnection (default: true)
   */
  public reconnect(reconnect: boolean): RelayOptionsInterface {
    return FfiConverterTypeRelayOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayoptions_reconnect(
            uniffiTypeRelayOptionsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(reconnect),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Retry interval (default: 10 sec)
   *
   * Minimum allowed value is `5 secs`
   */
  public retryInterval(interval: UniffiDuration): RelayOptionsInterface {
    return FfiConverterTypeRelayOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayoptions_retry_interval(
            uniffiTypeRelayOptionsObjectFactory.clonePointer(this),
            FfiConverterDuration.lower(interval),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set write flag
   */
  public write(write: boolean): RelayOptionsInterface {
    return FfiConverterTypeRelayOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_relayoptions_write(
            uniffiTypeRelayOptionsObjectFactory.clonePointer(this),
            FfiConverterBool.lower(write),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRelayOptionsObjectFactory.pointer(this);
      uniffiTypeRelayOptionsObjectFactory.freePointer(pointer);
      uniffiTypeRelayOptionsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RelayOptions {
    return uniffiTypeRelayOptionsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRelayOptionsObjectFactory: UniffiObjectFactory<RelayOptionsInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): RelayOptionsInterface {
      const instance = Object.create(RelayOptions.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RelayOptions';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_relayoptions_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: RelayOptionsInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RelayOptionsInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_relayoptions(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_relayoptions(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RelayOptionsInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RelayOptions'
      );
    },
  };
// FfiConverter for RelayOptionsInterface
const FfiConverterTypeRelayOptions = new FfiConverterObject(
  uniffiTypeRelayOptionsObjectFactory
);

/**
 * NIP47 Request
 */
export interface RequestInterface {
  method(): Method;
  params(): RequestParams;
}

/**
 * NIP47 Request
 */
export class Request extends UniffiAbstractObject implements RequestInterface {
  readonly [uniffiTypeNameSymbol] = 'Request';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(method: Method, params: RequestParams) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_request_new(
          FfiConverterTypeMethod.lower(method),
          FfiConverterTypeRequestParams.lower(params),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeRequestObjectFactory.bless(pointer);
  }

  public static parse(json: string): RequestInterface /*throws*/ {
    return FfiConverterTypeRequest.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_request_parse(
            FfiConverterString.lower(json),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public method(): Method {
    return FfiConverterTypeMethod.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_request_method(
            uniffiTypeRequestObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public params(): RequestParams {
    return FfiConverterTypeRequestParams.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_request_params(
            uniffiTypeRequestObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `RequestInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_request_uniffi_trait_debug(
            uniffiTypeRequestObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `RequestInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `RequestInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `RequestInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: Request): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_request_uniffi_trait_eq_eq(
            uniffiTypeRequestObjectFactory.clonePointer(this),
            FfiConverterTypeRequest.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `RequestInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_request_uniffi_trait_hash(
            uniffiTypeRequestObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeRequestObjectFactory.pointer(this);
      uniffiTypeRequestObjectFactory.freePointer(pointer);
      uniffiTypeRequestObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Request {
    return uniffiTypeRequestObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRequestObjectFactory: UniffiObjectFactory<RequestInterface> = {
  create(pointer: UnsafeMutableRawPointer): RequestInterface {
    const instance = Object.create(Request.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Request';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_request_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: RequestInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: RequestInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_request(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_request(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is RequestInterface {
    return (
      obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Request'
    );
  },
};
// FfiConverter for RequestInterface
const FfiConverterTypeRequest = new FfiConverterObject(
  uniffiTypeRequestObjectFactory
);

/**
 * NIP47 Response
 */
export interface ResponseInterface {}

/**
 * NIP47 Response
 */
export class Response
  extends UniffiAbstractObject
  implements ResponseInterface
{
  readonly [uniffiTypeNameSymbol] = 'Response';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeResponseObjectFactory.bless(pointer);
  }

  /**
   * Calls into the `Debug` string representation of `ResponseInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_response_uniffi_trait_debug(
            uniffiTypeResponseObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `ResponseInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `ResponseInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `ResponseInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: Response): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_response_uniffi_trait_eq_eq(
            uniffiTypeResponseObjectFactory.clonePointer(this),
            FfiConverterTypeResponse.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeResponseObjectFactory.pointer(this);
      uniffiTypeResponseObjectFactory.freePointer(pointer);
      uniffiTypeResponseObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Response {
    return uniffiTypeResponseObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeResponseObjectFactory: UniffiObjectFactory<ResponseInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): ResponseInterface {
      const instance = Object.create(Response.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'Response';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_response_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: ResponseInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: ResponseInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_response(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_response(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is ResponseInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Response'
      );
    },
  };
// FfiConverter for ResponseInterface
const FfiConverterTypeResponse = new FfiConverterObject(
  uniffiTypeResponseObjectFactory
);

export interface SecretKeyInterface {
  /**
   * Encrypt `SecretKey`
   *
   * By default, `LOG_N` is set to `16` and `KeySecurity` to `Unknown`.
   * To use custom values check `EncryptedSecretKey` constructor.
   */
  encrypt(password: string) /*throws*/ : EncryptedSecretKeyInterface;
  toBech32() /*throws*/ : string;
  toHex(): string;
}

export class SecretKey
  extends UniffiAbstractObject
  implements SecretKeyInterface
{
  readonly [uniffiTypeNameSymbol] = 'SecretKey';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSecretKeyObjectFactory.bless(pointer);
  }

  public static fromBytes(bytes: ArrayBuffer): SecretKeyInterface /*throws*/ {
    return FfiConverterTypeSecretKey.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_secretkey_from_bytes(
            FfiConverterArrayBuffer.lower(bytes),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Generate random secret key
   */
  public static generate(): SecretKeyInterface {
    return FfiConverterTypeSecretKey.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_secretkey_generate(
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Try to parse secret key from `hex` or `bech32`
   */
  public static parse(secretKey: string): SecretKeyInterface /*throws*/ {
    return FfiConverterTypeSecretKey.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_secretkey_parse(
            FfiConverterString.lower(secretKey),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Encrypt `SecretKey`
   *
   * By default, `LOG_N` is set to `16` and `KeySecurity` to `Unknown`.
   * To use custom values check `EncryptedSecretKey` constructor.
   */
  public encrypt(password: string): EncryptedSecretKeyInterface /*throws*/ {
    return FfiConverterTypeEncryptedSecretKey.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_secretkey_encrypt(
            uniffiTypeSecretKeyObjectFactory.clonePointer(this),
            FfiConverterString.lower(password),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toBech32(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_secretkey_to_bech32(
            uniffiTypeSecretKeyObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toHex(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_secretkey_to_hex(
            uniffiTypeSecretKeyObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `SecretKeyInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_secretkey_uniffi_trait_debug(
            uniffiTypeSecretKeyObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `SecretKeyInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `SecretKeyInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `SecretKeyInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: SecretKey): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_secretkey_uniffi_trait_eq_eq(
            uniffiTypeSecretKeyObjectFactory.clonePointer(this),
            FfiConverterTypeSecretKey.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSecretKeyObjectFactory.pointer(this);
      uniffiTypeSecretKeyObjectFactory.freePointer(pointer);
      uniffiTypeSecretKeyObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SecretKey {
    return uniffiTypeSecretKeyObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSecretKeyObjectFactory: UniffiObjectFactory<SecretKeyInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): SecretKeyInterface {
      const instance = Object.create(SecretKey.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SecretKey';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_secretkey_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SecretKeyInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: SecretKeyInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_secretkey(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_secretkey(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SecretKeyInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'SecretKey'
      );
    },
  };
// FfiConverter for SecretKeyInterface
const FfiConverterTypeSecretKey = new FfiConverterObject(
  uniffiTypeSecretKeyObjectFactory
);

export interface ServerConfigInterface {}

export class ServerConfig
  extends UniffiAbstractObject
  implements ServerConfigInterface
{
  readonly [uniffiTypeNameSymbol] = 'ServerConfig';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeServerConfigObjectFactory.bless(pointer);
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeServerConfigObjectFactory.pointer(this);
      uniffiTypeServerConfigObjectFactory.freePointer(pointer);
      uniffiTypeServerConfigObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is ServerConfig {
    return uniffiTypeServerConfigObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeServerConfigObjectFactory: UniffiObjectFactory<ServerConfigInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): ServerConfigInterface {
      const instance = Object.create(ServerConfig.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'ServerConfig';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_serverconfig_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: ServerConfigInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: ServerConfigInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_serverconfig(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_serverconfig(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is ServerConfigInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'ServerConfig'
      );
    },
  };
// FfiConverter for ServerConfigInterface
const FfiConverterTypeServerConfig = new FfiConverterObject(
  uniffiTypeServerConfigObjectFactory
);

export interface ShippingMethodInterface {
  /**
   * Get the product shipping cost of the shipping method
   */
  getShippingCost(): ShippingCost;
  /**
   * Set the name of the shipping method
   */
  name(name: string): ShippingMethodInterface;
  /**
   * Add a region to the shipping method
   */
  regions(regions: Array<string>): ShippingMethodInterface;
}

export class ShippingMethod
  extends UniffiAbstractObject
  implements ShippingMethodInterface
{
  readonly [uniffiTypeNameSymbol] = 'ShippingMethod';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Create a new shipping method
   */
  constructor(id: string, cost: /*f64*/ number) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_shippingmethod_new(
          FfiConverterString.lower(id),
          FfiConverterFloat64.lower(cost),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeShippingMethodObjectFactory.bless(pointer);
  }

  /**
   * Get the product shipping cost of the shipping method
   */
  public getShippingCost(): ShippingCost {
    return FfiConverterTypeShippingCost.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_shippingmethod_get_shipping_cost(
            uniffiTypeShippingMethodObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set the name of the shipping method
   */
  public name(name: string): ShippingMethodInterface {
    return FfiConverterTypeShippingMethod.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_shippingmethod_name(
            uniffiTypeShippingMethodObjectFactory.clonePointer(this),
            FfiConverterString.lower(name),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add a region to the shipping method
   */
  public regions(regions: Array<string>): ShippingMethodInterface {
    return FfiConverterTypeShippingMethod.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_shippingmethod_regions(
            uniffiTypeShippingMethodObjectFactory.clonePointer(this),
            FfiConverterArrayString.lower(regions),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeShippingMethodObjectFactory.pointer(this);
      uniffiTypeShippingMethodObjectFactory.freePointer(pointer);
      uniffiTypeShippingMethodObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is ShippingMethod {
    return uniffiTypeShippingMethodObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeShippingMethodObjectFactory: UniffiObjectFactory<ShippingMethodInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): ShippingMethodInterface {
      const instance = Object.create(ShippingMethod.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'ShippingMethod';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_shippingmethod_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: ShippingMethodInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: ShippingMethodInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_shippingmethod(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_shippingmethod(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is ShippingMethodInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'ShippingMethod'
      );
    },
  };
// FfiConverter for ShippingMethodInterface
const FfiConverterTypeShippingMethod = new FfiConverterObject(
  uniffiTypeShippingMethodObjectFactory
);

export interface SingleLetterTagInterface {
  isLowercase(): boolean;
  isUppercase(): boolean;
}

export class SingleLetterTag
  extends UniffiAbstractObject
  implements SingleLetterTagInterface
{
  readonly [uniffiTypeNameSymbol] = 'SingleLetterTag';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSingleLetterTagObjectFactory.bless(pointer);
  }

  public static lowercase(character: Alphabet): SingleLetterTagInterface {
    return FfiConverterTypeSingleLetterTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_singlelettertag_lowercase(
            FfiConverterTypeAlphabet.lower(character),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public static uppercase(character: Alphabet): SingleLetterTagInterface {
    return FfiConverterTypeSingleLetterTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_singlelettertag_uppercase(
            FfiConverterTypeAlphabet.lower(character),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public isLowercase(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_singlelettertag_is_lowercase(
            uniffiTypeSingleLetterTagObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public isUppercase(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_singlelettertag_is_uppercase(
            uniffiTypeSingleLetterTagObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `SingleLetterTagInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_singlelettertag_uniffi_trait_debug(
            uniffiTypeSingleLetterTagObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `SingleLetterTagInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `SingleLetterTagInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `SingleLetterTagInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: SingleLetterTag): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_singlelettertag_uniffi_trait_eq_eq(
            uniffiTypeSingleLetterTagObjectFactory.clonePointer(this),
            FfiConverterTypeSingleLetterTag.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `SingleLetterTagInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_singlelettertag_uniffi_trait_hash(
            uniffiTypeSingleLetterTagObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSingleLetterTagObjectFactory.pointer(this);
      uniffiTypeSingleLetterTagObjectFactory.freePointer(pointer);
      uniffiTypeSingleLetterTagObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SingleLetterTag {
    return uniffiTypeSingleLetterTagObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSingleLetterTagObjectFactory: UniffiObjectFactory<SingleLetterTagInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): SingleLetterTagInterface {
      const instance = Object.create(SingleLetterTag.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SingleLetterTag';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_singlelettertag_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SingleLetterTagInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: SingleLetterTagInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_singlelettertag(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_singlelettertag(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SingleLetterTagInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'SingleLetterTag'
      );
    },
  };
// FfiConverter for SingleLetterTagInterface
const FfiConverterTypeSingleLetterTag = new FfiConverterObject(
  uniffiTypeSingleLetterTagObjectFactory
);

export interface StallDataInterface {
  asJson() /*throws*/ : string;
  asRecord(): StallDataRecord;
  currency(): string;
  description(): string | undefined;
  id(): string;
  name(): string;
  shipping(): Array<ShippingMethodInterface>;
}

export class StallData
  extends UniffiAbstractObject
  implements StallDataInterface
{
  readonly [uniffiTypeNameSymbol] = 'StallData';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(
    id: string,
    name: string,
    description: string | undefined,
    currency: string,
    shipping: Array<ShippingMethodInterface>
  ) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_stalldata_new(
          FfiConverterString.lower(id),
          FfiConverterString.lower(name),
          FfiConverterOptionalString.lower(description),
          FfiConverterString.lower(currency),
          FfiConverterArrayTypeShippingMethod.lower(shipping),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeStallDataObjectFactory.bless(pointer);
  }

  public static fromJson(json: string): StallDataInterface /*throws*/ {
    return FfiConverterTypeStallData.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_stalldata_from_json(
            FfiConverterString.lower(json),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public static fromRecord(r: StallDataRecord): StallDataInterface {
    return FfiConverterTypeStallData.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_stalldata_from_record(
            FfiConverterTypeStallDataRecord.lower(r),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asJson(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_stalldata_as_json(
            uniffiTypeStallDataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asRecord(): StallDataRecord {
    return FfiConverterTypeStallDataRecord.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_stalldata_as_record(
            uniffiTypeStallDataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public currency(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_stalldata_currency(
            uniffiTypeStallDataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public description(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_stalldata_description(
            uniffiTypeStallDataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public id(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_stalldata_id(
            uniffiTypeStallDataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public name(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_stalldata_name(
            uniffiTypeStallDataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public shipping(): Array<ShippingMethodInterface> {
    return FfiConverterArrayTypeShippingMethod.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_stalldata_shipping(
            uniffiTypeStallDataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeStallDataObjectFactory.pointer(this);
      uniffiTypeStallDataObjectFactory.freePointer(pointer);
      uniffiTypeStallDataObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is StallData {
    return uniffiTypeStallDataObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeStallDataObjectFactory: UniffiObjectFactory<StallDataInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): StallDataInterface {
      const instance = Object.create(StallData.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'StallData';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_stalldata_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: StallDataInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: StallDataInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_stalldata(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_stalldata(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is StallDataInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'StallData'
      );
    },
  };
// FfiConverter for StallDataInterface
const FfiConverterTypeStallData = new FfiConverterObject(
  uniffiTypeStallDataObjectFactory
);

/**
 * Auto-closing subscribe options
 */
export interface SubscribeAutoCloseOptionsInterface {
  /**
   * Close subscription when the policy is satisfied
   */
  exitPolicy(policy: ReqExitPolicy): SubscribeAutoCloseOptionsInterface;
  /**
   * Automatically close subscription if no notifications/events are received within the duration.
   */
  idleTimeout(
    timeout: UniffiDuration | undefined
  ): SubscribeAutoCloseOptionsInterface;
  /**
   * Automatically close subscription after duration.
   */
  timeout(
    timeout: UniffiDuration | undefined
  ): SubscribeAutoCloseOptionsInterface;
}

/**
 * Auto-closing subscribe options
 */
export class SubscribeAutoCloseOptions
  extends UniffiAbstractObject
  implements SubscribeAutoCloseOptionsInterface
{
  readonly [uniffiTypeNameSymbol] = 'SubscribeAutoCloseOptions';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_subscribeautocloseoptions_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSubscribeAutoCloseOptionsObjectFactory.bless(pointer);
  }

  /**
   * Close subscription when the policy is satisfied
   */
  public exitPolicy(policy: ReqExitPolicy): SubscribeAutoCloseOptionsInterface {
    return FfiConverterTypeSubscribeAutoCloseOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_exit_policy(
            uniffiTypeSubscribeAutoCloseOptionsObjectFactory.clonePointer(this),
            FfiConverterTypeReqExitPolicy.lower(policy),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Automatically close subscription if no notifications/events are received within the duration.
   */
  public idleTimeout(
    timeout: UniffiDuration | undefined
  ): SubscribeAutoCloseOptionsInterface {
    return FfiConverterTypeSubscribeAutoCloseOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_idle_timeout(
            uniffiTypeSubscribeAutoCloseOptionsObjectFactory.clonePointer(this),
            FfiConverterOptionalDuration.lower(timeout),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Automatically close subscription after duration.
   */
  public timeout(
    timeout: UniffiDuration | undefined
  ): SubscribeAutoCloseOptionsInterface {
    return FfiConverterTypeSubscribeAutoCloseOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_timeout(
            uniffiTypeSubscribeAutoCloseOptionsObjectFactory.clonePointer(this),
            FfiConverterOptionalDuration.lower(timeout),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeSubscribeAutoCloseOptionsObjectFactory.pointer(this);
      uniffiTypeSubscribeAutoCloseOptionsObjectFactory.freePointer(pointer);
      uniffiTypeSubscribeAutoCloseOptionsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SubscribeAutoCloseOptions {
    return uniffiTypeSubscribeAutoCloseOptionsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSubscribeAutoCloseOptionsObjectFactory: UniffiObjectFactory<SubscribeAutoCloseOptionsInterface> =
  {
    create(
      pointer: UnsafeMutableRawPointer
    ): SubscribeAutoCloseOptionsInterface {
      const instance = Object.create(SubscribeAutoCloseOptions.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SubscribeAutoCloseOptions';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_subscribeautocloseoptions_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SubscribeAutoCloseOptionsInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: SubscribeAutoCloseOptionsInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_subscribeautocloseoptions(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_subscribeautocloseoptions(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SubscribeAutoCloseOptionsInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'SubscribeAutoCloseOptions'
      );
    },
  };
// FfiConverter for SubscribeAutoCloseOptionsInterface
const FfiConverterTypeSubscribeAutoCloseOptions = new FfiConverterObject(
  uniffiTypeSubscribeAutoCloseOptionsObjectFactory
);

/**
 * Subscribe options
 */
export interface SubscribeOptionsInterface {
  /**
   * Set auto-close conditions
   */
  closeOn(opts: SubscribeAutoCloseOptionsInterface): SubscribeOptionsInterface;
}

/**
 * Subscribe options
 */
export class SubscribeOptions
  extends UniffiAbstractObject
  implements SubscribeOptionsInterface
{
  readonly [uniffiTypeNameSymbol] = 'SubscribeOptions';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_subscribeoptions_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSubscribeOptionsObjectFactory.bless(pointer);
  }

  /**
   * Set auto-close conditions
   */
  public closeOn(
    opts: SubscribeAutoCloseOptionsInterface
  ): SubscribeOptionsInterface {
    return FfiConverterTypeSubscribeOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_subscribeoptions_close_on(
            uniffiTypeSubscribeOptionsObjectFactory.clonePointer(this),
            FfiConverterTypeSubscribeAutoCloseOptions.lower(opts),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSubscribeOptionsObjectFactory.pointer(this);
      uniffiTypeSubscribeOptionsObjectFactory.freePointer(pointer);
      uniffiTypeSubscribeOptionsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SubscribeOptions {
    return uniffiTypeSubscribeOptionsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSubscribeOptionsObjectFactory: UniffiObjectFactory<SubscribeOptionsInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): SubscribeOptionsInterface {
      const instance = Object.create(SubscribeOptions.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SubscribeOptions';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_subscribeoptions_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SubscribeOptionsInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: SubscribeOptionsInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_subscribeoptions(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_subscribeoptions(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SubscribeOptionsInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'SubscribeOptions'
      );
    },
  };
// FfiConverter for SubscribeOptionsInterface
const FfiConverterTypeSubscribeOptions = new FfiConverterObject(
  uniffiTypeSubscribeOptionsObjectFactory
);

export interface SyncOptionsInterface {
  /**
   * Sync Sync direction (default: down)
   */
  direction(direction: SyncDirection): SyncOptionsInterface;
  /**
   * Dry run
   *
   * Just check what event are missing: execute reconciliation but WITHOUT
   * getting/sending full events.
   */
  dryRun(): SyncOptionsInterface;
  /**
   * Timeout to check if negentropy it's supported (default: 10 secs)
   */
  initialTimeout(timeout: UniffiDuration): SyncOptionsInterface;
}

export class SyncOptions
  extends UniffiAbstractObject
  implements SyncOptionsInterface
{
  readonly [uniffiTypeNameSymbol] = 'SyncOptions';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * New default options
   */
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_syncoptions_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSyncOptionsObjectFactory.bless(pointer);
  }

  /**
   * Sync Sync direction (default: down)
   */
  public direction(direction: SyncDirection): SyncOptionsInterface {
    return FfiConverterTypeSyncOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_syncoptions_direction(
            uniffiTypeSyncOptionsObjectFactory.clonePointer(this),
            FfiConverterTypeSyncDirection.lower(direction),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Dry run
   *
   * Just check what event are missing: execute reconciliation but WITHOUT
   * getting/sending full events.
   */
  public dryRun(): SyncOptionsInterface {
    return FfiConverterTypeSyncOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_syncoptions_dry_run(
            uniffiTypeSyncOptionsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Timeout to check if negentropy it's supported (default: 10 secs)
   */
  public initialTimeout(timeout: UniffiDuration): SyncOptionsInterface {
    return FfiConverterTypeSyncOptions.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_syncoptions_initial_timeout(
            uniffiTypeSyncOptionsObjectFactory.clonePointer(this),
            FfiConverterDuration.lower(timeout),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSyncOptionsObjectFactory.pointer(this);
      uniffiTypeSyncOptionsObjectFactory.freePointer(pointer);
      uniffiTypeSyncOptionsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SyncOptions {
    return uniffiTypeSyncOptionsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSyncOptionsObjectFactory: UniffiObjectFactory<SyncOptionsInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): SyncOptionsInterface {
      const instance = Object.create(SyncOptions.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'SyncOptions';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_syncoptions_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SyncOptionsInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: SyncOptionsInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_syncoptions(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_syncoptions(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SyncOptionsInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'SyncOptions'
      );
    },
  };
// FfiConverter for SyncOptionsInterface
const FfiConverterTypeSyncOptions = new FfiConverterObject(
  uniffiTypeSyncOptionsObjectFactory
);

/**
 * Tag
 */
export interface TagInterface {
  /**
   * Get standardized tag
   */
  asStandardized(): TagStandard | undefined;
  /**
   * Get array of strings
   */
  asVec(): Array<string>;
  /**
   * Return the **first** tag value (index `1`), if exists.
   */
  content(): string | undefined;
  /**
   * Check if it's a protected event tag
   *
   * <https://github.com/nostr-protocol/nips/blob/master/70.md>
   */
  isProtected(): boolean;
  /**
   * Check if is a standard event tag with `reply` marker
   */
  isReply(): boolean;
  /**
   * Check if is a standard event tag with `root` marker
   */
  isRoot(): boolean;
  /**
   * Get tag kind
   */
  kind(): TagKind;
  /**
   * Get tag kind as string
   */
  kindStr(): string;
  /**
   * Get tag len
   */
  len(): /*u64*/ bigint;
  /**
   * Get `SingleLetterTag`
   */
  singleLetterTag(): SingleLetterTagInterface | undefined;
}

/**
 * Tag
 */
export class Tag extends UniffiAbstractObject implements TagInterface {
  readonly [uniffiTypeNameSymbol] = 'Tag';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeTagObjectFactory.bless(pointer);
  }

  /**
   * A short human-readable plaintext summary of what that event is about
   *
   * JSON: `["alt", "<summary>"]`
   *
   * <https://github.com/nostr-protocol/nips/blob/master/31.md>
   */
  public static alt(summary: string): TagInterface {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_alt(
            FfiConverterString.lower(summary),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Construct `["client", "<name>"]` tag
   *
   * <https://github.com/nostr-protocol/nips/blob/master/89.md>
   */
  public static client(name: string): TagInterface {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_client(
            FfiConverterString.lower(name),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Compose `["a", "<coordinate>"]` tag
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  public static coordinate(coordinate: CoordinateInterface): TagInterface {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_coordinate(
            FfiConverterTypeCoordinate.lower(coordinate),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Compose custom tag
   *
   * JSON: `["<kind>", "<value-1>", "<value-2>", ...]`
   */
  public static custom(kind: TagKind, values: Array<string>): TagInterface {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_custom(
            FfiConverterTypeTagKind.lower(kind),
            FfiConverterArrayString.lower(values),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Compose `["description", "<description>"]` tag
   */
  public static description(description: string): TagInterface {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_description(
            FfiConverterString.lower(description),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Compose `["e", "<event-id">]`
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  public static event(eventId: EventIdInterface): TagInterface {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_event(
            FfiConverterTypeEventId.lower(eventId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Compose `["e", "<event-id>", "<report>"]` tag
   *
   * <https://github.com/nostr-protocol/nips/blob/master/56.md>
   */
  public static eventReport(
    eventId: EventIdInterface,
    report: Report
  ): TagInterface {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_event_report(
            FfiConverterTypeEventId.lower(eventId),
            FfiConverterTypeReport.lower(report),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Compose `["expiration", "<timestamp>"]` tag
   *
   * <https://github.com/nostr-protocol/nips/blob/master/40.md>
   */
  public static expiration(timestamp: TimestampInterface): TagInterface {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_expiration(
            FfiConverterTypeTimestamp.lower(timestamp),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Construct from standardized tag
   */
  public static fromStandardized(
    standardized: TagStandard
  ): TagInterface /*throws*/ {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_from_standardized(
            FfiConverterTypeTagStandard.lower(standardized),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Compose `["t", "<hashtag>"]` tag
   *
   * This will convert the hashtag to lowercase.
   */
  public static hashtag(hashtag: string): TagInterface {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_hashtag(
            FfiConverterString.lower(hashtag),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Compose `["d", "<identifier>"]` tag
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  public static identifier(identifier: string): TagInterface {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_identifier(
            FfiConverterString.lower(identifier),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Compose image tag
   */
  public static image(
    url: string,
    dimensions: ImageDimensions | undefined = undefined
  ): TagInterface /*throws*/ {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_image(
            FfiConverterString.lower(url),
            FfiConverterOptionalTypeImageDimensions.lower(dimensions),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Parse tag
   *
   * Return error if the tag is empty!
   */
  public static parse(data: Array<string>): TagInterface /*throws*/ {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_parse(
            FfiConverterArrayString.lower(data),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Compose `["nonce", "<nonce>", "<difficulty>"]` tag
   *
   * <https://github.com/nostr-protocol/nips/blob/master/13.md>
   */
  public static pow(
    nonce: /*u64*/ bigint,
    difficulty: /*u8*/ number
  ): TagInterface {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_pow(
            FfiConverterUInt64.lower(nonce),
            FfiConverterUInt8.lower(difficulty),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Protected event
   *
   * JSON: `["-"]`
   *
   * <https://github.com/nostr-protocol/nips/blob/master/70.md>
   */
  public static protected_(): TagInterface {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_protected(
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Compose `["p", "<public-key>"]` tag
   *
   * <https://github.com/nostr-protocol/nips/blob/master/01.md>
   */
  public static publicKey(publicKey: PublicKeyInterface): TagInterface {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_public_key(
            FfiConverterTypePublicKey.lower(publicKey),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Compose `["p", "<public-key>", "<report>"]` tag
   *
   * <https://github.com/nostr-protocol/nips/blob/master/56.md>
   */
  public static publicKeyReport(
    publicKey: PublicKeyInterface,
    report: Report
  ): TagInterface {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_public_key_report(
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterTypeReport.lower(report),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Compose `["r", "<value>"]` tag
   */
  public static reference(reference: string): TagInterface {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_reference(
            FfiConverterString.lower(reference),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Compose `["r", "<relay-url>", "<metadata>"]` tag
   *
   * <https://github.com/nostr-protocol/nips/blob/master/65.md>
   */
  public static relayMetadata(
    relayUrl: string,
    metadata: RelayMetadata | undefined
  ): TagInterface /*throws*/ {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_relay_metadata(
            FfiConverterString.lower(relayUrl),
            FfiConverterOptionalTypeRelayMetadata.lower(metadata),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Compose `["title", "<title>"]` tag
   */
  public static title(title: string): TagInterface {
    return FfiConverterTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tag_title(
            FfiConverterString.lower(title),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get standardized tag
   */
  public asStandardized(): TagStandard | undefined {
    return FfiConverterOptionalTypeTagStandard.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tag_as_standardized(
            uniffiTypeTagObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get array of strings
   */
  public asVec(): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tag_as_vec(
            uniffiTypeTagObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Return the **first** tag value (index `1`), if exists.
   */
  public content(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tag_content(
            uniffiTypeTagObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Check if it's a protected event tag
   *
   * <https://github.com/nostr-protocol/nips/blob/master/70.md>
   */
  public isProtected(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tag_is_protected(
            uniffiTypeTagObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Check if is a standard event tag with `reply` marker
   */
  public isReply(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tag_is_reply(
            uniffiTypeTagObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Check if is a standard event tag with `root` marker
   */
  public isRoot(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tag_is_root(
            uniffiTypeTagObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get tag kind
   */
  public kind(): TagKind {
    return FfiConverterTypeTagKind.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tag_kind(
            uniffiTypeTagObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get tag kind as string
   */
  public kindStr(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tag_kind_str(
            uniffiTypeTagObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get tag len
   */
  public len(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tag_len(
            uniffiTypeTagObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get `SingleLetterTag`
   */
  public singleLetterTag(): SingleLetterTagInterface | undefined {
    return FfiConverterOptionalTypeSingleLetterTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tag_single_letter_tag(
            uniffiTypeTagObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `TagInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tag_uniffi_trait_debug(
            uniffiTypeTagObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `TagInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `TagInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `TagInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: Tag): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tag_uniffi_trait_eq_eq(
            uniffiTypeTagObjectFactory.clonePointer(this),
            FfiConverterTypeTag.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `TagInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tag_uniffi_trait_hash(
            uniffiTypeTagObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeTagObjectFactory.pointer(this);
      uniffiTypeTagObjectFactory.freePointer(pointer);
      uniffiTypeTagObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Tag {
    return uniffiTypeTagObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeTagObjectFactory: UniffiObjectFactory<TagInterface> = {
  create(pointer: UnsafeMutableRawPointer): TagInterface {
    const instance = Object.create(Tag.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Tag';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_tag_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: TagInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: TagInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_tag(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_tag(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is TagInterface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Tag';
  },
};
// FfiConverter for TagInterface
const FfiConverterTypeTag = new FfiConverterObject(uniffiTypeTagObjectFactory);

export interface TagsInterface {
  /**
   * Extract coordinates from `a` tags.
   *
   * This method extract ONLY supported standard variants
   */
  coordinates(): Array<CoordinateInterface>;
  /**
   * Extract event IDs from `e` tags.
   *
   * This method extract ONLY supported standard variants
   */
  eventIds(): Array<EventIdInterface>;
  /**
   * Get timestamp expiration, if set
   */
  expiration(): TimestampInterface | undefined;
  /**
   * Get first tag that match `TagKind`.
   */
  filter(kind: TagKind): Array<TagInterface>;
  /**
   * Get first tag that match `TagKind` and that is standardized.
   */
  filterStandardized(kind: TagKind): Array<TagStandard>;
  /**
   * /// Get first tag that match `TagKind`.
   */
  find(kind: TagKind): TagInterface | undefined;
  /**
   * Get first tag that match `TagKind` and that is standardized.
   */
  findStandardized(kind: TagKind): TagStandard | undefined;
  /**
   * Get first tag
   */
  first(): TagInterface | undefined;
  /**
   * Get tag at index
   */
  get(index: /*u64*/ bigint): TagInterface | undefined;
  /**
   * Extract hashtags from `t` tags.
   *
   * This method extract ONLY supported standard variants
   */
  hashtags(): Array<string>;
  /**
   * Extract identifier (`d` tag), if exists.
   */
  identifier(): string | undefined;
  /**
   * Check if contains no tags.
   */
  isEmpty(): boolean;
  /**
   * Get last tag
   */
  last(): TagInterface | undefined;
  /**
   * Get number of tags
   */
  len(): /*u64*/ bigint;
  /**
   * Extract public keys from `p` tags.
   *
   * This method extract ONLY supported standard variants
   */
  publicKeys(): Array<PublicKeyInterface>;
  toVec(): Array<TagInterface>;
}

export class Tags extends UniffiAbstractObject implements TagsInterface {
  readonly [uniffiTypeNameSymbol] = 'Tags';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeTagsObjectFactory.bless(pointer);
  }

  public static fromList(list: Array<TagInterface>): TagsInterface {
    return FfiConverterTypeTags.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tags_from_list(
            FfiConverterArrayTypeTag.lower(list),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Extract `nostr:` URIs from a text and construct tags.
   *
   * This method deduplicates the tags.
   */
  public static fromText(text: string): TagsInterface {
    return FfiConverterTypeTags.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tags_from_text(
            FfiConverterString.lower(text),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public static parse(tags: Array<Array<string>>): TagsInterface /*throws*/ {
    return FfiConverterTypeTags.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_tags_parse(
            FfiConverterArrayArrayString.lower(tags),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Extract coordinates from `a` tags.
   *
   * This method extract ONLY supported standard variants
   */
  public coordinates(): Array<CoordinateInterface> {
    return FfiConverterArrayTypeCoordinate.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tags_coordinates(
            uniffiTypeTagsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Extract event IDs from `e` tags.
   *
   * This method extract ONLY supported standard variants
   */
  public eventIds(): Array<EventIdInterface> {
    return FfiConverterArrayTypeEventId.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tags_event_ids(
            uniffiTypeTagsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get timestamp expiration, if set
   */
  public expiration(): TimestampInterface | undefined {
    return FfiConverterOptionalTypeTimestamp.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tags_expiration(
            uniffiTypeTagsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get first tag that match `TagKind`.
   */
  public filter(kind: TagKind): Array<TagInterface> {
    return FfiConverterArrayTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tags_filter(
            uniffiTypeTagsObjectFactory.clonePointer(this),
            FfiConverterTypeTagKind.lower(kind),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get first tag that match `TagKind` and that is standardized.
   */
  public filterStandardized(kind: TagKind): Array<TagStandard> {
    return FfiConverterArrayTypeTagStandard.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tags_filter_standardized(
            uniffiTypeTagsObjectFactory.clonePointer(this),
            FfiConverterTypeTagKind.lower(kind),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * /// Get first tag that match `TagKind`.
   */
  public find(kind: TagKind): TagInterface | undefined {
    return FfiConverterOptionalTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tags_find(
            uniffiTypeTagsObjectFactory.clonePointer(this),
            FfiConverterTypeTagKind.lower(kind),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get first tag that match `TagKind` and that is standardized.
   */
  public findStandardized(kind: TagKind): TagStandard | undefined {
    return FfiConverterOptionalTypeTagStandard.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tags_find_standardized(
            uniffiTypeTagsObjectFactory.clonePointer(this),
            FfiConverterTypeTagKind.lower(kind),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get first tag
   */
  public first(): TagInterface | undefined {
    return FfiConverterOptionalTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tags_first(
            uniffiTypeTagsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get tag at index
   */
  public get(index: /*u64*/ bigint): TagInterface | undefined {
    return FfiConverterOptionalTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tags_get(
            uniffiTypeTagsObjectFactory.clonePointer(this),
            FfiConverterUInt64.lower(index),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Extract hashtags from `t` tags.
   *
   * This method extract ONLY supported standard variants
   */
  public hashtags(): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tags_hashtags(
            uniffiTypeTagsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Extract identifier (`d` tag), if exists.
   */
  public identifier(): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tags_identifier(
            uniffiTypeTagsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Check if contains no tags.
   */
  public isEmpty(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tags_is_empty(
            uniffiTypeTagsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get last tag
   */
  public last(): TagInterface | undefined {
    return FfiConverterOptionalTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tags_last(
            uniffiTypeTagsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get number of tags
   */
  public len(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tags_len(
            uniffiTypeTagsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Extract public keys from `p` tags.
   *
   * This method extract ONLY supported standard variants
   */
  public publicKeys(): Array<PublicKeyInterface> {
    return FfiConverterArrayTypePublicKey.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tags_public_keys(
            uniffiTypeTagsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toVec(): Array<TagInterface> {
    return FfiConverterArrayTypeTag.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_tags_to_vec(
            uniffiTypeTagsObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeTagsObjectFactory.pointer(this);
      uniffiTypeTagsObjectFactory.freePointer(pointer);
      uniffiTypeTagsObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Tags {
    return uniffiTypeTagsObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeTagsObjectFactory: UniffiObjectFactory<TagsInterface> = {
  create(pointer: UnsafeMutableRawPointer): TagsInterface {
    const instance = Object.create(Tags.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Tags';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_tags_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: TagsInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: TagsInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_tags(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_tags(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is TagsInterface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Tags';
  },
};
// FfiConverter for TagsInterface
const FfiConverterTypeTags = new FfiConverterObject(
  uniffiTypeTagsObjectFactory
);

export interface TimestampInterface {
  /**
   * Get timestamp as [`u64`]
   */
  asSecs(): /*u64*/ bigint;
  /**
   * Convert [`Timestamp`] to human datetime
   */
  toHumanDatetime(): string;
}

export class Timestamp
  extends UniffiAbstractObject
  implements TimestampInterface
{
  readonly [uniffiTypeNameSymbol] = 'Timestamp';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeTimestampObjectFactory.bless(pointer);
  }

  public static fromSecs(secs: /*u64*/ bigint): TimestampInterface {
    return FfiConverterTypeTimestamp.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_timestamp_from_secs(
            FfiConverterUInt64.lower(secs),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get UNIX timestamp
   */
  public static now(): TimestampInterface {
    return FfiConverterTypeTimestamp.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_timestamp_now(
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get timestamp as [`u64`]
   */
  public asSecs(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_timestamp_as_secs(
            uniffiTypeTimestampObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Convert [`Timestamp`] to human datetime
   */
  public toHumanDatetime(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_timestamp_to_human_datetime(
            uniffiTypeTimestampObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `TimestampInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_timestamp_uniffi_trait_debug(
            uniffiTypeTimestampObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `TimestampInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `TimestampInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `TimestampInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: Timestamp): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_timestamp_uniffi_trait_eq_eq(
            uniffiTypeTimestampObjectFactory.clonePointer(this),
            FfiConverterTypeTimestamp.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `TimestampInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_timestamp_uniffi_trait_hash(
            uniffiTypeTimestampObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeTimestampObjectFactory.pointer(this);
      uniffiTypeTimestampObjectFactory.freePointer(pointer);
      uniffiTypeTimestampObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Timestamp {
    return uniffiTypeTimestampObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeTimestampObjectFactory: UniffiObjectFactory<TimestampInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): TimestampInterface {
      const instance = Object.create(Timestamp.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'Timestamp';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_timestamp_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: TimestampInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: TimestampInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_timestamp(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_timestamp(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is TimestampInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Timestamp'
      );
    },
  };
// FfiConverter for TimestampInterface
const FfiConverterTypeTimestamp = new FfiConverterObject(
  uniffiTypeTimestampObjectFactory
);

export interface UnsignedEventInterface {
  /**
   * Add signature to unsigned event
   *
   * Internally verify the event.
   */
  addSignature(sig: string) /*throws*/ : EventInterface;
  asJson() /*throws*/ : string;
  asPrettyJson() /*throws*/ : string;
  author(): PublicKeyInterface;
  content(): string;
  createdAt(): TimestampInterface;
  id(): EventIdInterface | undefined;
  kind(): KindInterface;
  /**
   * Sign an unsigned event
   */
  sign(
    signer: NostrSignerInterface,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<EventInterface>;
  /**
   * Sign an unsigned event with keys signer
   *
   * Internally: calculate event ID (if not set), sign it, compose and verify event.
   */
  signWithKeys(keys: KeysInterface) /*throws*/ : EventInterface;
  tags(): TagsInterface;
}

export class UnsignedEvent
  extends UniffiAbstractObject
  implements UnsignedEventInterface
{
  readonly [uniffiTypeNameSymbol] = 'UnsignedEvent';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeUnsignedEventObjectFactory.bless(pointer);
  }

  public static fromJson(json: string): UnsignedEventInterface /*throws*/ {
    return FfiConverterTypeUnsignedEvent.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_unsignedevent_from_json(
            FfiConverterString.lower(json),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Add signature to unsigned event
   *
   * Internally verify the event.
   */
  public addSignature(sig: string): EventInterface /*throws*/ {
    return FfiConverterTypeEvent.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unsignedevent_add_signature(
            uniffiTypeUnsignedEventObjectFactory.clonePointer(this),
            FfiConverterString.lower(sig),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asJson(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unsignedevent_as_json(
            uniffiTypeUnsignedEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asPrettyJson(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unsignedevent_as_pretty_json(
            uniffiTypeUnsignedEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public author(): PublicKeyInterface {
    return FfiConverterTypePublicKey.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unsignedevent_author(
            uniffiTypeUnsignedEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public content(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unsignedevent_content(
            uniffiTypeUnsignedEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public createdAt(): TimestampInterface {
    return FfiConverterTypeTimestamp.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unsignedevent_created_at(
            uniffiTypeUnsignedEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public id(): EventIdInterface | undefined {
    return FfiConverterOptionalTypeEventId.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unsignedevent_id(
            uniffiTypeUnsignedEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public kind(): KindInterface {
    return FfiConverterTypeKind.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unsignedevent_kind(
            uniffiTypeUnsignedEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Sign an unsigned event
   */
  public async sign(
    signer: NostrSignerInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<EventInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unsignedevent_sign(
            uniffiTypeUnsignedEventObjectFactory.clonePointer(this),
            FfiConverterTypeNostrSigner.lower(signer)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeEvent.lift.bind(FfiConverterTypeEvent),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Sign an unsigned event with keys signer
   *
   * Internally: calculate event ID (if not set), sign it, compose and verify event.
   */
  public signWithKeys(keys: KeysInterface): EventInterface /*throws*/ {
    return FfiConverterTypeEvent.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unsignedevent_sign_with_keys(
            uniffiTypeUnsignedEventObjectFactory.clonePointer(this),
            FfiConverterTypeKeys.lower(keys),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public tags(): TagsInterface {
    return FfiConverterTypeTags.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unsignedevent_tags(
            uniffiTypeUnsignedEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `UnsignedEventInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unsignedevent_uniffi_trait_debug(
            uniffiTypeUnsignedEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `UnsignedEventInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `UnsignedEventInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `UnsignedEventInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: UnsignedEvent): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unsignedevent_uniffi_trait_eq_eq(
            uniffiTypeUnsignedEventObjectFactory.clonePointer(this),
            FfiConverterTypeUnsignedEvent.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `UnsignedEventInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unsignedevent_uniffi_trait_hash(
            uniffiTypeUnsignedEventObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeUnsignedEventObjectFactory.pointer(this);
      uniffiTypeUnsignedEventObjectFactory.freePointer(pointer);
      uniffiTypeUnsignedEventObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is UnsignedEvent {
    return uniffiTypeUnsignedEventObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeUnsignedEventObjectFactory: UniffiObjectFactory<UnsignedEventInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): UnsignedEventInterface {
      const instance = Object.create(UnsignedEvent.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'UnsignedEvent';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_unsignedevent_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: UnsignedEventInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: UnsignedEventInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_unsignedevent(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_unsignedevent(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is UnsignedEventInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'UnsignedEvent'
      );
    },
  };
// FfiConverter for UnsignedEventInterface
const FfiConverterTypeUnsignedEvent = new FfiConverterObject(
  uniffiTypeUnsignedEventObjectFactory
);

/**
 * Unwrapped Gift Wrap
 *
 * <https://github.com/nostr-protocol/nips/blob/master/59.md>
 */
export interface UnwrappedGiftInterface {
  none(asyncOpts_?: { signal: AbortSignal }): Promise<void>;
  /**
   * Get rumor
   */
  rumor(): UnsignedEventInterface;
  /**
   * Get sender public key
   */
  sender(): PublicKeyInterface;
}

/**
 * Unwrapped Gift Wrap
 *
 * <https://github.com/nostr-protocol/nips/blob/master/59.md>
 */
export class UnwrappedGift
  extends UniffiAbstractObject
  implements UnwrappedGiftInterface
{
  readonly [uniffiTypeNameSymbol] = 'UnwrappedGift';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeUnwrappedGiftObjectFactory.bless(pointer);
  }

  /**
   * Unwrap Gift Wrap event
   *
   * Internally verify the `seal` event
   */
  public static async fromGiftWrap(
    signer: NostrSignerInterface,
    giftWrap: EventInterface,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<UnwrappedGiftInterface> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_unwrappedgift_from_gift_wrap(
            FfiConverterTypeNostrSigner.lower(signer),
            FfiConverterTypeEvent.lower(giftWrap)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_pointer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_pointer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_pointer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_pointer,
        /*liftFunc:*/ FfiConverterTypeUnwrappedGift.lift.bind(
          FfiConverterTypeUnwrappedGift
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  public async none(asyncOpts_?: { signal: AbortSignal }): Promise<void> {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unwrappedgift__none(
            uniffiTypeUnwrappedGiftObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Get rumor
   */
  public rumor(): UnsignedEventInterface {
    return FfiConverterTypeUnsignedEvent.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_rumor(
            uniffiTypeUnwrappedGiftObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get sender public key
   */
  public sender(): PublicKeyInterface {
    return FfiConverterTypePublicKey.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_sender(
            uniffiTypeUnwrappedGiftObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `UnwrappedGiftInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_uniffi_trait_debug(
            uniffiTypeUnwrappedGiftObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `UnwrappedGiftInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `UnwrappedGiftInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `UnwrappedGiftInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: UnwrappedGift): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_uniffi_trait_eq_eq(
            uniffiTypeUnwrappedGiftObjectFactory.clonePointer(this),
            FfiConverterTypeUnwrappedGift.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `UnwrappedGiftInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_uniffi_trait_hash(
            uniffiTypeUnwrappedGiftObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeUnwrappedGiftObjectFactory.pointer(this);
      uniffiTypeUnwrappedGiftObjectFactory.freePointer(pointer);
      uniffiTypeUnwrappedGiftObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is UnwrappedGift {
    return uniffiTypeUnwrappedGiftObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeUnwrappedGiftObjectFactory: UniffiObjectFactory<UnwrappedGiftInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): UnwrappedGiftInterface {
      const instance = Object.create(UnwrappedGift.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'UnwrappedGift';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_unwrappedgift_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: UnwrappedGiftInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: UnwrappedGiftInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_unwrappedgift(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_unwrappedgift(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is UnwrappedGiftInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'UnwrappedGift'
      );
    },
  };
// FfiConverter for UnwrappedGiftInterface
const FfiConverterTypeUnwrappedGift = new FfiConverterObject(
  uniffiTypeUnwrappedGiftObjectFactory
);

export interface WebSocketAdapter {
  /**
   * Send a WebSocket message
   */
  send(
    msg: WebSocketMessage,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<void>;
  /**
   * Receive a message
   *
   * This method MUST await for a message.
   *
   * Return `None` to mark the stream as terminated.
   */
  recv(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<WebSocketMessage | undefined>;
  /**
   * Close the WebSocket connection
   */
  closeConnection(asyncOpts_?: {
    signal: AbortSignal;
  }) /*throws*/ : Promise<void>;
}

export class WebSocketAdapterImpl
  extends UniffiAbstractObject
  implements WebSocketAdapter
{
  readonly [uniffiTypeNameSymbol] = 'WebSocketAdapterImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeWebSocketAdapterImplObjectFactory.bless(pointer);
  }

  /**
   * Send a WebSocket message
   */
  public async send(
    msg: WebSocketMessage,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_websocketadapter_send(
            uniffiTypeWebSocketAdapterImplObjectFactory.clonePointer(this),
            FfiConverterTypeWebSocketMessage.lower(msg)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Receive a message
   *
   * This method MUST await for a message.
   *
   * Return `None` to mark the stream as terminated.
   */
  public async recv(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<WebSocketMessage | undefined> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_websocketadapter_recv(
            uniffiTypeWebSocketAdapterImplObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterOptionalTypeWebSocketMessage.lift.bind(
          FfiConverterOptionalTypeWebSocketMessage
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * Close the WebSocket connection
   */
  public async closeConnection(asyncOpts_?: {
    signal: AbortSignal;
  }): Promise<void> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_websocketadapter_close_connection(
            uniffiTypeWebSocketAdapterImplObjectFactory.clonePointer(this)
          );
        },
        /*pollFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_poll_void,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_cancel_void,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_complete_void,
        /*freeFunc:*/ nativeModule()
          .ubrn_ffi_nostr_sdk_ffi_rust_future_free_void,
        /*liftFunc:*/ (_v) => {},
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypeNostrSdkError.lift.bind(
          FfiConverterTypeNostrSdkError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeWebSocketAdapterImplObjectFactory.pointer(this);
      uniffiTypeWebSocketAdapterImplObjectFactory.freePointer(pointer);
      uniffiTypeWebSocketAdapterImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is WebSocketAdapterImpl {
    return uniffiTypeWebSocketAdapterImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeWebSocketAdapterImplObjectFactory: UniffiObjectFactory<WebSocketAdapter> =
  {
    create(pointer: UnsafeMutableRawPointer): WebSocketAdapter {
      const instance = Object.create(WebSocketAdapterImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'WebSocketAdapterImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_websocketadapter_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: WebSocketAdapter): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: WebSocketAdapter): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_websocketadapter(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_websocketadapter(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is WebSocketAdapter {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'WebSocketAdapterImpl'
      );
    },
  };
// FfiConverter for WebSocketAdapter
const FfiConverterTypeWebSocketAdapter = new FfiConverterObjectWithCallbacks(
  uniffiTypeWebSocketAdapterImplObjectFactory
);

// Add a vtavble for the callbacks that go in WebSocketAdapter.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceWebSocketAdapter: {
  vtable: UniffiVTableCallbackInterfaceWebSocketAdapter;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    send: (
      uniffiHandle: bigint,
      msg: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeWebSocketAdapter.lift(uniffiHandle);
        return await jsCallback.send(
          FfiConverterTypeWebSocketMessage.lift(msg),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ NostrSdkError.instanceOf,
        /*lowerError:*/ FfiConverterTypeNostrSdkError.lower.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    recv: (
      uniffiHandle: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<WebSocketMessage | undefined> => {
        const jsCallback = FfiConverterTypeWebSocketAdapter.lift(uniffiHandle);
        return await jsCallback.recv({ signal });
      };
      const uniffiHandleSuccess = (
        returnValue: WebSocketMessage | undefined
      ) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue:
              FfiConverterOptionalTypeWebSocketMessage.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ NostrSdkError.instanceOf,
        /*lowerError:*/ FfiConverterTypeNostrSdkError.lower.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    closeConnection: (
      uniffiHandle: bigint,
      uniffiFutureCallback: UniffiForeignFutureCompleteVoid,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (signal: AbortSignal): Promise<void> => {
        const jsCallback = FfiConverterTypeWebSocketAdapter.lift(uniffiHandle);
        return await jsCallback.closeConnection({ signal });
      };
      const uniffiHandleSuccess = (returnValue: void) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructVoid */ {
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ NostrSdkError.instanceOf,
        /*lowerError:*/ FfiConverterTypeNostrSdkError.lower.bind(
          FfiConverterTypeNostrSdkError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // WebSocketAdapter: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeWebSocketAdapter.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_init_callback_vtable_websocketadapter(
      uniffiCallbackInterfaceWebSocketAdapter.vtable
    );
  },
};

export interface WebSocketAdapterWrapperInterface {}

export class WebSocketAdapterWrapper
  extends UniffiAbstractObject
  implements WebSocketAdapterWrapperInterface
{
  readonly [uniffiTypeNameSymbol] = 'WebSocketAdapterWrapper';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(adapter: WebSocketAdapter) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_websocketadapterwrapper_new(
          FfiConverterTypeWebSocketAdapter.lower(adapter),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeWebSocketAdapterWrapperObjectFactory.bless(pointer);
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeWebSocketAdapterWrapperObjectFactory.pointer(this);
      uniffiTypeWebSocketAdapterWrapperObjectFactory.freePointer(pointer);
      uniffiTypeWebSocketAdapterWrapperObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is WebSocketAdapterWrapper {
    return uniffiTypeWebSocketAdapterWrapperObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeWebSocketAdapterWrapperObjectFactory: UniffiObjectFactory<WebSocketAdapterWrapperInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): WebSocketAdapterWrapperInterface {
      const instance = Object.create(WebSocketAdapterWrapper.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'WebSocketAdapterWrapper';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_websocketadapterwrapper_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: WebSocketAdapterWrapperInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(
      obj: WebSocketAdapterWrapperInterface
    ): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_websocketadapterwrapper(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_websocketadapterwrapper(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is WebSocketAdapterWrapperInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'WebSocketAdapterWrapper'
      );
    },
  };
// FfiConverter for WebSocketAdapterWrapperInterface
const FfiConverterTypeWebSocketAdapterWrapper = new FfiConverterObject(
  uniffiTypeWebSocketAdapterWrapperObjectFactory
);

export interface ZapRequestDataInterface {
  amount(amount: /*u64*/ bigint): ZapRequestDataInterface;
  eventId(eventId: EventIdInterface): ZapRequestDataInterface;
  lnurl(lnurl: string): ZapRequestDataInterface;
  message(message: string): ZapRequestDataInterface;
}

export class ZapRequestData
  extends UniffiAbstractObject
  implements ZapRequestDataInterface
{
  readonly [uniffiTypeNameSymbol] = 'ZapRequestData';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(publicKey: PublicKeyInterface, relays: Array<string>) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_constructor_zaprequestdata_new(
          FfiConverterTypePublicKey.lower(publicKey),
          FfiConverterArrayString.lower(relays),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeZapRequestDataObjectFactory.bless(pointer);
  }

  public amount(amount: /*u64*/ bigint): ZapRequestDataInterface {
    return FfiConverterTypeZapRequestData.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_amount(
            uniffiTypeZapRequestDataObjectFactory.clonePointer(this),
            FfiConverterUInt64.lower(amount),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public eventId(eventId: EventIdInterface): ZapRequestDataInterface {
    return FfiConverterTypeZapRequestData.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_event_id(
            uniffiTypeZapRequestDataObjectFactory.clonePointer(this),
            FfiConverterTypeEventId.lower(eventId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public lnurl(lnurl: string): ZapRequestDataInterface {
    return FfiConverterTypeZapRequestData.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_lnurl(
            uniffiTypeZapRequestDataObjectFactory.clonePointer(this),
            FfiConverterString.lower(lnurl),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public message(message: string): ZapRequestDataInterface {
    return FfiConverterTypeZapRequestData.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_message(
            uniffiTypeZapRequestDataObjectFactory.clonePointer(this),
            FfiConverterString.lower(message),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `ZapRequestDataInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust.
   */
  toDebugString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_uniffi_trait_debug(
            uniffiTypeZapRequestDataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `Debug` string representation of `ZapRequestDataInterface` (the native Rust peer).
   *
   * Generated by deriving the `Debug` trait in Rust, without deriving `Display`.
   */
  toString(): string {
    return this.toDebugString();
  }

  /**
   * Calls into the `==` method of `ZapRequestDataInterface` (the native Rust peer).
   *
   * Returns `true` if and only if the two instance of `ZapRequestDataInterface` are
   * equivalent on the Rust side.
   *
   * Generated by deriving the `Eq` trait in Rust.
   */
  equals(other: ZapRequestData): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_uniffi_trait_eq_eq(
            uniffiTypeZapRequestDataObjectFactory.clonePointer(this),
            FfiConverterTypeZapRequestData.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Calls into the `hash` method of `ZapRequestDataInterface` (the native Rust peer).
   *
   * Generated by deriving the `Hash` trait in Rust.
   */
  hashCode(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_uniffi_trait_hash(
            uniffiTypeZapRequestDataObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeZapRequestDataObjectFactory.pointer(this);
      uniffiTypeZapRequestDataObjectFactory.freePointer(pointer);
      uniffiTypeZapRequestDataObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is ZapRequestData {
    return uniffiTypeZapRequestDataObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeZapRequestDataObjectFactory: UniffiObjectFactory<ZapRequestDataInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): ZapRequestDataInterface {
      const instance = Object.create(ZapRequestData.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'ZapRequestData';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_zaprequestdata_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: ZapRequestDataInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: ZapRequestDataInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_clone_zaprequestdata(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_nostr_sdk_ffi_fn_free_zaprequestdata(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is ZapRequestDataInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'ZapRequestData'
      );
    },
  };
// FfiConverter for ZapRequestDataInterface
const FfiConverterTypeZapRequestData = new FfiConverterObject(
  uniffiTypeZapRequestDataObjectFactory
);

// FfiConverter for boolean | undefined
const FfiConverterOptionalBool = new FfiConverterOptional(FfiConverterBool);

// FfiConverter for UniffiDuration | undefined
const FfiConverterOptionalDuration = new FfiConverterOptional(
  FfiConverterDuration
);

// FfiConverter for /*i32*/number | undefined
const FfiConverterOptionalInt32 = new FfiConverterOptional(FfiConverterInt32);

// FfiConverter for FeeSchedules | undefined
const FfiConverterOptionalTypeFeeSchedules = new FfiConverterOptional(
  FfiConverterTypeFeeSchedules
);

// FfiConverter for Image | undefined
const FfiConverterOptionalTypeImage = new FfiConverterOptional(
  FfiConverterTypeImage
);

// FfiConverter for ImageDimensions | undefined
const FfiConverterOptionalTypeImageDimensions = new FfiConverterOptional(
  FfiConverterTypeImageDimensions
);

// FfiConverter for Limitation | undefined
const FfiConverterOptionalTypeLimitation = new FfiConverterOptional(
  FfiConverterTypeLimitation
);

// FfiConverter for LiveEventHost | undefined
const FfiConverterOptionalTypeLiveEventHost = new FfiConverterOptional(
  FfiConverterTypeLiveEventHost
);

// FfiConverter for TagClientAddress | undefined
const FfiConverterOptionalTypeTagClientAddress = new FfiConverterOptional(
  FfiConverterTypeTagClientAddress
);

// FfiConverter for WebSocketCloseFrame | undefined
const FfiConverterOptionalTypeWebSocketCloseFrame = new FfiConverterOptional(
  FfiConverterTypeWebSocketCloseFrame
);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for /*u16*/number | undefined
const FfiConverterOptionalUInt16 = new FfiConverterOptional(FfiConverterUInt16);

// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);

// FfiConverter for /*u64*/bigint | undefined
const FfiConverterOptionalUInt64 = new FfiConverterOptional(FfiConverterUInt64);

// FfiConverter for /*u8*/number | undefined
const FfiConverterOptionalUInt8 = new FfiConverterOptional(FfiConverterUInt8);

// FfiConverter for Array<Contact>
const FfiConverterArrayTypeContact = new FfiConverterArray(
  FfiConverterTypeContact
);

// FfiConverter for Array<EmojiInfo>
const FfiConverterArrayTypeEmojiInfo = new FfiConverterArray(
  FfiConverterTypeEmojiInfo
);

// FfiConverter for Array<FeeSchedule>
const FfiConverterArrayTypeFeeSchedule = new FfiConverterArray(
  FfiConverterTypeFeeSchedule
);

// FfiConverter for Array<GenericTag>
const FfiConverterArrayTypeGenericTag = new FfiConverterArray(
  FfiConverterTypeGenericTag
);

// FfiConverter for Array<Image>
const FfiConverterArrayTypeImage = new FfiConverterArray(FfiConverterTypeImage);

// FfiConverter for Array<KeysendTlvRecord>
const FfiConverterArrayTypeKeysendTLVRecord = new FfiConverterArray(
  FfiConverterTypeKeysendTLVRecord
);

// FfiConverter for Array<LookupInvoiceResponse>
const FfiConverterArrayTypeLookupInvoiceResponse = new FfiConverterArray(
  FfiConverterTypeLookupInvoiceResponse
);

// FfiConverter for Array<NegentropyItem>
const FfiConverterArrayTypeNegentropyItem = new FfiConverterArray(
  FfiConverterTypeNegentropyItem
);

// FfiConverter for Array<PayInvoiceRequest>
const FfiConverterArrayTypePayInvoiceRequest = new FfiConverterArray(
  FfiConverterTypePayInvoiceRequest
);

// FfiConverter for Array<PayKeysendRequest>
const FfiConverterArrayTypePayKeysendRequest = new FfiConverterArray(
  FfiConverterTypePayKeysendRequest
);

// FfiConverter for Array<Person>
const FfiConverterArrayTypePerson = new FfiConverterArray(
  FfiConverterTypePerson
);

// FfiConverter for Array<ReconciliationSendFailureItem>
const FfiConverterArrayTypeReconciliationSendFailureItem =
  new FfiConverterArray(FfiConverterTypeReconciliationSendFailureItem);

// FfiConverter for Array<Retention>
const FfiConverterArrayTypeRetention = new FfiConverterArray(
  FfiConverterTypeRetention
);

// FfiConverter for Array<ShippingCost>
const FfiConverterArrayTypeShippingCost = new FfiConverterArray(
  FfiConverterTypeShippingCost
);

// FfiConverter for Array<ShippingMethodRecord>
const FfiConverterArrayTypeShippingMethodRecord = new FfiConverterArray(
  FfiConverterTypeShippingMethodRecord
);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

// FfiConverter for Array</*u16*/number>
const FfiConverterArrayUInt16 = new FfiConverterArray(FfiConverterUInt16);

// FfiConverter for Map<string, JsonValue>
const FfiConverterMapStringTypeJsonValue = new FfiConverterMap(
  FfiConverterString,
  FfiConverterTypeJsonValue
);

// FfiConverter for Map<string, RelayStatus>
const FfiConverterMapStringTypeRelayStatus = new FfiConverterMap(
  FfiConverterString,
  FfiConverterTypeRelayStatus
);

// FfiConverter for Map<string, FilterInterface>
const FfiConverterMapStringTypeFilter = new FfiConverterMap(
  FfiConverterString,
  FfiConverterTypeFilter
);

// FfiConverter for Map<string, RelayInterface>
const FfiConverterMapStringTypeRelay = new FfiConverterMap(
  FfiConverterString,
  FfiConverterTypeRelay
);

// FfiConverter for Map<string, Array<ReconciliationSendFailureItem>>
const FfiConverterMapStringArrayTypeReconciliationSendFailureItem =
  new FfiConverterMap(
    FfiConverterString,
    FfiConverterArrayTypeReconciliationSendFailureItem
  );

// FfiConverter for JsonValue | undefined
const FfiConverterOptionalTypeJsonValue = new FfiConverterOptional(
  FfiConverterTypeJsonValue
);

// FfiConverter for KindStandard | undefined
const FfiConverterOptionalTypeKindStandard = new FfiConverterOptional(
  FfiConverterTypeKindStandard
);

// FfiConverter for LiveEventStatus | undefined
const FfiConverterOptionalTypeLiveEventStatus = new FfiConverterOptional(
  FfiConverterTypeLiveEventStatus
);

// FfiConverter for Marker | undefined
const FfiConverterOptionalTypeMarker = new FfiConverterOptional(
  FfiConverterTypeMarker
);

// FfiConverter for RelayMetadata | undefined
const FfiConverterOptionalTypeRelayMetadata = new FfiConverterOptional(
  FfiConverterTypeRelayMetadata
);

// FfiConverter for TagStandard | undefined
const FfiConverterOptionalTypeTagStandard = new FfiConverterOptional(
  FfiConverterTypeTagStandard
);

// FfiConverter for TransactionType | undefined
const FfiConverterOptionalTypeTransactionType = new FfiConverterOptional(
  FfiConverterTypeTransactionType
);

// FfiConverter for WebSocketMessage | undefined
const FfiConverterOptionalTypeWebSocketMessage = new FfiConverterOptional(
  FfiConverterTypeWebSocketMessage
);

// FfiConverter for EventInterface | undefined
const FfiConverterOptionalTypeEvent = new FfiConverterOptional(
  FfiConverterTypeEvent
);

// FfiConverter for EventIdInterface | undefined
const FfiConverterOptionalTypeEventId = new FfiConverterOptional(
  FfiConverterTypeEventId
);

// FfiConverter for FilterInterface | undefined
const FfiConverterOptionalTypeFilter = new FfiConverterOptional(
  FfiConverterTypeFilter
);

// FfiConverter for KindInterface | undefined
const FfiConverterOptionalTypeKind = new FfiConverterOptional(
  FfiConverterTypeKind
);

// FfiConverter for MetadataInterface | undefined
const FfiConverterOptionalTypeMetadata = new FfiConverterOptional(
  FfiConverterTypeMetadata
);

// FfiConverter for NostrSignerInterface | undefined
const FfiConverterOptionalTypeNostrSigner = new FfiConverterOptional(
  FfiConverterTypeNostrSigner
);

// FfiConverter for PublicKeyInterface | undefined
const FfiConverterOptionalTypePublicKey = new FfiConverterOptional(
  FfiConverterTypePublicKey
);

// FfiConverter for RelayOptionsInterface | undefined
const FfiConverterOptionalTypeRelayOptions = new FfiConverterOptional(
  FfiConverterTypeRelayOptions
);

// FfiConverter for SingleLetterTagInterface | undefined
const FfiConverterOptionalTypeSingleLetterTag = new FfiConverterOptional(
  FfiConverterTypeSingleLetterTag
);

// FfiConverter for SubscribeAutoCloseOptionsInterface | undefined
const FfiConverterOptionalTypeSubscribeAutoCloseOptions =
  new FfiConverterOptional(FfiConverterTypeSubscribeAutoCloseOptions);

// FfiConverter for TagInterface | undefined
const FfiConverterOptionalTypeTag = new FfiConverterOptional(
  FfiConverterTypeTag
);

// FfiConverter for TimestampInterface | undefined
const FfiConverterOptionalTypeTimestamp = new FfiConverterOptional(
  FfiConverterTypeTimestamp
);

// FfiConverter for WebSocketAdapterWrapperInterface | undefined
const FfiConverterOptionalTypeWebSocketAdapterWrapper =
  new FfiConverterOptional(FfiConverterTypeWebSocketAdapterWrapper);

// FfiConverter for Array<string> | undefined
const FfiConverterOptionalArrayString = new FfiConverterOptional(
  FfiConverterArrayString
);

// FfiConverter for Array</*u16*/number> | undefined
const FfiConverterOptionalArrayUInt16 = new FfiConverterOptional(
  FfiConverterArrayUInt16
);

// FfiConverter for Array<JsonValue>
const FfiConverterArrayTypeJsonValue = new FfiConverterArray(
  FfiConverterTypeJsonValue
);

// FfiConverter for Array<RetentionKind>
const FfiConverterArrayTypeRetentionKind = new FfiConverterArray(
  FfiConverterTypeRetentionKind
);

// FfiConverter for Array<TagStandard>
const FfiConverterArrayTypeTagStandard = new FfiConverterArray(
  FfiConverterTypeTagStandard
);

// FfiConverter for Array<ClientMessageInterface>
const FfiConverterArrayTypeClientMessage = new FfiConverterArray(
  FfiConverterTypeClientMessage
);

// FfiConverter for Array<CoordinateInterface>
const FfiConverterArrayTypeCoordinate = new FfiConverterArray(
  FfiConverterTypeCoordinate
);

// FfiConverter for Array<EventInterface>
const FfiConverterArrayTypeEvent = new FfiConverterArray(FfiConverterTypeEvent);

// FfiConverter for Array<EventIdInterface>
const FfiConverterArrayTypeEventId = new FfiConverterArray(
  FfiConverterTypeEventId
);

// FfiConverter for Array<FilterInterface>
const FfiConverterArrayTypeFilter = new FfiConverterArray(
  FfiConverterTypeFilter
);

// FfiConverter for Array<KindInterface>
const FfiConverterArrayTypeKind = new FfiConverterArray(FfiConverterTypeKind);

// FfiConverter for Array<Nip21Interface>
const FfiConverterArrayTypeNip21 = new FfiConverterArray(FfiConverterTypeNip21);

// FfiConverter for Array<PublicKeyInterface>
const FfiConverterArrayTypePublicKey = new FfiConverterArray(
  FfiConverterTypePublicKey
);

// FfiConverter for Array<ShippingMethodInterface>
const FfiConverterArrayTypeShippingMethod = new FfiConverterArray(
  FfiConverterTypeShippingMethod
);

// FfiConverter for Array<TagInterface>
const FfiConverterArrayTypeTag = new FfiConverterArray(FfiConverterTypeTag);

// FfiConverter for Array<Array<string>>
const FfiConverterArrayArrayString = new FfiConverterArray(
  FfiConverterArrayString
);

// FfiConverter for Map<string, RelayMetadata | undefined>
const FfiConverterMapStringOptionalTypeRelayMetadata = new FfiConverterMap(
  FfiConverterString,
  FfiConverterOptionalTypeRelayMetadata
);

// FfiConverter for Array<RetentionKind> | undefined
const FfiConverterOptionalArrayTypeRetentionKind = new FfiConverterOptional(
  FfiConverterArrayTypeRetentionKind
);

// FfiConverter for Array<EventIdInterface> | undefined
const FfiConverterOptionalArrayTypeEventId = new FfiConverterOptional(
  FfiConverterArrayTypeEventId
);

// FfiConverter for Array<KindInterface> | undefined
const FfiConverterOptionalArrayTypeKind = new FfiConverterOptional(
  FfiConverterArrayTypeKind
);

// FfiConverter for Array<PublicKeyInterface> | undefined
const FfiConverterOptionalArrayTypePublicKey = new FfiConverterOptional(
  FfiConverterArrayTypePublicKey
);

// FfiConverter for Array<Array<string>> | undefined
const FfiConverterOptionalArrayArrayString = new FfiConverterOptional(
  FfiConverterArrayArrayString
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 26;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_nostr_sdk_ffi_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_create_delegation_tag() !==
    29447
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_create_delegation_tag'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_decrypt_received_private_zap_message() !==
    55155
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_decrypt_received_private_zap_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_decrypt_sent_private_zap_message() !==
    30641
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_decrypt_sent_private_zap_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_extract_relay_list() !==
    28052
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_extract_relay_list'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_generate_shared_key() !==
    60318
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_generate_shared_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_get_leading_zero_bits() !==
    2779
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_get_leading_zero_bits'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_get_nip05_profile() !==
    25210
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_get_nip05_profile'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_get_nip96_server_config() !==
    4061
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_get_nip96_server_config'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_get_prefixes_for_difficulty() !==
    12958
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_get_prefixes_for_difficulty'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_gift_wrap() !== 44375
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_gift_wrap'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_gift_wrap_from_seal() !==
    30742
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_gift_wrap_from_seal'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_git_hash_version() !==
    2908
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_git_hash_version'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_init_logger() !==
    38847
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_init_logger'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_make_private_msg() !==
    13683
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_make_private_msg'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_nip04_decrypt() !==
    23337
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_nip04_decrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_nip04_encrypt() !==
    29489
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_nip04_encrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_nip11_get_information_document() !==
    40832
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_nip11_get_information_document'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_nip21_extract_from_text() !==
    18556
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_nip21_extract_from_text'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_nip44_decrypt() !==
    18954
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_nip44_decrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_nip44_encrypt() !==
    41114
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_nip44_encrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_nip57_anonymous_zap_request() !==
    19524
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_nip57_anonymous_zap_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_nip57_private_zap_request() !==
    33299
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_nip57_private_zap_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_nip96_upload() !==
    11220
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_nip96_upload'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_sign_delegation() !==
    44344
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_sign_delegation'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_tag_kind_to_string() !==
    44698
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_tag_kind_to_string'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_validate_delegation_tag() !==
    34014
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_validate_delegation_tag'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_verify_delegation_signature() !==
    217
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_verify_delegation_signature'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_func_verify_nip05() !==
    56759
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_func_verify_nip05'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_admitpolicy_admit_event() !==
    28348
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_admitpolicy_admit_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_add_discovery_relay() !==
    57691
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_add_discovery_relay'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_add_read_relay() !==
    2002
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_add_read_relay'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_add_relay() !==
    38820
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_add_relay'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_add_relay_with_opts() !==
    46063
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_add_relay_with_opts'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_add_write_relay() !==
    6818
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_add_write_relay'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_automatic_authentication() !==
    51347
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_automatic_authentication'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_connect() !==
    19131
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_connect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_connect_relay() !==
    31242
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_connect_relay'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_database() !==
    35722
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_database'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_disconnect() !==
    33822
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_disconnect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_disconnect_relay() !==
    63825
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_disconnect_relay'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_fetch_combined_events() !==
    8445
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_fetch_combined_events'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_fetch_events() !==
    22564
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_fetch_events'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_fetch_events_from() !==
    38316
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_fetch_events_from'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_fetch_metadata() !==
    7347
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_fetch_metadata'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_force_remove_all_relays() !==
    54159
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_force_remove_all_relays'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_force_remove_relay() !==
    55839
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_force_remove_relay'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_gift_wrap() !==
    35151
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_gift_wrap'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_gift_wrap_to() !==
    62984
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_gift_wrap_to'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_handle_notifications() !==
    8916
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_handle_notifications'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_relay() !==
    53414
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_relay'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_relays() !==
    53935
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_relays'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_remove_all_relays() !==
    12546
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_remove_all_relays'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_remove_relay() !==
    36133
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_remove_relay'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_send_event() !==
    58506
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_send_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_send_event_builder() !==
    23280
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_send_event_builder'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_send_event_builder_to() !==
    7719
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_send_event_builder_to'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_send_event_to() !==
    49750
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_send_event_to'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_send_msg_to() !==
    40734
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_send_msg_to'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_send_private_msg() !==
    64645
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_send_private_msg'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_send_private_msg_to() !==
    2996
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_send_private_msg_to'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_set_metadata() !==
    31801
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_set_metadata'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_shutdown() !==
    4321
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_shutdown'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_sign_event_builder() !==
    14074
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_sign_event_builder'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_signer() !==
    31951
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_signer'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_subscribe() !==
    45449
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_subscribe'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_to() !==
    19987
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_to'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_with_id() !==
    37609
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_with_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_with_id_to() !==
    8370
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_with_id_to'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_subscription() !==
    61368
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_subscription'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_subscriptions() !==
    36032
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_subscriptions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_sync() !==
    10419
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_sync'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_try_connect() !==
    8744
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_try_connect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_unsubscribe() !==
    16499
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_unsubscribe'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_unsubscribe_all() !==
    37740
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_unsubscribe_all'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_unwrap_gift_wrap() !==
    24699
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_unwrap_gift_wrap'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_client_wait_for_connection() !==
    388
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_client_wait_for_connection'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_admit_policy() !==
    1024
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_admit_policy'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_build() !==
    61424
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_build'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_database() !==
    21061
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_database'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_opts() !==
    22620
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_opts'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_signer() !==
    30905
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_signer'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_websocket_transport() !==
    48944
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_websocket_transport'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_clientmessage_as_enum() !==
    46388
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_clientmessage_as_enum'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_clientmessage_as_json() !==
    4674
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_clientmessage_as_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_connection_addr() !==
    43068
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_connection_addr'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_connection_mode() !==
    217
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_connection_mode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_connection_target() !==
    61648
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_connection_target'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_coordinate_identifier() !==
    38994
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_coordinate_identifier'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_coordinate_kind() !==
    7837
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_coordinate_kind'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_coordinate_public_key() !==
    29286
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_coordinate_public_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_coordinate_verify() !==
    52656
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_coordinate_verify'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_backend() !==
    7020
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_backend'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_get_public_key() !==
    1696
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_get_public_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_sign_event() !==
    35436
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_sign_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip04_encrypt() !==
    382
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip04_encrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip04_decrypt() !==
    58024
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip04_decrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip44_encrypt() !==
    25563
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip44_encrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip44_decrypt() !==
    7340
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip44_decrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_customwebsockettransport_support_ping() !==
    65059
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_customwebsockettransport_support_ping'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_customwebsockettransport_connect() !==
    8221
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_customwebsockettransport_connect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_decrypt() !==
    50130
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_decrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_key_security() !==
    9516
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_key_security'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_to_bech32() !==
    44747
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_to_bech32'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_version() !==
    19336
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_version'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_event_as_json() !==
    3171
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_event_as_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_event_as_pretty_json() !==
    15571
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_event_as_pretty_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_event_author() !==
    33777
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_event_author'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_event_content() !==
    63997
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_event_content'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_event_created_at() !==
    44671
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_event_created_at'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_event_id() !==
    10840
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_event_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_event_is_expired() !==
    16390
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_event_is_expired'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_event_is_protected() !==
    60470
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_event_is_protected'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_event_kind() !==
    37638
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_event_kind'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_event_signature() !==
    24839
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_event_signature'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_event_tags() !==
    32843
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_event_tags'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_event_verify() !==
    3329
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_event_verify'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_event_verify_id() !==
    50510
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_event_verify_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_event_verify_signature() !==
    21120
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_event_verify_signature'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_allow_self_tagging() !==
    57727
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_allow_self_tagging'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_build() !==
    10100
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_build'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_custom_created_at() !==
    20379
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_custom_created_at'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_dedup_tags() !==
    16426
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_dedup_tags'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_pow() !==
    47148
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_pow'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_sign() !==
    24133
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_sign'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_sign_with_keys() !==
    46872
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_sign_with_keys'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_tags() !==
    22610
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_tags'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_eventid_as_bytes() !==
    22930
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_eventid_as_bytes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_eventid_to_bech32() !==
    35036
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_eventid_to_bech32'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_eventid_to_hex() !==
    62987
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_eventid_to_hex'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_eventid_to_nostr_uri() !==
    15047
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_eventid_to_nostr_uri'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_events_contains() !==
    39963
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_events_contains'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_events_first() !==
    11892
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_events_first'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_events_is_empty() !==
    16727
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_events_is_empty'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_events_len() !==
    22082
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_events_len'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_events_merge() !==
    57155
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_events_merge'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_events_to_vec() !==
    14351
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_events_to_vec'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filemetadata_aes_256_gcm() !==
    15419
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filemetadata_aes_256_gcm'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filemetadata_blurhash() !==
    58338
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filemetadata_blurhash'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filemetadata_dimensions() !==
    7956
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filemetadata_dimensions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filemetadata_magnet() !==
    49047
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filemetadata_magnet'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filemetadata_size() !==
    53216
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filemetadata_size'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_as_json() !==
    6808
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_as_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_as_record() !==
    6560
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_as_record'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_author() !==
    30570
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_author'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_authors() !==
    55524
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_authors'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_coordinate() !==
    29286
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_coordinate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_coordinates() !==
    2599
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_coordinates'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_custom_tag() !==
    11314
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_custom_tag'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_custom_tags() !==
    44033
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_custom_tags'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_event() !==
    9919
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_events() !==
    6127
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_events'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_hashtag() !==
    45839
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_hashtag'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_hashtags() !==
    34615
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_hashtags'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_id() !==
    61970
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_identifier() !==
    32910
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_identifier'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_identifiers() !==
    38883
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_identifiers'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_ids() !==
    23011
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_ids'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_is_empty() !==
    21971
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_is_empty'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_kind() !==
    4634
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_kind'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_kinds() !==
    4092
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_kinds'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_limit() !==
    14746
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_limit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_match_event() !==
    43992
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_match_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_pubkey() !==
    17463
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_pubkey'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_pubkeys() !==
    13058
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_pubkeys'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_reference() !==
    5361
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_reference'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_references() !==
    54226
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_references'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_remove_authors() !==
    9364
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_remove_authors'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_remove_coordinates() !==
    47805
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_remove_coordinates'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_remove_custom_tags() !==
    243
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_remove_custom_tags'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_remove_events() !==
    30094
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_remove_events'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_remove_hashtags() !==
    33949
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_remove_hashtags'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_remove_identifiers() !==
    53765
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_remove_identifiers'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_remove_ids() !==
    11079
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_remove_ids'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_remove_kinds() !==
    55693
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_remove_kinds'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_remove_limit() !==
    45828
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_remove_limit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_remove_pubkeys() !==
    22880
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_remove_pubkeys'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_remove_references() !==
    62395
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_remove_references'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_remove_search() !==
    29028
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_remove_search'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_remove_since() !==
    30254
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_remove_since'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_remove_until() !==
    41736
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_remove_until'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_search() !==
    36347
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_search'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_since() !==
    19595
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_since'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_filter_until() !==
    6520
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_filter_until'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_handlenotification_handle_msg() !==
    54779
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_handlenotification_handle_msg'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_handlenotification_handle() !==
    45027
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_handlenotification_handle'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_jobfeedbackdata_amount() !==
    2543
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_jobfeedbackdata_amount'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_jobfeedbackdata_extra_info() !==
    21313
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_jobfeedbackdata_extra_info'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_jobfeedbackdata_payload() !==
    45291
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_jobfeedbackdata_payload'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_keys_public_key() !==
    21581
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_keys_public_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_keys_secret_key() !==
    60506
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_keys_secret_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_keys_sign_schnorr() !==
    55396
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_keys_sign_schnorr'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_kind_as_std() !==
    65021
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_kind_as_std'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_kind_as_u16() !==
    33899
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_kind_as_u16'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_kind_is_addressable() !==
    13541
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_kind_is_addressable'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_kind_is_ephemeral() !==
    12268
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_kind_is_ephemeral'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_kind_is_job_request() !==
    21807
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_kind_is_job_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_kind_is_job_result() !==
    3971
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_kind_is_job_result'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_kind_is_regular() !==
    26650
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_kind_is_regular'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_kind_is_replaceable() !==
    31494
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_kind_is_replaceable'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_as_json() !==
    2258
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_as_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_as_pretty_json() !==
    48195
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_as_pretty_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_as_record() !==
    2519
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_as_record'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_get_about() !==
    16385
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_get_about'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_get_banner() !==
    54057
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_get_banner'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_get_custom_field() !==
    40823
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_get_custom_field'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_get_display_name() !==
    44347
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_get_display_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_get_lud06() !==
    57088
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_get_lud06'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_get_lud16() !==
    19773
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_get_lud16'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_get_name() !==
    1699
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_get_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_get_nip05() !==
    17207
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_get_nip05'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_get_picture() !==
    20724
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_get_picture'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_get_website() !==
    21850
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_get_website'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_set_about() !==
    24342
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_set_about'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_set_banner() !==
    23479
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_set_banner'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_set_custom_field() !==
    38634
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_set_custom_field'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_set_display_name() !==
    40186
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_set_display_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_set_lud06() !==
    19232
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_set_lud06'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_set_lud16() !==
    55868
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_set_lud16'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_set_name() !==
    56705
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_set_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_set_nip05() !==
    63892
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_set_nip05'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_set_picture() !==
    64626
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_set_picture'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_metadata_set_website() !==
    57629
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_metadata_set_website'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nwc_get_balance() !==
    30742
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nwc_get_balance'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nwc_get_info() !==
    19865
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nwc_get_info'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nwc_list_transactions() !==
    15654
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nwc_list_transactions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nwc_lookup_invoice() !==
    28952
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nwc_lookup_invoice'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nwc_make_invoice() !==
    56020
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nwc_make_invoice'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nwc_pay_invoice() !==
    842
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nwc_pay_invoice'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nwc_pay_keysend() !==
    38155
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nwc_pay_keysend'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nwc_status() !==
    44132
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nwc_status'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip05profile_nip46() !==
    13517
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip05profile_nip46'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip05profile_public_key() !==
    56263
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip05profile_public_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip05profile_relays() !==
    11122
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip05profile_relays'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip19_as_enum() !==
    62711
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip19_as_enum'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_coordinate() !==
    31239
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_coordinate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_relays() !==
    53978
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_relays'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_to_bech32() !==
    787
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_to_bech32'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_to_nostr_uri() !==
    21870
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_to_nostr_uri'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip19event_author() !==
    8504
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip19event_author'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip19event_event_id() !==
    9799
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip19event_event_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip19event_kind() !==
    12835
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip19event_kind'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip19event_relays() !==
    14111
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip19event_relays'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip19event_to_bech32() !==
    12367
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip19event_to_bech32'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip19event_to_nostr_uri() !==
    31723
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip19event_to_nostr_uri'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip19profile_public_key() !==
    32958
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip19profile_public_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip19profile_relays() !==
    62720
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip19profile_relays'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip19profile_to_bech32() !==
    36717
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip19profile_to_bech32'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip19profile_to_nostr_uri() !==
    28973
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip19profile_to_nostr_uri'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip21_as_enum() !==
    7140
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip21_as_enum'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nip21_to_nostr_uri() !==
    28944
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nip21_to_nostr_uri'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_bunker_uri() !==
    57336
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_bunker_uri'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_get_public_key() !==
    16592
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_get_public_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip04_decrypt() !==
    9737
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip04_decrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip04_encrypt() !==
    32405
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip04_encrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip44_decrypt() !==
    57892
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip44_decrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip44_encrypt() !==
    7459
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip44_encrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_relays() !==
    56157
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_relays'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_sign_event() !==
    11201
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_sign_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_as_json() !==
    14883
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_as_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_description() !==
    63846
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_description'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_icons() !==
    20500
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_icons'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_url() !==
    5634
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_count() !==
    5629
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_count'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_delete() !==
    57958
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_delete'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_event_by_id() !==
    41668
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_event_by_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_metadata() !==
    5609
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_metadata'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_query() !==
    62424
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_query'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_save_event() !==
    32072
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_save_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_wipe() !==
    58001
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_wipe'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_backend() !==
    42053
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_backend'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_get_public_key() !==
    57508
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_get_public_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip04_decrypt() !==
    21362
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip04_decrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip04_encrypt() !==
    56434
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip04_encrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip44_decrypt() !==
    9052
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip44_decrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip44_encrypt() !==
    24375
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip44_encrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_sign_event() !==
    15564
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_sign_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnectoptions_connection_mode() !==
    29062
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnectoptions_connection_mode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnectoptions_timeout() !==
    18259
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnectoptions_timeout'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_lud16() !==
    20036
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_lud16'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_public_key() !==
    21325
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_public_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_relays() !==
    31357
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_relays'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_secret() !==
    15591
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_secret'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_options_autoconnect() !==
    15533
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_options_autoconnect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_options_automatic_authentication() !==
    33238
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_options_automatic_authentication'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_options_connection() !==
    11615
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_options_connection'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_options_gossip() !==
    22162
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_options_gossip'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_options_max_avg_latency() !==
    34264
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_options_max_avg_latency'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_options_relay_limits() !==
    11682
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_options_relay_limits'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_publickey_to_bech32() !==
    28181
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_publickey_to_bech32'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_publickey_to_hex() !==
    25698
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_publickey_to_hex'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_publickey_to_nostr_uri() !==
    54491
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_publickey_to_nostr_uri'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_batch_msg() !==
    32031
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_batch_msg'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_connect() !==
    29641
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_connect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_connection_mode() !==
    52002
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_connection_mode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_count_events() !==
    58311
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_count_events'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_disconnect() !==
    57306
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_disconnect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_document() !==
    30968
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_document'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_fetch_events() !==
    61339
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_fetch_events'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_is_connected() !==
    18284
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_is_connected'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_opts() !==
    21198
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_opts'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_queue() !==
    23174
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_queue'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_send_event() !==
    30621
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_send_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_send_msg() !==
    53871
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_send_msg'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_stats() !==
    58574
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_stats'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_status() !==
    52365
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_status'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_subscribe() !==
    11379
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_subscribe'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_subscribe_with_id() !==
    41014
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_subscribe_with_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_subscription() !==
    33503
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_subscription'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_subscriptions() !==
    23315
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_subscriptions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_sync() !==
    50084
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_sync'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_sync_with_items() !==
    50768
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_sync_with_items'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_try_connect() !==
    39036
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_try_connect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_unsubscribe() !==
    62991
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_unsubscribe'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_unsubscribe_all() !==
    18626
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_unsubscribe_all'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relay_url() !==
    1351
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relay_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_attempts() !==
    52060
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_attempts'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_bytes_received() !==
    157
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_bytes_received'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_bytes_sent() !==
    64970
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_bytes_sent'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_connected_at() !==
    27772
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_connected_at'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_first_connection_timestamp() !==
    32759
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_first_connection_timestamp'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_latency() !==
    14031
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_latency'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_success() !==
    52759
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_success'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_success_rate() !==
    58744
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_success_rate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_contact() !==
    33791
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_contact'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_description() !==
    55506
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_description'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_fees() !==
    52643
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_fees'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_icon() !==
    37182
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_icon'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_language_tags() !==
    5241
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_language_tags'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_limitation() !==
    63667
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_limitation'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_name() !==
    54729
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_payments_url() !==
    50516
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_payments_url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_posting_policy() !==
    57849
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_posting_policy'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_pubkey() !==
    52169
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_pubkey'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_relay_countries() !==
    43620
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_relay_countries'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_retention() !==
    48273
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_retention'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_software() !==
    34250
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_software'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_supported_nips() !==
    11144
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_supported_nips'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_tags() !==
    65245
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_tags'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_version() !==
    38302
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_version'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_num_tags() !==
    29781
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_num_tags'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_num_tags_per_kind() !==
    54489
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_num_tags_per_kind'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_size() !==
    63930
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_size'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_size_per_kind() !==
    30650
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_size_per_kind'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relaylimits_message_max_size() !==
    39217
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relaylimits_message_max_size'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relaymessage_as_enum() !==
    673
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relaymessage_as_enum'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relaymessage_as_json() !==
    14562
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relaymessage_as_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayoptions_adjust_retry_interval() !==
    25372
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayoptions_adjust_retry_interval'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayoptions_connection_mode() !==
    24699
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayoptions_connection_mode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayoptions_limits() !==
    10405
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayoptions_limits'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayoptions_max_avg_latency() !==
    58939
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayoptions_max_avg_latency'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayoptions_ping() !==
    51607
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayoptions_ping'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayoptions_read() !==
    47081
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayoptions_read'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayoptions_reconnect() !==
    48820
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayoptions_reconnect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayoptions_retry_interval() !==
    30532
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayoptions_retry_interval'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_relayoptions_write() !==
    45946
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_relayoptions_write'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_request_method() !==
    17520
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_request_method'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_request_params() !==
    39349
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_request_params'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_secretkey_encrypt() !==
    49692
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_secretkey_encrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_secretkey_to_bech32() !==
    38599
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_secretkey_to_bech32'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_secretkey_to_hex() !==
    57941
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_secretkey_to_hex'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_shippingmethod_get_shipping_cost() !==
    56592
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_shippingmethod_get_shipping_cost'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_shippingmethod_name() !==
    13755
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_shippingmethod_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_shippingmethod_regions() !==
    233
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_shippingmethod_regions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_singlelettertag_is_lowercase() !==
    53511
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_singlelettertag_is_lowercase'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_singlelettertag_is_uppercase() !==
    16786
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_singlelettertag_is_uppercase'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_stalldata_as_json() !==
    14626
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_stalldata_as_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_stalldata_as_record() !==
    30522
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_stalldata_as_record'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_stalldata_currency() !==
    40639
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_stalldata_currency'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_stalldata_description() !==
    50371
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_stalldata_description'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_stalldata_id() !==
    34671
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_stalldata_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_stalldata_name() !==
    15071
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_stalldata_name'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_stalldata_shipping() !==
    17698
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_stalldata_shipping'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_exit_policy() !==
    62279
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_exit_policy'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_idle_timeout() !==
    9446
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_idle_timeout'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_timeout() !==
    16202
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_timeout'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_subscribeoptions_close_on() !==
    54857
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_subscribeoptions_close_on'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_syncoptions_direction() !==
    15360
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_syncoptions_direction'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_syncoptions_dry_run() !==
    15725
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_syncoptions_dry_run'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_syncoptions_initial_timeout() !==
    19180
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_syncoptions_initial_timeout'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tag_as_standardized() !==
    39092
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tag_as_standardized'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tag_as_vec() !==
    22150
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tag_as_vec'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tag_content() !==
    43772
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tag_content'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tag_is_protected() !==
    61999
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tag_is_protected'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tag_is_reply() !==
    26678
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tag_is_reply'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tag_is_root() !==
    42913
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tag_is_root'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tag_kind() !==
    28437
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tag_kind'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tag_kind_str() !==
    21836
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tag_kind_str'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tag_len() !== 35144
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tag_len'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tag_single_letter_tag() !==
    50942
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tag_single_letter_tag'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tags_coordinates() !==
    39150
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tags_coordinates'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tags_event_ids() !==
    44166
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tags_event_ids'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tags_expiration() !==
    15697
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tags_expiration'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tags_filter() !==
    6442
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tags_filter'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tags_filter_standardized() !==
    23694
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tags_filter_standardized'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tags_find() !==
    19756
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tags_find'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tags_find_standardized() !==
    61199
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tags_find_standardized'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tags_first() !==
    16571
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tags_first'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tags_get() !== 2938
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tags_get'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tags_hashtags() !==
    50724
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tags_hashtags'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tags_identifier() !==
    44864
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tags_identifier'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tags_is_empty() !==
    16467
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tags_is_empty'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tags_last() !==
    22526
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tags_last'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tags_len() !==
    28453
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tags_len'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tags_public_keys() !==
    15566
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tags_public_keys'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_tags_to_vec() !==
    38520
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_tags_to_vec'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_timestamp_as_secs() !==
    7797
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_timestamp_as_secs'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_timestamp_to_human_datetime() !==
    24020
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_timestamp_to_human_datetime'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_add_signature() !==
    33695
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_add_signature'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_as_json() !==
    14388
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_as_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_as_pretty_json() !==
    3289
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_as_pretty_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_author() !==
    33632
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_author'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_content() !==
    61788
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_content'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_created_at() !==
    2838
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_created_at'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_id() !==
    26673
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_kind() !==
    24650
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_kind'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_sign() !==
    17648
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_sign'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_sign_with_keys() !==
    65226
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_sign_with_keys'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_tags() !==
    23219
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_tags'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_unwrappedgift__none() !==
    31106
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_unwrappedgift__none'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_unwrappedgift_rumor() !==
    9051
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_unwrappedgift_rumor'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_unwrappedgift_sender() !==
    65176
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_unwrappedgift_sender'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_websocketadapter_send() !==
    56567
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_websocketadapter_send'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_websocketadapter_recv() !==
    39160
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_websocketadapter_recv'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_websocketadapter_close_connection() !==
    35891
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_websocketadapter_close_connection'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_amount() !==
    38837
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_amount'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_event_id() !==
    60606
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_event_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_lnurl() !==
    11688
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_lnurl'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_message() !==
    38998
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_client_new() !==
    54751
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_client_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_clientbuilder_new() !==
    11332
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_clientbuilder_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_auth() !==
    45144
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_auth'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_close() !==
    12470
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_close'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_count() !==
    5292
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_count'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_event() !==
    35014
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_from_enum() !==
    42986
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_from_enum'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_from_json() !==
    27860
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_from_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_req() !==
    60557
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_req'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_connection_new() !==
    32544
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_connection_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_coordinate_new() !==
    25471
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_coordinate_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_coordinate_parse() !==
    59337
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_coordinate_parse'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_encryptedsecretkey_from_bech32() !==
    27546
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_encryptedsecretkey_from_bech32'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_encryptedsecretkey_new() !==
    35289
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_encryptedsecretkey_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_event_from_json() !==
    14737
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_event_from_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_articles_curation_set() !==
    36328
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_articles_curation_set'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_auth() !==
    58729
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_auth'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_award_badge() !==
    41119
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_award_badge'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_blocked_relays() !==
    57431
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_blocked_relays'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_bookmarks() !==
    63306
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_bookmarks'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_bookmarks_set() !==
    23068
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_bookmarks_set'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_channel() !==
    21555
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_channel'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_channel_metadata() !==
    54862
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_channel_metadata'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_channel_msg() !==
    33615
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_channel_msg'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_comment() !==
    7128
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_comment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_communities() !==
    54557
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_communities'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_contact_list() !==
    48706
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_contact_list'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_define_badge() !==
    89
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_define_badge'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_delete() !==
    50417
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_delete'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_emoji_set() !==
    6114
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_emoji_set'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_emojis() !==
    43073
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_emojis'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_file_metadata() !==
    8053
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_file_metadata'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_follow_set() !==
    32344
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_follow_set'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_git_issue() !==
    26026
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_git_issue'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_git_patch() !==
    34800
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_git_patch'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_git_repository_announcement() !==
    58206
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_git_repository_announcement'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_hide_channel_msg() !==
    8353
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_hide_channel_msg'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_http_auth() !==
    42464
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_http_auth'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_interest_set() !==
    54183
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_interest_set'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_interests() !==
    55071
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_interests'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_job_feedback() !==
    11871
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_job_feedback'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_job_request() !==
    14986
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_job_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_job_result() !==
    48936
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_job_result'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_label() !==
    17217
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_label'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_live_event() !==
    35589
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_live_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_live_event_msg() !==
    36293
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_live_event_msg'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_long_form_text_note() !==
    4671
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_long_form_text_note'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_metadata() !==
    34149
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_metadata'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_mute_channel_user() !==
    64300
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_mute_channel_user'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_mute_list() !==
    34705
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_mute_list'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_new() !==
    61972
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_nostr_connect() !==
    10416
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_nostr_connect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_pinned_notes() !==
    5335
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_pinned_notes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_private_msg_rumor() !==
    6901
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_private_msg_rumor'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_product_data() !==
    57627
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_product_data'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_profile_badges() !==
    15894
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_profile_badges'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_public_chats() !==
    65509
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_public_chats'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_public_zap_request() !==
    49461
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_public_zap_request'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_reaction() !==
    35984
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_reaction'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_reaction_extended() !==
    29568
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_reaction_extended'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_relay_list() !==
    56793
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_relay_list'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_relay_set() !==
    4966
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_relay_set'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_report() !==
    9803
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_report'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_repost() !==
    48340
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_repost'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_seal() !==
    55824
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_seal'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_search_relays() !==
    50345
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_search_relays'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_stall_data() !==
    14247
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_stall_data'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_text_note() !==
    19143
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_text_note'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_text_note_reply() !==
    45910
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_text_note_reply'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_videos_curation_set() !==
    19505
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_videos_curation_set'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_zap_receipt() !==
    16189
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_zap_receipt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventid_from_bytes() !==
    63077
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventid_from_bytes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventid_new() !==
    57964
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventid_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_eventid_parse() !==
    39522
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_eventid_parse'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_filemetadata_new() !==
    27821
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_filemetadata_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_filter_from_json() !==
    60806
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_filter_from_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_filter_from_record() !==
    32151
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_filter_from_record'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_filter_new() !==
    58026
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_filter_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_jobfeedbackdata_new() !==
    39189
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_jobfeedbackdata_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_keys_from_mnemonic() !==
    25690
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_keys_from_mnemonic'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_keys_generate() !==
    61718
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_keys_generate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_keys_new() !==
    46666
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_keys_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_keys_parse() !==
    27763
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_keys_parse'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_kind_from_std() !==
    49333
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_kind_from_std'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_kind_new() !==
    53039
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_kind_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_metadata_from_json() !==
    44036
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_metadata_from_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_metadata_from_record() !==
    29877
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_metadata_from_record'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_metadata_new() !==
    52664
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_metadata_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nwc_new() !==
    24213
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nwc_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nwc_with_opts() !==
    29036
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nwc_with_opts'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nip19_from_bech32() !==
    12847
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nip19_from_bech32'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nip19coordinate_from_bech32() !==
    9233
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nip19coordinate_from_bech32'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nip19coordinate_from_nostr_uri() !==
    4130
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nip19coordinate_from_nostr_uri'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nip19coordinate_new() !==
    56049
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nip19coordinate_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_from_bech32() !==
    48940
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_from_bech32'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_from_event() !==
    59343
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_from_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_from_nostr_uri() !==
    20420
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_from_nostr_uri'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_new() !==
    20553
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nip19profile_from_bech32() !==
    56532
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nip19profile_from_bech32'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nip19profile_from_nostr_uri() !==
    54372
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nip19profile_from_nostr_uri'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nip19profile_new() !==
    23364
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nip19profile_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nip21_parse() !==
    2093
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nip21_parse'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnect_new() !==
    60022
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnect_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnectmetadata_new() !==
    55577
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnectmetadata_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnecturi_parse() !==
    36627
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnecturi_parse'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nostrdatabase_lmdb() !==
    21752
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nostrdatabase_lmdb'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_custom() !==
    7081
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_custom'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_keys() !==
    41683
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_keys'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_nostr_connect() !==
    3051
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_nostr_connect'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnectoptions_new() !==
    35456
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnectoptions_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnecturi_new() !==
    61620
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnecturi_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnecturi_parse() !==
    31940
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnecturi_parse'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_options_new() !==
    30503
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_options_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_publickey_from_bytes() !==
    38006
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_publickey_from_bytes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_publickey_parse() !==
    50593
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_publickey_parse'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_relayinformationdocument_new() !==
    44412
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_relayinformationdocument_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_relaylimits_disable() !==
    39641
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_relaylimits_disable'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_relaylimits_new() !==
    1364
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_relaylimits_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_auth() !==
    49391
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_auth'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_closed() !==
    12776
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_closed'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_count() !==
    38897
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_count'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_eose() !==
    61100
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_eose'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_event() !==
    41233
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_from_enum() !==
    34939
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_from_enum'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_from_json() !==
    52163
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_from_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_notice() !==
    17916
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_notice'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_ok() !==
    56502
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_ok'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_relayoptions_new() !==
    32157
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_relayoptions_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_request_new() !==
    22154
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_request_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_request_parse() !==
    38336
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_request_parse'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_secretkey_from_bytes() !==
    33002
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_secretkey_from_bytes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_secretkey_generate() !==
    2297
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_secretkey_generate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_secretkey_parse() !==
    41672
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_secretkey_parse'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_shippingmethod_new() !==
    54442
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_shippingmethod_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_singlelettertag_lowercase() !==
    25781
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_singlelettertag_lowercase'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_singlelettertag_uppercase() !==
    26245
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_singlelettertag_uppercase'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_stalldata_from_json() !==
    26421
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_stalldata_from_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_stalldata_from_record() !==
    10070
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_stalldata_from_record'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_stalldata_new() !==
    11283
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_stalldata_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_subscribeautocloseoptions_new() !==
    39595
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_subscribeautocloseoptions_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_subscribeoptions_new() !==
    56214
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_subscribeoptions_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_syncoptions_new() !==
    7169
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_syncoptions_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_alt() !==
    61627
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_alt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_client() !==
    18574
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_client'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_coordinate() !==
    40153
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_coordinate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_custom() !==
    55533
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_custom'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_description() !==
    31007
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_description'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_event() !==
    3596
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_event_report() !==
    12542
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_event_report'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_expiration() !==
    25703
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_expiration'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_from_standardized() !==
    10696
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_from_standardized'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_hashtag() !==
    56828
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_hashtag'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_identifier() !==
    5344
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_identifier'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_image() !==
    35229
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_image'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_parse() !==
    63294
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_parse'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_pow() !==
    46606
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_pow'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_protected() !==
    21460
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_protected'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_public_key() !==
    4984
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_public_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_public_key_report() !==
    44501
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_public_key_report'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_reference() !==
    43166
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_reference'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_relay_metadata() !==
    64762
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_relay_metadata'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tag_title() !==
    51619
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tag_title'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tags_from_list() !==
    61074
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tags_from_list'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tags_from_text() !==
    30575
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tags_from_text'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_tags_parse() !==
    21642
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_tags_parse'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_from_secs() !==
    64753
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_from_secs'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_now() !==
    13059
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_now'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_unsignedevent_from_json() !==
    8735
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_unsignedevent_from_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_unwrappedgift_from_gift_wrap() !==
    4603
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_unwrappedgift_from_gift_wrap'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_websocketadapterwrapper_new() !==
    27365
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_websocketadapterwrapper_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_nostr_sdk_ffi_checksum_constructor_zaprequestdata_new() !==
    17704
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_nostr_sdk_ffi_checksum_constructor_zaprequestdata_new'
    );
  }

  uniffiCallbackInterfaceAdmitPolicy.register();
  uniffiCallbackInterfaceCustomNostrSigner.register();
  uniffiCallbackInterfaceCustomWebSocketTransport.register();
  uniffiCallbackInterfaceHandleNotification.register();
  uniffiCallbackInterfaceWebSocketAdapter.register();
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeAdmitPolicy,
    FfiConverterTypeAdmitStatus,
    FfiConverterTypeAlphabet,
    FfiConverterTypeArticlesCuration,
    FfiConverterTypeBookmarks,
    FfiConverterTypeClient,
    FfiConverterTypeClientBuilder,
    FfiConverterTypeClientMessage,
    FfiConverterTypeClientMessageEnum,
    FfiConverterTypeConnection,
    FfiConverterTypeConnectionMode,
    FfiConverterTypeConnectionTarget,
    FfiConverterTypeContact,
    FfiConverterTypeCoordinate,
    FfiConverterTypeCustomNostrSigner,
    FfiConverterTypeCustomWebSocketTransport,
    FfiConverterTypeDataVendingMachineStatus,
    FfiConverterTypeEmojiInfo,
    FfiConverterTypeEmojis,
    FfiConverterTypeEncryptedSecretKey,
    FfiConverterTypeEncryptedSecretKeyVersion,
    FfiConverterTypeErrorCode,
    FfiConverterTypeEvent,
    FfiConverterTypeEventBuilder,
    FfiConverterTypeEventDeletionRequest,
    FfiConverterTypeEventId,
    FfiConverterTypeEvents,
    FfiConverterTypeExternalContentId,
    FfiConverterTypeExternalIdentity,
    FfiConverterTypeExtractedComment,
    FfiConverterTypeFeeSchedule,
    FfiConverterTypeFeeSchedules,
    FfiConverterTypeFileMetadata,
    FfiConverterTypeFilter,
    FfiConverterTypeFilterRecord,
    FfiConverterTypeGenericTag,
    FfiConverterTypeGetBalanceResponse,
    FfiConverterTypeGetInfoResponse,
    FfiConverterTypeGitIssue,
    FfiConverterTypeGitPatch,
    FfiConverterTypeGitPatchCommitter,
    FfiConverterTypeGitPatchContent,
    FfiConverterTypeGitRepositoryAnnouncement,
    FfiConverterTypeHandleNotification,
    FfiConverterTypeHttpData,
    FfiConverterTypeHttpMethod,
    FfiConverterTypeIdentity,
    FfiConverterTypeImage,
    FfiConverterTypeImageDimensions,
    FfiConverterTypeInterests,
    FfiConverterTypeJobFeedbackData,
    FfiConverterTypeJsonValue,
    FfiConverterTypeKeySecurity,
    FfiConverterTypeKeys,
    FfiConverterTypeKeysendTLVRecord,
    FfiConverterTypeKind,
    FfiConverterTypeKindStandard,
    FfiConverterTypeLimitation,
    FfiConverterTypeListTransactionsRequest,
    FfiConverterTypeLiveEvent,
    FfiConverterTypeLiveEventHost,
    FfiConverterTypeLiveEventMarker,
    FfiConverterTypeLiveEventStatus,
    FfiConverterTypeLogLevel,
    FfiConverterTypeLookupInvoiceRequest,
    FfiConverterTypeLookupInvoiceResponse,
    FfiConverterTypeMakeInvoiceRequest,
    FfiConverterTypeMakeInvoiceResponse,
    FfiConverterTypeMarker,
    FfiConverterTypeMetadata,
    FfiConverterTypeMetadataRecord,
    FfiConverterTypeMethod,
    FfiConverterTypeMultiPayInvoiceRequest,
    FfiConverterTypeMultiPayKeysendRequest,
    FfiConverterTypeMuteList,
    FfiConverterTypeNIP47Error,
    FfiConverterTypeNWC,
    FfiConverterTypeNegentropyItem,
    FfiConverterTypeNip05Profile,
    FfiConverterTypeNip19,
    FfiConverterTypeNip19Coordinate,
    FfiConverterTypeNip19Enum,
    FfiConverterTypeNip19Event,
    FfiConverterTypeNip19Profile,
    FfiConverterTypeNip21,
    FfiConverterTypeNip21Enum,
    FfiConverterTypeNip44Version,
    FfiConverterTypeNip46Request,
    FfiConverterTypeNostrConnect,
    FfiConverterTypeNostrConnectMessage,
    FfiConverterTypeNostrConnectMetadata,
    FfiConverterTypeNostrConnectURI,
    FfiConverterTypeNostrDatabase,
    FfiConverterTypeNostrSigner,
    FfiConverterTypeNostrWalletConnectOptions,
    FfiConverterTypeNostrWalletConnectURI,
    FfiConverterTypeOptions,
    FfiConverterTypeOutput,
    FfiConverterTypePayInvoiceRequest,
    FfiConverterTypePayInvoiceResponse,
    FfiConverterTypePayKeysendRequest,
    FfiConverterTypePayKeysendResponse,
    FfiConverterTypePerson,
    FfiConverterTypeProductData,
    FfiConverterTypeProtocol,
    FfiConverterTypePublicKey,
    FfiConverterTypeReconciliation,
    FfiConverterTypeReconciliationOutput,
    FfiConverterTypeReconciliationSendFailureItem,
    FfiConverterTypeRejectedReason,
    FfiConverterTypeRelay,
    FfiConverterTypeRelayConnectionStats,
    FfiConverterTypeRelayInformationDocument,
    FfiConverterTypeRelayLimits,
    FfiConverterTypeRelayMessage,
    FfiConverterTypeRelayMessageEnum,
    FfiConverterTypeRelayMetadata,
    FfiConverterTypeRelayOptions,
    FfiConverterTypeRelayStatus,
    FfiConverterTypeReport,
    FfiConverterTypeReqExitPolicy,
    FfiConverterTypeRequest,
    FfiConverterTypeRequestParams,
    FfiConverterTypeResponse,
    FfiConverterTypeResponseResult,
    FfiConverterTypeRetention,
    FfiConverterTypeRetentionKind,
    FfiConverterTypeSaveEventStatus,
    FfiConverterTypeSecretKey,
    FfiConverterTypeSendEventOutput,
    FfiConverterTypeServerConfig,
    FfiConverterTypeShippingCost,
    FfiConverterTypeShippingMethod,
    FfiConverterTypeShippingMethodRecord,
    FfiConverterTypeSignerBackend,
    FfiConverterTypeSingleLetterTag,
    FfiConverterTypeStallData,
    FfiConverterTypeStallDataRecord,
    FfiConverterTypeSubscribeAutoCloseOptions,
    FfiConverterTypeSubscribeOptions,
    FfiConverterTypeSubscribeOutput,
    FfiConverterTypeSyncDirection,
    FfiConverterTypeSyncOptions,
    FfiConverterTypeTag,
    FfiConverterTypeTagClientAddress,
    FfiConverterTypeTagKind,
    FfiConverterTypeTagStandard,
    FfiConverterTypeTags,
    FfiConverterTypeTimestamp,
    FfiConverterTypeTransactionType,
    FfiConverterTypeUnsignedEvent,
    FfiConverterTypeUnwrappedGift,
    FfiConverterTypeWebSocketAdapter,
    FfiConverterTypeWebSocketAdapterWrapper,
    FfiConverterTypeWebSocketCloseFrame,
    FfiConverterTypeWebSocketMessage,
    FfiConverterTypeZapRequestData,
    FfiConverterTypeZapType,
  },
});
